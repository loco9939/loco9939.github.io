
<!DOCTYPE html>
<html lang="ko">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Loco&#39;s Dev Blog">
    <title>아카이브 - Loco&#39;s Dev Blog</title>
    <meta name="author" content="loco9939">
    
        <meta name="keywords" content="loco9939,javascript,">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Loco&#39;s Dev Blog">
<meta property="og:url" content="https://loco9939.github.io/archives/page/12/index.html">
<meta property="og:site_name" content="Loco&#39;s Dev Blog">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="loco9939">
<meta property="article:tag" content="loco9939">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-alaac2o0p8lb5n7mx8aazw1dzhwcsltexgjtf9twurzytkujqiefoq1soijy.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Loco&#39;s Dev Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/24/Javascript/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3/"
                            aria-label=": 클래스"
                        >
                            클래스
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-24T18:50:32+09:00">
	
		    2022/08/24
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="클래스와-생성자-함수"><a href="#클래스와-생성자-함수" class="headerlink" title="클래스와 생성자 함수"></a>클래스와 생성자 함수</h1><table>
<thead>
<tr>
<th>구분</th>
<th>클래스</th>
<th>생성자함수</th>
</tr>
</thead>
<tbody><tr>
<td>new 연산자</td>
<td>무조건 쓴다. 안쓰면 에러</td>
<td>쓰면 생성자 함수, 안쓰면 일반함수</td>
</tr>
<tr>
<td>extends &amp; super</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>호이스팅</td>
<td>let,const 처럼 변수 호이스팅</td>
<td>선언문 → 함수 호출 &#x2F; 표현식 → 변수 호이스팅</td>
</tr>
<tr>
<td>strict mode</td>
<td>O</td>
<td>X</td>
</tr>
<tr>
<td>내부 메서드들의[[Enumerable]]</td>
<td>false</td>
<td>true</td>
</tr>
</tbody></table>
<p>내가 객체를 만드는 방법이 5가지나 아는데 어떠한 근거로 이 방법으로 객체를 만들것인지 생각하여 선택해야한다.</p>
<p><strong>⇒ 다양한 문법 상황에서 현재 상황에 맞는 것을 끄집어 내는 것이 중요하다.</strong></p>
<p>만약 인스턴스 여러개 만들 상황이라면 우리는 생성자 함수를 쓸것이냐? 클래스를 쓸 것이냐 ? 선택해야한다.</p>
<p>그렇다면 생성자 함수랑 클래스가 동일한 동작을 하는 문법적 설탕일까?</p>
<p>즉, 이말은 두개가 동일한 동작을 하니 둘중 아무거나 써도될까?</p>
<p>⇒ <strong>아니다… 왜? 위와 같은 이유때문에!</strong></p>
<aside>
💡 엄격한 조건을 갖는 클래스를 사용하는 것이 더 적절하다.

<p><strong>에러를 빨리 내는 것이 유리하지 런타임에 에러나는 것은 별로다.</strong></p>
</aside>

<p><strong>항상 왜 A 방법 대신 B 방법을 쓰는것인지 이유를 알아내야한다.</strong></p>
<p>이벤트핸들러 내부의 this는 이벤트 핸들러를 바인딩한 내부를 가리킨다.</p>
<p>애플리케이션의 그릇으로 class를 사용하는 것은 부적절하다. ⇒ this가 꼬여서</p>
<p>클래스를 문법적 설탕이라고 보기보다는 새로운 객체 생성 메커니즘으로 보는 것이 합당하다.</p>
<aside>
💡 문법적 설탕이란? 똑같이 동작하는데 서로 다른 것을 문법적 설탕이라고 한다. 문법적인 편의성을 주는 것이다.

</aside>

<hr>
<h1 id="클래스-호이스팅"><a href="#클래스-호이스팅" class="headerlink" title="클래스 호이스팅"></a>클래스 호이스팅</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스 선언문</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>클래스도 함수이다. 클래스 선언문으로 정의한 클래스는 함수 선언문과 같이 런타임 이전에 먼저 평가되어 함수 객체를 생성한다. <strong>함수 호이스팅이 발생</strong>한다.</p>
<p>이 때 클래스가 평가되어 생성된 함수 객체는 constructor다. constructor는 생성자 함수로서 호출될 수 있으므로 <strong>함수 정의가 평가될 때 더불어 프로토타입도 생성된다.</strong></p>
<aside>
💡 프로토타입과 생성자함수는 언제나 쌍으로 존재한다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스 선언문</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Person</span>); <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<ul>
<li>클래스는 let,const 키워드로 선언한 변수처럼 호이스팅 현상이 발생한다.(TDZ) 그러므로 클래스 정의 이전에 참조할 수 없다.</li>
</ul>
<hr>
<h1 id="클래스-메서드"><a href="#클래스-메서드" class="headerlink" title="클래스 메서드"></a>클래스 메서드</h1><h2 id="1-counstructor-생성자-메서드"><a href="#1-counstructor-생성자-메서드" class="headerlink" title="1. counstructor(생성자) 메서드"></a>1. counstructor(생성자) 메서드</h2><p>constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드다.</p>
<ul>
<li>constructor는 <span style="color:red">이름을 변경할 수 없다.</span></li>
<li>유일하게 하나만 존재할 수 있다.</li>
<li>생략할 수 있다. 생략시 빈 constructor에 의해 빈 객체를 생성한다.</li>
<li>constructor는 <span style="color:red"><strong>return문 반드시 생략한다.</strong></span> 생성자 함수와 동일하게 암묵적으로 this를 반환하기 때문에 다른 객체를 return 할 시 인스턴스가 반환되지 못할 수 있다.</li>
<li>프로퍼티 추가하여 초기화한 인스턴스 생성하려면 constructor 내부에서 this에 인스턴스 프로퍼티를 추가한다. <strong>(이 경우 constructor 생략 불가)</strong></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>생성자 함수와 마찬가지로 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스 프로퍼티가 된다.</p>
<ul>
<li>constructor 내부의 this는 클래스가 미래에 생성할 인스턴스를 가리킨다.</li>
</ul>
<p>constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다.</p>
<p>⇒ constructor가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.</p>
<aside>
💡 클래스의 constructor ≠ 프토로타입의 constructor 프로퍼티

</aside>

<h2 id="2-프로토타입-메서드"><a href="#2-프로토타입-메서드" class="headerlink" title="2. 프로토타입 메서드"></a>2. 프로토타입 메서드</h2><p>생성자 함수와 달리 Person.prototype.sayHi 이런식으로 추가하지 않아도 기본적으로 프로토타입 메서드가 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메서드</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Lee</span></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// me 객체의 프로토타입은 Person.prototype이다.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(me) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br><span class="line">me <span class="keyword">instanceof</span> <span class="title class_">Person</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Person.prototype의 프로토타입은 Object.prototype이다.</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// -&gt; true</span></span><br><span class="line">me <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// me 객체의 constructor는 Person 클래스다.</span></span><br><span class="line">me.<span class="property">constructor</span> === <span class="title class_">Person</span>; <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>생성자 함수와 마찬가지로 인스턴스는 프로토타입 체인의 일원이된다.</li>
</ul>
<h2 id="3-정적-메서드"><a href="#3-정적-메서드" class="headerlink" title="3. 정적 메서드"></a>3. 정적 메서드</h2><p>정적 메서드는 인스턴스를 생성하지 않고 호출할 수 있는 메서드이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 메서드 호출</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHi</span>(); <span class="comment">// Hi!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 정적 메서드</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성없이 호출 가능</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">sayHi</span>(); <span class="comment">// Hi!</span></span><br></pre></td></tr></table></figure>

<ul>
<li>클래스에서는 static 키워드만 붙이면 정적 메서드(클래스 메서드)가 된다.</li>
</ul>
<h2 id="정적-메서드와-프로토타입-메서드-차이"><a href="#정적-메서드와-프로토타입-메서드-차이" class="headerlink" title="정적 메서드와 프로토타입 메서드 차이"></a>정적 메서드와 프로토타입 메서드 차이</h2><ol>
<li>이 둘은 각자 속해있는 프로토타입 체인이 다르다</li>
<li>정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.</li>
<li>정적 메서드는 인스턴스 프로퍼티 참조 불가하지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 생성자</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메서드</span></span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 정적 메서드</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hi!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;kim&quot;</span>);</span><br><span class="line"></span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is kim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드는 인스턴스 프로퍼티인 name을 참조할 수 있다.</span></span><br></pre></td></tr></table></figure>

<p>또한 프로토타입 메서드 내부의 this는 메서드를 호출한 인스턴스에 바인딩 되지만, 정적 메서드는 클래스로 호출해야하므로 <strong>정적 메서드 내부의 this는 인스턴스가 아닌 클래스에 바인딩</strong>된다.</p>
<ul>
<li>인스턴스 프로퍼티 참조해야한다 → <strong>프로토타입 메서드</strong></li>
<li>인스턴스 프로퍼티 참조 불필요 → <strong>정적 메서드</strong></li>
</ul>
<h2 id="클래스에서-정의한-메서드-특징"><a href="#클래스에서-정의한-메서드-특징" class="headerlink" title="클래스에서 정의한 메서드 특징"></a>클래스에서 정의한 메서드 특징</h2><ol>
<li>메서드 축약표현 사용</li>
<li>클래스에 메서드 정의시 콤마 필요없다</li>
<li>암묵적 strict mode</li>
<li>프로퍼티 어트리뷰트 [[Enumerable]] 값이 false로 열거 불가능</li>
<li>메서드 축약 표현 사용했으므로 non-constructor이다. new 연산자와 호출 불가</li>
</ol>
<hr>
<h1 id="프로퍼티"><a href="#프로퍼티" class="headerlink" title="프로퍼티"></a>프로퍼티</h1><h2 id="인스턴스-프로퍼티"><a href="#인스턴스-프로퍼티" class="headerlink" title="인스턴스 프로퍼티"></a>인스턴스 프로퍼티</h2><p>인스턴스 프로퍼티는 constructor 내부에서 정의해야한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// 인스턴스 프로퍼티 =&gt; public 하다.</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me); <span class="comment">// Person &#123;name: &quot;Lee&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>constructor 내부의 코드가 실행되기 이전에 빈 객체가 생성되고 this가 바인딩되어 있다.</p>
<ul>
<li>자바스크립트 클래스는 접근 제한자를 제공하지 않아 <strong>인스턴스 프로퍼티는 언제나 public하다.</strong></li>
</ul>
<h2 id="접근자-프로퍼티"><a href="#접근자-프로퍼티" class="headerlink" title="접근자 프로퍼티"></a>접근자 프로퍼티</h2><p>자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수들로 구성된 프로퍼티이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">firstName, lastName</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">lastName</span> = lastName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티다.</span></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Ungmo&quot;</span>, <span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;me.firstName&#125;</span> <span class="subst">$&#123;me.lastName&#125;</span>`</span>); <span class="comment">// Ungmo Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">me.<span class="property">fullName</span> = <span class="string">&quot;Heegun Lee&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me); <span class="comment">// &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">fullName</span>); <span class="comment">// Heegun Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;fullName&quot;</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>클래스 메서드는 기본적으로 프로토타입 메서드가 되므로 접근자 프로퍼티도 인스턴스 프로퍼티가 아닌 <strong>프로토타입 프로퍼티</strong>가 된다.</li>
</ul>
<h1 id="클래스-필드-정의"><a href="#클래스-필드-정의" class="headerlink" title="클래스 필드 정의"></a>클래스 필드 정의</h1><p>클래스 필드란, 클래스 기반 객체지향 언어에서 클래스가 생성할 인스턴스의 프로퍼티를 가리키는 용어이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 클래스 필드 정의</span></span><br><span class="line">  name = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br></pre></td></tr></table></figure>

<aside>
💡 클래스 몸체에서 클래스 필드 정의시 this에 클래스 필드를 바인딩해서는 안된다. this는 constructor와 메서드 내부에서만 유효하다.

</aside>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// 클래스 필드에 문자열을 할당</span></span><br><span class="line">  name = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클래스 필드에 함수를 할당</span></span><br><span class="line">  getName = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 화살표 함수로 정의할 수도 있다.</span></span><br><span class="line">  <span class="comment">// getName = () =&gt; this.name;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me); <span class="comment">// Person &#123;name: &quot;Lee&quot;, getName: ƒ&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">getName</span>()); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>

<ul>
<li>함수는 일급 객체이므로 함수를 클래스 필드에 할당할 수 있다.</li>
</ul>
<p>단, 이 경우 프로토타입 메서드가 아닌 인스턴스 메서드가 된다.</p>
<h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><ul>
<li>인스턴스 생성시 클래스 필드 this 초기화 필요하다면 constructor에서 인스턴스 프로퍼티 정의</li>
<li>클래스 필드 this 초기화 필요 없다면 기존 방식과 클래스 필드 정의 방식 모두 사용 가능</li>
</ul>
<p>추가로 클래스 필드에 정의하여 고정 초기값을 주고 constructor에 정의하여 this 바인딩 해주는 것들 구분하면 좋다.</p>
<h2 id="private-필드-정의-제안"><a href="#private-필드-정의-제안" class="headerlink" title="private 필드 정의 제안"></a>private 필드 정의 제안</h2><p>자바스크립트는 캡슐화를 안전하게 지원하지 않는다. 인스턴스 여러개 생성시 프로퍼티 상태를 유지하지 못하는 문제점 등이 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// private 필드 정의</span></span><br><span class="line">  #name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="comment">// private 필드 참조</span></span><br><span class="line">    <span class="variable language_">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// private 필드 #name은 클래스 외부에서 참조할 수 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.#name);</span><br><span class="line"><span class="comment">// SyntaxError: Private field &#x27;#name&#x27; must be declared in an enclosing class</span></span><br></pre></td></tr></table></figure>

<ul>
<li>private 필드 정의는 식별자 앞에 #을 붙혀 정의한다.</li>
<li>private 필드는 클래스 내부에서만 참조할 수 있다.</li>
<li>private 필드는 constructor 내부가 아닌 반드시 클래스 몸체에 정의해야한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="comment">// private 필드 정의</span></span><br><span class="line">  #name = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.#name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// name은 접근자 프로퍼티다.</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">name</span>() &#123;</span><br><span class="line">    <span class="comment">// private 필드를 참조하여 trim한 다음 반환한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.#name.<span class="title function_">trim</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot; Lee &quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">name</span>); <span class="comment">// Lee</span></span><br></pre></td></tr></table></figure>

<ul>
<li>접근자 프로퍼티를 통해 간접적으로 접근하는 방법은 유효하다.</li>
</ul>
<h2 id="static-필드-정의-제안"><a href="#static-필드-정의-제안" class="headerlink" title="static 필드 정의 제안"></a>static 필드 정의 제안</h2><p>static private 필드 , static public 필드, static private 메서드를 정의할 수 있다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyMath</span> &#123;</span><br><span class="line">  <span class="comment">// static public 필드 정의</span></span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">PI</span> = <span class="number">22</span> / <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static private 필드 정의</span></span><br><span class="line">  <span class="keyword">static</span> #num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static 메서드</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ++<span class="title class_">MyMath</span>.#num;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyMath</span>.<span class="property">PI</span>); <span class="comment">// 3.142857142857143</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">MyMath</span>.<span class="title function_">increment</span>()); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/24/Javascript/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A2%E1%84%89%E1%85%B3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/23/Javascript/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A5/"
                            aria-label=": 클로저"
                        >
                            클로저
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-23T17:53:41+09:00">
	
		    2022/08/23
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p>함수를 일급 객체로 취급하는 함수형 프로그래밍 언어(하스켈, 리스프, 얼랭, 스칼라 등)에서 사용되는 중요한 특성이다.</p>
<p>클로저는 자바스크립트의 고유의 개념이 아니므로 ECMAScript 사양에 등장하지 않는다.</p>
<blockquote>
<p>클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.</p>
</blockquote>
<h1 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h1><p>자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 <strong>함수를 어디에 정의했는지에 따라 상위 스코프를 결정</strong>한다. 이를 렉시컬 스코프라고 한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="title function_">bar</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// ?</span></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure>

<p>foo함수와 bar함수 모두 전역에서 정의된 전역 함수이다. 함수의 상위 스코프는 <span style="color:red">함수를 어디서 정의했는지에 따라 결정되니</span> 두 함수의 상위 스코프는 전역 스코프이다. 이는 정적이며 변하지 않는다.</p>
<p>즉, 함수의 상위 스코프를 결정한다는 것은 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 값이 바로 상위 렉시컬 환경에 대한 참조이며 이것이 상위 스코프이다.</p>
<h1 id="함수-객체의-내부슬롯-Environment"><a href="#함수-객체의-내부슬롯-Environment" class="headerlink" title="함수 객체의 내부슬롯 [[Environment]]"></a>함수 객체의 내부슬롯 [[Environment]]</h1><p>함수는 자신의 내부슬롯 [[Environment]] 에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다.</p>
<p>즉, 함수 정의가 평가되어 함수 객체를 생성할 때 <strong>자신이 정의된 환경에 의해 결정된 상위 스코프의 참조</strong>를 함수 객체 자신의 내부 슬롯 [[Environment]] 에 저장한다.</p>
<p><strong>이 때, 내부 슬롯 [[Environment]] 에 저장된 상위 스코프의 참조는 <span style="color:red">현재 실행중인 실행 컨텍스트의 렉시컬 환경</span>을 가리킨다.</strong></p>
<p>왜냐하면, 함수 정의가 평가되어 함수 객체를 생성하는 시점은 함수가 정의된 환경 즉, 상위함수나 전역 코드가 평가 또는 실행되고 있는 시점이므로 이 때 실행중인 실행 컨텍스트는 상위 함수 또는 전역 코드의 실행 컨텍스트 이기 때문이다.</p>
<p><strong>이해 중요</strong></p>
<p><strong>따라서 함수 객체의 내부 슬롯 [[Environment]] 에 저장된 현재 실행중인 실행 컨텍스트의 렉시컬 환경의 참조가 상위 스코프이다. 또한 자신이 호출되었을 때 생성될 함수 렉시컬 환경의 “외부 렉시컬 환경에 대한 참조”에 저장될 참조값이 현재 실행중인 실행 컨텍스트의 렉시컬 환경의 참조이다.</strong></p>
<h1 id="클로저와-렉시컬-환경"><a href="#클로저와-렉시컬-환경" class="headerlink" title="클로저와 렉시컬 환경"></a>클로저와 렉시컬 환경</h1><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ①</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">const</span> inner = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;; <span class="comment">// ②</span></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// outer 함수를 호출하면 중첩 함수 inner를 반환한다.</span></span><br><span class="line"><span class="comment">// 그리고 outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 팝되어 제거된다.</span></span><br><span class="line"><span class="comment">// 아직 중첩함수 호출도 안해봤는데 외부함수가 생명주기 다한 것이다.</span></span><br><span class="line"><span class="keyword">const</span> innerFunc = <span class="title function_">outer</span>(); <span class="comment">// ③</span></span><br><span class="line"><span class="title function_">innerFunc</span>(); <span class="comment">// ④ 10</span></span><br></pre></td></tr></table></figure>

<p>outer 함수 호출하면 inner 함수 반환하고 생명주기를 마감한다. 즉 outer 함수의 실행이 종료되면 outer함수의 실행 컨텍스트가 pop 되어 제거된다. 이 때 outer 함수의 지역변수 x와 값 10을 저장하고 있던 outer 함수의 실행컨텍스트가 제거되어서 이들 또한 생명주기를 마감한다. 따라서 outer 함수의 지역변수 x는 더 이상 유효하지 않게되어 접근할 방법이 없어보인다.</p>
<p>하지만 위 코드의 결과 outer 함수의 지역 변수 x의 값인 10이 출력되는 것을 볼 수 있다.마치 제거된 지역변수 x가 되살아 난 것 처럼 말이다.</p>
<p>이처럼 <strong>외부함수보다 중첩함수가 더 오래 유지되는 경우 중첩 함수는 이미 생명주기가 종료한 외부함수의 변수를 참조할 수 있다. 이러한 중첩함수를 클로저</strong>라고 한다.</p>
<h1 id="모든-함수는-클로저다"><a href="#모든-함수는-클로저다" class="headerlink" title="모든 함수는 클로저다?"></a>모든 함수는 클로저다?</h1><p>이론적으로 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저라고 볼 수 있다.</p>
<p>하지만 다음 조건을 만족하는 경우에만 클로저라고 한다.</p>
<ul>
<li>중첩함수가 상위 스코프의 식별자를 참조하는 경우여야한다.</li>
<li>중첩함수가 외부함수보다 생명주기가 더 길어야한다.</li>
</ul>
<h1 id="클로저의-활용"><a href="#클로저의-활용" class="headerlink" title="클로저의 활용"></a>클로저의 활용</h1><p><strong>클로저는 상태를 안전하게 변경하고 유지하기 위해 사용한다.</strong> 다시 말해 <strong>상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉</strong>하고 <strong>특정 함수에게만 상태 변경을 허용</strong>하기 위해 사용한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 카운트 상태 변경 함수</span></span><br><span class="line"><span class="keyword">const</span> increase = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 카운트 상태 변수</span></span><br><span class="line">  <span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클로저</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 카운트 상태를 1만큼 증가 시킨다.</span></span><br><span class="line">    <span class="keyword">return</span> ++num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">increase</span>()); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">increase</span>()); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">increase</span>()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>위 코드 실행되면 즉시실행함수가 호출되고 즉시실행함수가 반환한 함수가 increase 식별자에 할당된다. increase 변수에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프인 즉시실행함수의 렉시컬환경을 기억하는 클로저이다.</p>
<ul>
<li>num 변수는 외부에서 접근할 수 없다</li>
<li>increase 식별자에 할당된 클로저함수를 통해서만 참조 가능하다.</li>
</ul>
<h1 id="캡슐화와-정보-은닉"><a href="#캡슐화와-정보-은닉" class="headerlink" title="캡슐화와 정보 은닉"></a>캡슐화와 정보 은닉</h1><p>캡슐화는 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 동작인 메서드를 하나로 묶는 것을 말한다.</p>
<p>캡슐화는 객체의 특정 프로퍼티나 메소드를 감출 목적으로 사용하는데 이를 정보은닉이라고 한다. 이를 통해 외부에 부적절한 접근을 막아 객체의 상태가 변경되는것을 방지한다.</p>
<p>⇒ <strong>객체간의 상호 의존성 즉, 결합도를 낮추는 효과가 있다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Person</span> = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> _age = <span class="number">0</span>; <span class="comment">// private</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name; <span class="comment">// public</span></span><br><span class="line">    _age = age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메서드</span></span><br><span class="line">  <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>. I am <span class="subst">$&#123;_age&#125;</span>.`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 반환</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Person</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>, <span class="number">20</span>);</span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Lee. I am 20.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">name</span>); <span class="comment">// Lee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="property">_age</span>); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kim&quot;</span>, <span class="number">30</span>);</span><br><span class="line">you.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Kim. I am 30.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(you.<span class="property">name</span>); <span class="comment">// Kim</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(you.<span class="property">_age</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<ul>
<li>즉시실행함수가 반환하는 Person 생성자함수와 프로토타입 메서드는 즉시실행함수가 종료된 후 호출되고 각각 즉시실행함수의 자유변수 _age를 참조하고 있으므로 이들은 클로저이다.</li>
</ul>
<aside>
💡 생성자함수가 평가되어 함수객체를 생성할 때 프로토타입도 더불어 생성된다.

</aside>

<p>하지만 위 코드의 문제점은 Person 생성자 함수가 여러개의 인스턴스를 생성할 경우 _age 변수의 상태가 유지 되지 않는다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>, <span class="number">20</span>);</span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Lee. I am 20.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kim&quot;</span>, <span class="number">30</span>);</span><br><span class="line">you.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Kim. I am 30.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// _age 변수 값이 변경된다!</span></span><br><span class="line">me.<span class="title function_">sayHi</span>(); <span class="comment">// Hi! My name is Lee. I am 30.</span></span><br></pre></td></tr></table></figure>

<p>이는 Person.prototype.sayHi 메서드가 단 한번 생성되는 클로저이기 때문이다. 따라서 Person 생성자 함수가 생성한 모든 인스턴스가 상속을 통해 호출할 수 있는 Person.prototype.sayHi 메서드의 상위 스코프는 어떤 인스턴스를 호출하더라도 <strong>하나의 동일한 상위 스코프를 사용</strong>하여 _age 변수의 상태가 유지되지 않는다.</p>
<p>즉, 여러개의 인스턴스를 만들기에는 클래스가 더 적합하다. 다음 시간에는 클래스를 배워보자.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/23/Javascript/%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/22/Javascript/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3/"
                            aria-label=": 실행컨텍스트"
                        >
                            실행컨텍스트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-22T17:34:13+09:00">
	
		    2022/08/22
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="실행-컨텍스트"><a href="#실행-컨텍스트" class="headerlink" title="실행 컨텍스트"></a>실행 컨텍스트</h1><p>자바스크립트에서 실행 컨텍스트란 모든 코드의 동작 원리를 담고 있는 핵심 개념이다. 이후 나오는 클로저를 이해하는데도 필수내용이므로 제대로 이해하고 넘어가자.</p>
<h2 id="소스코드-타입-구분"><a href="#소스코드-타입-구분" class="headerlink" title="소스코드 타입 구분"></a>소스코드 타입 구분</h2><h3 id="1-전역-코드"><a href="#1-전역-코드" class="headerlink" title="1. 전역 코드"></a>1. 전역 코드</h3><p>전역 코드는 전역 변수를 관리하기 위한 최상위 스코프인 전역 스코프를 생성한다.</p>
<ul>
<li>var 키워드로 선언한 변수</li>
<li>함수 선언문</li>
</ul>
<p>위 두가지는 전역 객체의 프로퍼티와 메서드로 바인딩하고 참조하기 위해 전역 코드는 전역 객체와 연결되어야한다.</p>
<blockquote>
<p>함수 코드는 포함하지만 함수 내부의 코드는 포함하지 않는다.</p>
</blockquote>
<h3 id="2-함수-코드"><a href="#2-함수-코드" class="headerlink" title="2. 함수 코드"></a>2. 함수 코드</h3><p>함수 코드는 지역 스코프를 생성하고 지역 스코프를 전역 스코프로 연결 하여 스코프 체인의 일원으로 한다.</p>
<blockquote>
<p>함수 내부의 중첩 함수의 내부 코드는 포함하지 않는다.</p>
</blockquote>
<hr>
<h2 id="소스코드-평가와-실행"><a href="#소스코드-평가와-실행" class="headerlink" title="소스코드 평가와 실행"></a>소스코드 평가와 실행</h2><p>소스코드는 평가 과정과 실행과정으로 나뉘는데, 이 두 과정을 하나의 예제를 통해서 알아보자.</p>
<blockquote>
<p>직접 그림을 그리면서 단계에 따라 이해해보는 것이 더 기억에 오래 남는다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="1-전역-객체-생성"><a href="#1-전역-객체-생성" class="headerlink" title="1. 전역 객체 생성"></a>1. 전역 객체 생성</h3><p>전역 코드가 평가되기 이전 전역 객체가 생성된다. 전역 객체도 Object.prototype의 상속을 받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다.</p>
<h3 id="2-전역-코드-평가"><a href="#2-전역-코드-평가" class="headerlink" title="2. 전역 코드 평가"></a>2. 전역 코드 평가</h3><p>소스코드 로드되면 전역 코드가 평가된다.</p>
<h4 id="1-전역-실행-컨텍스트-생성"><a href="#1-전역-실행-컨텍스트-생성" class="headerlink" title="1. 전역 실행 컨텍스트 생성"></a>1. 전역 실행 컨텍스트 생성</h4><p>전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 PUSH 한다.</p>
<h4 id="2-전역-렉시컬-환경-생성"><a href="#2-전역-렉시컬-환경-생성" class="headerlink" title="2. 전역 렉시컬 환경 생성"></a>2. 전역 렉시컬 환경 생성</h4><p>전역 렉시컬 환경을 생성한 후 전역 실행 컨텍스트에 바인딩한다.<br>전역 렉시컬 환경은 전역 환경 레코드와 외부 렉시컬 환경에 대한 참조 총 2가지 컴포넌트로 구성된다.</p>
<h5 id="2-1-전역-환경-레코드-생성"><a href="#2-1-전역-환경-레코드-생성" class="headerlink" title="2.1. 전역 환경 레코드 생성"></a>2.1. 전역 환경 레코드 생성</h5><p>let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않으므로 var 키워드와 구분해줘야한다.</p>
<ul>
<li>객체 환경 레코드 : var키워드로 선언한 전역 변수, 함수 선언문으로 정의한 전역 함수, 빌트인 전역 프로퍼티와 전역 함수, 표준 빌트인 객체 관리</li>
<li>선언적 환경 레코드 : let, const 키워드로 선언한 전역 변수 관리</li>
</ul>
<h6 id="2-1-1-객체-환경-레코드-생성"><a href="#2-1-1-객체-환경-레코드-생성" class="headerlink" title="2.1.1. 객체 환경 레코드 생성"></a>2.1.1. 객체 환경 레코드 생성</h6><p>객체환경 레코드가 관리하는 것들은 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 된다.</p>
<blockquote>
<p>BindingObject는 전역 객체가 생성될 때 생성된 전역 객체이다.</p>
</blockquote>
<h6 id="2-1-2-선언적-환경-레코드-생성"><a href="#2-1-2-선언적-환경-레코드-생성" class="headerlink" title="2.1.2. 선언적 환경 레코드 생성"></a>2.1.2. 선언적 환경 레코드 생성</h6><p>let, const로 선언한 변수는 이곳에서 관리한다.</p>
<ul>
<li>let, const 키워드로 선언한 변수는 전역 객체의 프로퍼티가 되지 않는다.</li>
<li>선언 단계와 초기화 단계가 분리되어 진행되기 때문에 선언단계 이후 런타임때 실행 흐름이 변수 선언문에 도달하기 전까지 **일시적 사각지대(Temporal Dead Zone : TDZ)**에 빠진다.</li>
<li>식별자 y에 바인딩된 <uninitialized>는 초기화 단계가 진행되지 않아 <strong>변수에 접근할 수 없음을 나타내기 위해 사용한 표현일 뿐</strong> 실제 값이 바인딩 된 것은 아니다.</li>
</ul>
<blockquote>
<p>let, const 키워드로 선언한 변수도 호이스팅 현상 일어난다.</p>
</blockquote>
<h5 id="2-2-this-바인딩"><a href="#2-2-this-바인딩" class="headerlink" title="2.2. this 바인딩"></a>2.2. this 바인딩</h5><p>전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 즉, 전역 코드에서 this를 참조하면 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 바인딩 되어있는 전역 객체가 반환된다.</p>
<blockquote>
<p>this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다.</p>
</blockquote>
<h5 id="2-3-외부-렉시컬-환경에-대한-참조-결정"><a href="#2-3-외부-렉시컬-환경에-대한-참조-결정" class="headerlink" title="2.3. 외부 렉시컬 환경에 대한 참조 결정"></a>2.3. 외부 렉시컬 환경에 대한 참조 결정</h5><p>현재 전역 코드의 평가가 진행되고 있고 전역 코드를 포함하는 외부 소스 코드의 렉시컬 환경 즉, 상위 스코프를 가리킨다. 전역 스코프의 상위 스코프는 존재 하지 않으므로 null 값이 바인딩된다.</p>
<h4 id="3-전역-코드-실행"><a href="#3-전역-코드-실행" class="headerlink" title="3. 전역 코드 실행"></a>3. 전역 코드 실행</h4><p>전역 코드 평가과정이 끝나면 소스코드를 순차적으로 한줄씩 실행한다.</p>
<ul>
<li>선언한 전역 변수 x,y에 값이 할당된다.</li>
<li>foo 함수 호출된다.</li>
</ul>
<p>위 과정을 하기 위해서는 역시 렉시컬 환경의 환경 레코드에 등록된 식별자를 확인해야한다. <span style='color:red'>선언되지 않는 식별자는 참조할 수 없다.</span></p>
<p>식별자를 찾을 때 현재 실행중인 실행 컨텍스트의 렉시컬 환경에서 부터 찾다가 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 상위 스코프로 이동하여 식별자를 찾는다.</p>
<p>&#x3D;&gt; 이것이 바로 <span style='color:red'>스코프 체인의 동작 원리</span>이다.</p>
<h4 id="4-함수-코드-평가"><a href="#4-함수-코드-평가" class="headerlink" title="4. 함수 코드 평가"></a>4. 함수 코드 평가</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params">b</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> z = <span class="number">5</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + x + y + z);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(<span class="number">20</span>); <span class="comment">// ← 호출 직전</span></span><br></pre></td></tr></table></figure>

<p>foo 함수 호출하면 전역 코드 실행 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드의 평가가 시작된다.</p>
<h5 id="4-1-함수-실행-컨텍스트-생성"><a href="#4-1-함수-실행-컨텍스트-생성" class="headerlink" title="4.1. 함수 실행 컨텍스트 생성"></a>4.1. 함수 실행 컨텍스트 생성</h5><p>함수 실행 컨텍스트가 생성되고 함수 렉시컬 환경이 완성된 이후 실행 컨텍스트 스택에 푸시된다.</p>
<blockquote>
<p>함수 실행 컨텍스트는 함수 렉시컬 환경이 완성된 이후 함수 실행 컨텍스트가 실행 컨텍스트 스택에 푸시된다.</p>
</blockquote>
<h5 id="5-2-함수-렉시컬-환경-생성"><a href="#5-2-함수-렉시컬-환경-생성" class="headerlink" title="5.2. 함수 렉시컬 환경 생성"></a>5.2. 함수 렉시컬 환경 생성</h5><h6 id="5-2-1-함수-환경-레코드-생성"><a href="#5-2-1-함수-환경-레코드-생성" class="headerlink" title="5.2.1. 함수 환경 레코드 생성"></a>5.2.1. 함수 환경 레코드 생성</h6><p>함수 환경 레코드는 다음을 등록하고 관리한다.</p>
<ul>
<li>arguments 객체</li>
<li>매개변수</li>
<li>함수 내부에서 선언한 지역변수와 중첩함수</li>
</ul>
<h6 id="5-2-2-this-바인딩"><a href="#5-2-2-this-바인딩" class="headerlink" title="5.2.2. this 바인딩"></a>5.2.2. this 바인딩</h6><p>함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다.</p>
<ul>
<li>this는 함수를 호출할 때 동적으로 바인딩된다.</li>
<li>foo 함수는 일반함수로 호출되어 전역 객체에 바인딩된다.</li>
</ul>
<h6 id="5-2-3-외부-렉시컬-환경에-대한-참조-결정"><a href="#5-2-3-외부-렉시컬-환경에-대한-참조-결정" class="headerlink" title="5.2.3. 외부 렉시컬 환경에 대한 참조 결정"></a>5.2.3. 외부 렉시컬 환경에 대한 참조 결정</h6><p>foo 함수정의가 평가된 시점의 실행중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다. 전역 코드에 정의된 함수이므로 전역 렉시컬 환경의 참조가 할당된다.</p>
<p>자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때, 현재 실행중인 실행 컨텍스트의 렉시컬 환경 즉, <span style='color:red'>함수의 상위 스코프를 함수 객체의 내부 슬롯 [[Environment]] 에 저장</span>한다.</p>
<h4 id="6-foo-함수-코드-실행"><a href="#6-foo-함수-코드-실행" class="headerlink" title="6. foo 함수 코드 실행"></a>6. foo 함수 코드 실행</h4><p>매개변수 a에 인수가 할당되고 변수 식별자에 값이 할당되고 bar 함수 호출된다.</p>
<h4 id="7-bar-함수-코드-평가"><a href="#7-bar-함수-코드-평가" class="headerlink" title="7. bar 함수 코드 평가"></a>7. bar 함수 코드 평가</h4><p>bar 함수 호출되어 코드 내부로 실행흐름이 이동하여 bar 함수 코드가 평가된다. foo함수와 동일하게 진행된다.</p>
<h4 id="8-bar-함수-코드-실행"><a href="#8-bar-함수-코드-실행" class="headerlink" title="8. bar 함수 코드 실행"></a>8. bar 함수 코드 실행</h4><ul>
<li><code>console.log(a+b+x+y+z)</code> 가 실행된다.</li>
</ul>
<ol>
<li>console.log 식별자 검색</li>
</ol>
<p>먼저 console 식별자를 스코프 체인에서 검색한다. 현재 실행중인 실행 컨텍스트인 bar 함수의 렉시컬 환경에서부터 식별자를 검색하기 시작한다.</p>
<p>→ 이곳에는 식별자가 없어 외부 렉시컬 환경에 대한 참조가 가리키는 foo 함수 렉시컬 환경으로 이동하여 console 식별자를 검색한다.</p>
<p>→ 이곳에도 식별자가 없으므로 전역 렉시컬 환경으로 이동한다. 전역 렉시컬 환경은 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.</p>
<p>→ console 식별자는 객체 환경 레코드의 BindingObject를 통해 전역 객체에서 찾을 수 있다.</p>
<ol start="2">
<li>log 메서드 검색</li>
</ol>
<p>전역 객체에 console 식별자에 바인딩된 console 객체에서 log 메서드를 검색한다. 이 때 console 객체의 프로토타입 체인을 통해 메서드를 검색한다.</p>
<ol start="3">
<li>표현식 a+b+x+y+z 의 평가</li>
</ol>
<p>이제 console.log 메서드에 전달할 인수, 즉 표현식에 대한 평가를 위해 a,b,x,y,z 식별자를 검색한다. 식별자는 현재 실행중인 실행 컨텍스트의 렉시컬 환경에서부터 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속에서 검색한다.</p>
<ol start="4">
<li>console.log 메서드 호출</li>
</ol>
<p>표현식 a+b+x+y+z가 평가되어 생성한 값 42를 console.log 메서드에 전달되어 호출한다.</p>
<h4 id="9-bar-함수-코드-실행-종료"><a href="#9-bar-함수-코드-실행-종료" class="headerlink" title="9. bar 함수 코드 실행 종료"></a>9. bar 함수 코드 실행 종료</h4><p>더 이상 실행할 코드가 없으므로 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 pop 되어 제거된다.</p>
<blockquote>
<p>단, 실행 컨텍스트가 제거되더라도 bar 함수의 렉시컬 환경까지 즉시 소멸하는 것은 아니다. (클로저)</p>
</blockquote>
<h4 id="10-foo-함수-코드-실행-종료"><a href="#10-foo-함수-코드-실행-종료" class="headerlink" title="10. foo 함수 코드 실행 종료"></a>10. foo 함수 코드 실행 종료</h4><p>코드 실행 종료되고 foo 함수 실행 컨텍스트 pop 되어 제거된다.</p>
<h4 id="11-전역-코드-실행-종료"><a href="#11-전역-코드-실행-종료" class="headerlink" title="11. 전역 코드 실행 종료"></a>11. 전역 코드 실행 종료</h4><p>전역 코드가 종료되므로서 전역 실행 컨텍스트가 pop 되어 제거된다.</p>
<hr>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>실행 컨텍스트는 <strong>식별자, 스코프, 코드 실행 순서를 관리한다.</strong></p>
<ol>
<li>선언에 의해 생성된 모든 식별자는 스코프를 구분하여 등록하고 상태변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야함</li>
<li>스코프는 중첩관계에 의해 스코프 체인을 형성</li>
<li>현재 실행 중인 코드의 실행 순서를 변경(ex. 함수호출)할 수 있어야하며 되돌아 올 수 있어야 한다.</li>
</ol>
<aside>
💡 실행 컨텍스트는 **식별자를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 메커니즘**으로, **모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다.**

</aside>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/22/Javascript/%E1%84%89%E1%85%B5%E1%86%AF%E1%84%92%E1%85%A2%E1%86%BC%E1%84%8F%E1%85%A5%E1%86%AB%E1%84%90%E1%85%A6%E1%86%A8%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/19/Javascript/tagged%20templates/"
                            aria-label=": tagged templates"
                        >
                            tagged templates
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-19T19:33:57+09:00">
	
		    2022/08/19
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="📌-template-literals"><a href="#📌-template-literals" class="headerlink" title="📌 template literals"></a>📌 template literals</h1><p>템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다.</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul>
<li>&#96; 백틱이라는 기호를 사용한다.</li>
<li>${}를 사용하여 표현식을 삽입할 수 있다.</li>
<li>개행을 포함한다.</li>
</ul>
<h2 id="tagged-templates"><a href="#tagged-templates" class="headerlink" title="tagged templates"></a>tagged templates</h2><p>템플릿 리터럴의 발전된 형태로 태그드 템플릿이 있다.</p>
<p>마치 함수처럼 사용할 수 있다.</p>
<h2 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 1"></a>예제 1</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> virtualNode = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;figure&#x27;</span>,</span><br><span class="line"><span class="attr">className</span>: <span class="string">&#x27;tagged-template-literals&#x27;</span>,</span><br><span class="line"><span class="attr">style</span>: &#123; <span class="attr">cssText</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">styled</span> = (<span class="params">strings, Node, ...value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> el = strings.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">3</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc,cur</span>) =&gt;</span> acc+cur.<span class="title function_">trim</span>(),<span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    el.<span class="title function_">forEach</span>(<span class="function">(<span class="params">elem,i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Node</span>.<span class="property">style</span>.<span class="property">cssText</span> += elem + value[i] + <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Node</span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> values = &#123;</span><br><span class="line">    <span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;#d08471&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> received = styled<span class="string">`<span class="subst">$&#123;virtualNode&#125;</span>margin: <span class="subst">$&#123;values.margin&#125;</span>;color: <span class="subst">$&#123;values.color&#125;</span>;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(received);</span><br></pre></td></tr></table></figure>

<ul>
<li>마치 함수처럼 인수를 받아서 템플릿 리터럴에 넣어 반환값을 원하는 대로 지정해줄 수 있다.</li>
<li>리액트의 StyledComponent가 태그드 템플릿을 활용하여 탄생하게 되었다.</li>
</ul>
<h1 id="🏓-소감"><a href="#🏓-소감" class="headerlink" title="🏓 소감"></a>🏓 소감</h1><p>문자타입과 다른 타입을 파라미터로 사용하는 함수를 만들 때 원하는 반환값을 직관적으로 사용할 수 있어 용이해보인다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/19/Javascript/tagged%20templates/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/19/Javascript/this/"
                            aria-label=": this"
                        >
                            this
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-19T19:33:57+09:00">
	
		    2022/08/19
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="this-키워드"><a href="#this-키워드" class="headerlink" title="this 키워드"></a>this 키워드</h1><p>메서드로 프로퍼티를 참조하고 변경하기 위해서는 우선 자신이 속한 객체를 가리키는 식별자를 참조해야만 가능한 일이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  <span class="comment">// 프로퍼티: 객체 고유의 상태 데이터</span></span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="comment">// 메서드: 상태 데이터를 참조하고 조작하는 동작</span></span><br><span class="line">  <span class="title function_">getDiameter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면</span></span><br><span class="line">    <span class="comment">// 자신이 속한 객체인 circle을 참조할 수 있어야 한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * circle.<span class="property">radius</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle.<span class="title function_">getDiameter</span>()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>객체 리터럴은 circle 변수에 할당되기 직전에 평가된다?<br>&#x3D; 할당 연산자에 의해서 피연산자를 할당해주기 위해서는 우측의 객체 리터럴이 평가된 값으로 존재해야 할당을 해줄 수 있기 때문이다.</li>
</ul>
<p>하지만 위처럼 재귀적으로 자신이 속한 객체를 참조하는 것은 바람직하지 않다.</p>
<p>그 예시를 생성자 함수를 통해 설명해보자</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="comment">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span></span><br><span class="line">  ????.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getDiameter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * ????.<span class="property">radius</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>생성자 함수 내부에서 프로퍼티나 메서드를 추가하기 위해서는 자신이 생성할 인스턴스를 참조할 수 있어야 하는데, 인스턴스를 생성하려면 생성자 함수가 존재해야한다.</li>
</ul>
<p>따라서 자신이 속한 객체, 자신이 생성할 인스턴스를 가리킬 <strong>특별한 식별자가 필요하다.</strong></p>
<p><strong>this란, 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체나 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.</strong></p>
<ul>
<li>this는 코드 어디서든 참조할 수 있다. (전역에서도 가능)</li>
</ul>
<aside>
💡 단, this가 가리키는 값(this 바인딩)은 함수 호출 방식에 의해 동적으로 결정된다.

</aside>

<p>this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이므로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 선언된 일반 함수 내부의 this는 undefined가 바인딩된다. (일반함수에선 필요 없다)</p>
<h1 id="함수-호출방식과-this-바인딩"><a href="#함수-호출방식과-this-바인딩" class="headerlink" title="함수 호출방식과 this 바인딩"></a>함수 호출방식과 this 바인딩</h1><p><strong>this에 바인딩될 값은 함수 호출 방식에 의해 동적으로 결정된다.</strong></p>
<h2 id="1-일반-함수-호출"><a href="#1-일반-함수-호출" class="headerlink" title="1. 일반 함수 호출"></a>1. 일반 함수 호출</h2><p>전역 객체에 바인딩된다.</p>
<p>중첩 함수 또한 일반 함수로 호출 시 함수 내부의 this는 전역 객체에 바인딩 된다.</p>
<p>매서드 내에서 정의된 중첩함수도 일반 함수로 호출되면 역시 전역 객체에 바인딩 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.</span></span><br><span class="line"><span class="comment">// const value = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메서드 내에서 정의한 중첩 함수</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    <span class="title function_">bar</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>콜백함수가 일반함수로 호출된다면 콜백함수 내부의 this에도 전역객체가 바인딩된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="comment">// 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>하지만 메서드 내의 중첩함수와 콜백함수는 외부함수를 돕는 헬퍼 함수의 역할을 하는데 <strong>외부함수인 메서드와 중첩함수 또는 콜백함수의 this가 일치하지 않는다</strong>는 것은 중첩함수 또는 콜백함수가 헬퍼 함수로 동작하는 것을 어렵게 만든다.</p>
<h3 id="화살표함수-내부에서-this"><a href="#화살표함수-내부에서-this" class="headerlink" title="화살표함수 내부에서 this"></a>화살표함수 내부에서 this</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>), <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h2 id="2-메서드-호출"><a href="#2-메서드-호출" class="headerlink" title="2. 메서드 호출"></a>2. 메서드 호출</h2><p>메서드 내부의 this는 메서드를 소유한 객체가 아닌 <span style="color:red">메서드를 호출한 객체에 바인딩</span>된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// Lee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">getName</span>()); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<ul>
<li>person 객체의 getName 프로퍼티가 가리키는 함수 객체는 person 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체이다? 내 생각에는 this가 가리키는 것이 메서드를 소유한 객체라고 생각해도 맞지 않나?<br>person 객체에 getName 프로퍼티 키가 가리키는 함수 객체를 소유하고 있는 것이 아니라 참조값을 가지므로 독립적으로 존재하는 객체를 가리키고 있는 것이 맞다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anotherPerson = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// getName 메서드를 anotherPerson 객체의 메서드로 할당</span></span><br><span class="line">anotherPerson.<span class="property">getName</span> = person.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getName 메서드를 호출한 객체는 anotherPerson이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="title function_">getName</span>()); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<ul>
<li>새로운 객체의 프로퍼티에 person.getName 프로퍼티를 할당해줄 수 있다.</li>
</ul>
<p>this는 getName 메서드를 호출한 객체에 바인딩된다.</p>
<p>프로토타입 메서드 내부에서도 마찬가지로 바인딩된다.</p>
<h2 id="3-생성자-함수-호출"><a href="#3-생성자-함수-호출" class="headerlink" title="3. 생성자 함수 호출"></a>3. 생성자 함수 호출</h2><p>생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getDiameter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="title function_">getDiameter</span>()); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle2.<span class="title function_">getDiameter</span>()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Function-prototype-apply-x2F-call-x2F-bind-메서드에-의한-간접-호출"><a href="#4-Function-prototype-apply-x2F-call-x2F-bind-메서드에-의한-간접-호출" class="headerlink" title="4. Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접 호출"></a>4. Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접 호출</h2><p>apply, call, bind 메서드는 Function.prototype의 메서드이다. 이들 메서드는 <strong>모든 함수가 상속받아 사용 가능하다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getThisBinding</span>()); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">apply</span>(thisArg)); <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">call</span>(thisArg)); <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>call,apply 메서드는 함수를 호출하면서 첫번째 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.</p>
<ul>
<li>위 예제에서는 getThisBinding() 함수에 인수를 전달해주지 않는다.</li>
<li><strong>call, apply의 반환값은 호출한 함수의 반환값이다.</strong></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span></span><br><span class="line"><span class="comment">// apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">apply</span>(thisArg, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="comment">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">call</span>(thisArg, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>call,apply 메서드로 함수를 호출하면서 호출한 함수에 인수를 전달해줄 수 있다.</p>
<h3 id="유사배열-객체에-배열-메서드-사용"><a href="#유사배열-객체에-배열-메서드-사용" class="headerlink" title="유사배열 객체에 배열 메서드 사용"></a>유사배열 객체에 배열 메서드 사용</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertArgsToArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체를 배열로 변환</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice를 인수없이 호출하면 배열의 복사본을 생성한다.</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// const arr = Array.prototype.slice.apply(arguments);</span></span><br><span class="line">  <span class="comment">// const arr = Array.from(arguments)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convertArgsToArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arguments 객체는 배열이 아니므로 배열 메서드를 사용할 수 없지만 apply, call 메서드를 사용하면 가능하다.</li>
</ul>
<blockquote>
<p>새로 나온 Array.from() 정적 메서드를 사용할 수 있다. 하지만 arguments 객체를 잘 안쓴다.</p>
</blockquote>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된</span></span><br><span class="line"><span class="comment">// getThisBinding 함수를 새롭게 생성해 반환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">bind</span>(thisArg)); <span class="comment">// getThisBinding</span></span><br><span class="line"><span class="comment">// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">bind</span>(thisArg)()); <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bind 메서드는 함수를 호출하지 않고 인수로 전달받은 객체로 this 바인딩이 교체된 함수를 새롭게 생성하여 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>); <span class="comment">// ② Hi! my name is .</span></span><br><span class="line">  <span class="comment">// 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.</span></span><br><span class="line">  <span class="comment">// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 &#x27;&#x27;이다.</span></span><br><span class="line">  <span class="comment">// Node.js 환경에서 this.name은 undefined다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>person.foo의 콜백함수가 호출되기 전 1의 시점에서 this는 foo 메서드를 호출한 객체(person)를 가리킨다.</li>
<li>그러나 person.foo의 콜백함수가 일반 함수로서 호출된 2의 시점에서 this는 전역객체 windows를 가리킨다.</li>
<li>person.foo의 콜백함수는 헬퍼함수로 person.foo를 돕는 역할을 하기 때문에 서로의 this가 같아야한다.</li>
</ul>
<p>이 때, bind 메서드를 사용하여 this를 일치시킨다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(callback.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>); <span class="comment">// Hi! my name is Lee.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>callback 함수에 this가 바인딩된 새로운 함수를 반환</li>
</ul>
<p><strong>코드해설</strong></p>
<p>즉, foo안의 this는 person 객체를가리키는데, 콜백함수 호출하면 this가 window를 가리킨다. 그러므로 bind함수를 사용하여 foo 메서드가 가리키는 this를 callback 함수에 바인딩해줘서 콜백함수가 가리키는 this와 일치 시켜준다.</p>
<blockquote>
<p>bind, call, apply, that으로 this 바인딩을 일치 시켜주는 것 보다 화살표 함수를 사용하는 것이 간편하다. 하지만 여러 가지 방식에 대해서도 알아두자.</p>
</blockquote>
<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this 바인딩</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메서드 호출</td>
<td>메서드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수 호출</td>
<td>생성자 함수가 (미래에) 생성할 인스턴스</td>
</tr>
<tr>
<td>Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접호출</td>
<td>Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 첫번째로 전달한 객체</td>
</tr>
</tbody></table>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/19/Javascript/this/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/18/Javascript/%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8/"
                            aria-label=": 상속"
                        >
                            상속
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-18T19:35:34+09:00">
	
		    2022/08/18
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바스크립트에서 상속을 구현하기 위해 프로토타입을 기반으로 구현한다고 이전시간에 배워보았다.</p>
<p>그럼 상속을 구현하는 방법이 과연 이 방법뿐일까? 한번 알아보자.</p>
<h1 id="직접상속"><a href="#직접상속" class="headerlink" title="직접상속"></a>직접상속</h1><h2 id="Object-create에-의한-직접-상속-정적메서드"><a href="#Object-create에-의한-직접-상속-정적메서드" class="headerlink" title="Object.create에 의한 직접 상속 (정적메서드)"></a>Object.create에 의한 직접 상속 (정적메서드)</h2><p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(생성할 객체의 프로토타입, 생성할 객체의 프로퍼티키와 프로퍼티 디스크립터 객체로 이뤄진 객체)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(prototype[, propertiesObject])</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.</span></span><br><span class="line"><span class="comment">// obj → null</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.prototype을 상속받지 못한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()); <span class="comment">// TypeError: obj.toString is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj → Object.prototype → null</span></span><br><span class="line"><span class="comment">// obj = &#123; x: 1 &#125;;와 동일하다.</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 위 코드는 다음과 동일하다.</span></span><br><span class="line"><span class="comment">// obj = Object.create(Object.prototype);</span></span><br><span class="line"><span class="comment">// obj.x = 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빈객체만 생성하는 것이 아니다.</span></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">20</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;x: 10, y: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// 객체리터럴로 생성된 객체를 직접 상속받는다.</span></span><br><span class="line"><span class="comment">// obj → myProto → Object.prototype → null</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(myProto);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === myProto); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj → Person.prototype → Object.prototype → null</span></span><br><span class="line"><span class="comment">// obj = new Person(&#x27;Lee&#x27;)와 동일하다.</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// Lee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Object.create 메서드의 첫번째 인수로 전달한 객체를 프로토타입으로 하는 프로토타입 체인에 속하는 객체를 생성한다. 즉, 객체를 생성하면서 직접적인 상속을 구현하는 것이다.</p>
<ul>
<li>new 연산자 없이 객체 생성 가능</li>
<li>프로토타입을 지정하면서 객체 생성 가능</li>
<li>객체 리터럴로 생성된 객체도 상속받을 수 있다.</li>
</ul>
<p>Object.prototype의 빌트인 메서드를 직접 호출하는 것은 위험하다. 그 이유는 Object.create 메서드를 사용하여 <span style="color:red">프로토타입 체인 종점에 위치하는 객체</span>를 생성할 수도 있기 때문이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">// TypeError: obj.hasOwnProperty is not a function</span></span><br></pre></td></tr></table></figure>

<p>그러므로 Object.prototype의 빌트인 메서드는 call,apply 등을 통해 간접적으로 호출하는 것을 권장한다.</p>
<p>하지만 위 방법은 너무 길다…</p>
<p><span style="font-size:1.2rem">그래서 새로나온 문법을 사용하자</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(obj, property);</span><br></pre></td></tr></table></figure>

<p>위 방법을 사용하여 같은 기능을 구현할 수 있다.</p>
<h1 id="정적-프로퍼티-x2F-메소드"><a href="#정적-프로퍼티-x2F-메소드" class="headerlink" title="정적 프로퍼티&#x2F;메소드"></a>정적 프로퍼티&#x2F;메소드</h1><p>생성자 함수로 <span style="color:red">인스턴스를 생성하지 않아도</span> 참조,호출할 수 있는 프로퍼티, 메소드를 말한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 프로퍼티</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">staticProp</span> = <span class="string">&quot;static prop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">staticMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// staticMethod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</span></span><br><span class="line"><span class="comment">// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.</span></span><br><span class="line">me.<span class="title function_">staticMethod</span>(); <span class="comment">// TypeError: me.staticMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수로 생성한 인스턴스로 정적 프로퍼티와 메소드를 참조, 호출할 수 없다.</p>
<p>생성자 함수가 생성한 인스턴스는 프로퍼티, 메소드를 참조할 때 <span style="color:red">프로토타입 체인 내에서만 할 수 있다.</span></p>
<p>정적 프로퍼티,메소드는 인스턴스의 프로토타입 체인 내에 없기 때문에 참조, 호출할 수 없다.</p>
<aside>
💡 MDN에 보면 정적메서드와 프로토타입 메서드를 구분하여 소개한다. 정적 메서드는 Object.isExtensible(), Object.keys() 처럼 중간에 prototype이 들어가지 않지만 프로토타입 메서드는 Object.prototype.hasOwnProperty() 처럼 중간에 prototype이 들어간다.
</aside>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/18/Javascript/%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A9%E1%86%A8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/17/Javascript/%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8/"
                            aria-label=": 객체지향프로그래밍과 프로토타입"
                        >
                            객체지향프로그래밍과 프로토타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-17T18:12:35+09:00">
	
		    2022/08/17
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바스크립트는 public,private,protected 등의 키워드가 없어서 객체지향 프로그래밍이 아니라는 오해를 받지만 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 <span style="color:red">프로토타입 기반의 객체지향 프로그래밍 언어</span>이다.</p>
<h1 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h1><p>객체지향 프로그래밍이란, 특성을 나타내는 속성들의 집합을 통해 실체를 나타내어 구별하거나 인식하는 개념을 프로그래밍에 접목시킨 프로그래밍 패러다임이다. 여기서 프로그램에 필요한 속성만을 간추려 추상화 한것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">고양이 = &#123;</span><br><span class="line">  동물</span><br><span class="line">  귀여움</span><br><span class="line">  털이있음</span><br><span class="line">  다리가 <span class="number">4</span>개임...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">	<span class="attr">address</span>:<span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="프로토타입과-상속"><a href="#프로토타입과-상속" class="headerlink" title="프로토타입과 상속"></a>프로토타입과 상속</h1><p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 불필요한 메서드 중복 소유</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>); <span class="comment">// 얘도 getArea 가지고</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>); <span class="comment">// 쟤도 getArea 가지네?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>위 예시는 Circle 생성자 함수가 인스턴스를 생성할 때마다 동일한 동작을 하는 getArea 메서드를 중복 생성하는데, 이 경우 모든 인스턴스가 메서드를 중복 소유하여 메모리 낭비를 야기시킬 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 상속을 기반으로 불필요한 중복 제거</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유하여 사용할 수 있도록 프로토타입에 추가</span></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><p>프로토타입 객체(줄여서 프로토타입)은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체의 공유 프로퍼티(메서드 포함)를 제공한다.</p>
<ul>
<li>객체간 상속을 구현하기 위해 사용</li>
<li>프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자유롭게 사용</li>
</ul>
<p>앞으로 나올 개념은 그림이 없으면 이해하기 어렵다. 이 블로그는 나의 생각을 정리해 둔 것이므로 이해를 돕기 위해서 모던 자바스크립트 Deep Dive 책을 참고하도록하자. 혹은 Poiema Web 사이트를 참고하자.</p>
<blockquote>
<p>객체 생성 방식에 따라 객체가 생성될 때, 프로토타입이 결정되고 [[Prototype]] 내부 슬롯의 값으로 저장된다.</p>
</blockquote>
<h3 id="함수객체의-prototype-프로퍼티"><a href="#함수객체의-prototype-프로퍼티" class="headerlink" title="함수객체의 prototype 프로퍼티"></a>함수객체의 prototype 프로퍼티</h3><p>함수 객체만이 갖는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
<p>함수 정의 방식에 따라 일반함수 정의할 경우 constructor이고 ES6에서 정한 메서드 축약표현, 화살표 함수로 함수 정의할 경우 non-constructor이다.</p>
<p>non-constructor인 화살표 함수, 메서드 축약표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않는다. ⇒ <span style="color:red">프로토타입도 생성하지 않는다.</span></p>
<blockquote>
<p>프로토타입 객체(프로토타입), 생성자 함수의 prototype 프로퍼티, 프로토타입의 constructor 프로퍼티, 생성자 함수가 생성한 객체(인스턴스)의 <strong>proto</strong> 등 헷갈리는 용어들이 많이 나오니 혼동하지 않도록 한다.</p>
</blockquote>
<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3><p>모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</p>
<p>프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하며 <span style="color:red">생성자 함수가 생성되는 시점과 더불어 프로토타입도 생성</span>된다.</p>
<hr>
<h2 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h2><p><span style="color:red">생성자 함수가 생성되는 시점과 더불어 프로토타입도 생성</span>된다.</p>
<p>사용자 정의 생성자 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 함수 표현식이라면 에러(변수호이스팅)</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>함수 선언문은 함수 호이스팅이 일어나 런타임 이전에 자바스크립트 엔진에 의해 실행된다.</p>
</li>
<li><p>이 때 함수 객체가 생성되고 더불어 생성된 프로토타입은 Person 생성자 함수의 prototype의 프로퍼티에 바인딩된다.</p>
</li>
</ol>
<p>이 때 생성된 프로토타입은 오직 constructor 프로퍼티만 갖는 객체이다.</p>
<blockquote>
<p>생성된 프로토타입의 프로토타입은 항상 Object.prototype이다.</p>
</blockquote>
<p>반면, 빌트인 생성자 함수의 경우 전역 객체가 생성되는 시점에 생성된다.</p>
<p>즉, 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화 되어 존재한다. 이 후 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다. 그 결과 생성된 객체는 프로토타입의 상속을 받는다.</p>
<hr>
<h2 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h2><p>객체는 다양한 방식으로 생성되어 세부적인 객체 생성 방식의 차이는 있지만 모두 추상연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.</p>
<p>추상연산 OrdinaryObjectCreate는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.</p>
<p>즉, 프로토타입은 추상연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<ol>
<li>객체 리터럴로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Object 생성자 함수로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>사용자 정의 생성자 함수로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">생성자함수.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 이 프로토타입은 constructor 프로퍼티만 가지고 있다.</p>
<hr>
<h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kim&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Person 생성자 함수에 의해 생성된 me 인스턴스는 Object.prototype의 메서드인 hasOwnProperty 메서드를 호출할 수 있다. 이것은 Person.prototype뿐만 아니라 Object.prototype도 상속 받았다는 것을 알 수 있다.</p>
<p>단, <span style="color:red">me 객체의 프로토타입은 Person.prototype</span>이다.</p>
<p>그리고 Person.prototype의 프로토타입은 Object.prototype이다.</p>
<blockquote>
<p>프로토타입 최상위에 있는 객체는 언제나 Object.prototype(프로토타입 체인의 종점)이다. 그러므로 Object.prototype의 [[Prototype]] 내부 슬롯은 null 이다.</p>
</blockquote>
<h3 id="식별자와-프로퍼티-차이"><a href="#식별자와-프로퍼티-차이" class="headerlink" title="식별자와 프로퍼티 차이"></a>식별자와 프로퍼티 차이</h3><p>식별자는 함수의 중첩관계로 이루어진 스코프의 계층적 구조로 이뤄진 스코프 체인에서 검색하여 찾는다.</p>
<p>반면에 객체의 프로퍼티는 해당 객체의 프로퍼티가 없다면 프로토타입 체인을 따라 [[Prototype]] 내부 슬롯에 바인딩된 프로토타입으로 이동하면서 프로퍼티를 검색한다.</p>
<p>스코프 체인과 프로토타입 체인은 별도로 동작하지 않고 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다.</p>
<h1 id="소감"><a href="#소감" class="headerlink" title="소감"></a>소감</h1><p>프로토타입에 대해 설명하기가 무척 어렵고 난해했는데 그림을 보며 공부하니 이해가 수월하였다. TIL을 정리하면서 저작권때문에 그림을 첨부할 순 없었지만 머릿속으로 다시 그려보면서 정리하니 기억에 오래 남을 것 같다.</p>
<p>이제 러버덕을 하면서 말로 설명해보는 시간을 가져야겠다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/17/Javascript/%E1%84%80%E1%85%A2%E1%86%A8%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%B5%E1%84%92%E1%85%A3%E1%86%BC%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%E1%84%80%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%90%E1%85%A9%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/16/Javascript/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2%E1%84%90%E1%85%B3/"
                            aria-label=": 프로퍼티와 프로퍼티 어트리뷰트"
                        >
                            프로퍼티와 프로퍼티 어트리뷰트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-16T19:23:07+09:00">
	
		    2022/08/16
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><p>오늘은 프로퍼티 어트리뷰트에 대해서 알아보자. 한국말로 번역하면 속성 속성이다. 하지만 자바스크립트에서 속성은 두가지로 구분하여 사용하여야 한다. 이번 시간에는 속성 중 하나인 프로퍼티에 대해 알아보자</p>
<h1 id="내부슬롯-internal-slot"><a href="#내부슬롯-internal-slot" class="headerlink" title="내부슬롯 internal slot"></a>내부슬롯 internal slot</h1><p>내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 프로퍼티와 메서드이다.</p>
<p>내부슬롯은 개발자가 직접 접근할 수는 없다.</p>
<p>하지만, [[Prototype]] 내부슬롯은 <strong>proto</strong>를 통해 간접적으로 접근할 수 있다.</p>
<h1 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1><p>자바스크립트 엔진은 프로퍼티 생성 시 <span style="color:red;">프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트</span>를 기본값으로 자동 정의한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&quot;kim&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a).<span class="property">age</span>.<span class="property">value</span> = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;name: &#x27;kim&#x27;, age: 28&#125;</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 어트리뷰트란 <span style="color:red">내부슬롯</span>이다. 따라서 직접 접근할 순 없지만, Object.getOwnPropertyDescriptor 메서드로 간접적으로 접근할 수 있다.</p>
<p>다만 간접적으로 접근만 가능한 것이므로 위 메서드로 값을 변경하거나 할 수는 없다.</p>
<p>⇒ 프로퍼티 생성될 때 [[value]]는 프로퍼티 값으로 초기화 되고 나머지는 true로 초기화된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name : <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// &#123;value: &#x27;Lee&#x27;, writable:true,... configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>프로퍼티 디스크립터 객체를 반환한다. 존재하지 않거나 상속받은 프로퍼티라면 undefined 반환</li>
</ul>
<h2 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h2><h3 id="1-데이터-프로퍼티"><a href="#1-데이터-프로퍼티" class="headerlink" title="1. 데이터 프로퍼티"></a>1. 데이터 프로퍼티</h3><p>키와 값으로 구성된 일반적인 프로퍼티</p>
<ul>
<li>프로퍼티의 값 [[value]]</li>
<li>값의 갱신 가능여부 [[writable]] : false이면 프로퍼티의 [[value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티</li>
<li>열거 가능여부 [[enumerable]] : for…in 혹은 Object.keys 메서드로 열거 가능 여부</li>
<li>재정의 가능여부 [[configurable]] : false이면 해당 프로퍼티 삭제, 프로퍼티 어트리뷰트 값의 변경 금지</li>
</ul>
<h3 id="2-접근자-프로퍼티"><a href="#2-접근자-프로퍼티" class="headerlink" title="2. 접근자 프로퍼티"></a>2. 접근자 프로퍼티</h3><p>자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티</p>
<ul>
<li>[[get]] : 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[get]]의 값 즉, getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>[[set]] : 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[set]]의 값 즉, setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>[[enumerate]]</li>
<li>[[configurable]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Donald&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Duck&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + person.<span class="property">lastName</span>); <span class="comment">// Donald Duck</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName값을 저장하면 setter 함수가 호출</span></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&quot;Daisy Duck&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &quot;Daisy&quot;, lastName: &quot;Duck&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">fullName</span>); <span class="comment">// Daisy Duck</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// firstName은 데이터 프로퍼티</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor);</span><br><span class="line"><span class="comment">// &#123;value:&quot;Daisy&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티</span></span><br><span class="line">descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&quot;fullName&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">// &#123;get: f, set: f, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="접근자-프로퍼티와-데이터-프로퍼티-구분-방법"><a href="#접근자-프로퍼티와-데이터-프로퍼티-구분-방법" class="headerlink" title="접근자 프로퍼티와 데이터 프로퍼티 구분 방법"></a>접근자 프로퍼티와 데이터 프로퍼티 구분 방법</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 객체의 __proto__는 접근자 프로퍼티</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;__proto__&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;get: f, set: f, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체의 prototype은 데이터 프로퍼티</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="string">&quot;prototype&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#123;...&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>

<p>위 예시는 접근자 프로퍼티의 경우 다음과 같은 프로퍼티 어트리뷰트가 나오고 데이터 프로퍼티의 경우 출력되는 프로퍼티 어트리뷰트가 다른 것을 확인할 수 있다.</p>
<h1 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h1><p>프로퍼티를 정의한다. 라는 것은 새로운 프로퍼티 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.</p>
<h2 id="데이터-프로퍼티-정의"><a href="#데이터-프로퍼티-정의" class="headerlink" title="데이터 프로퍼티 정의"></a>데이터 프로퍼티 정의</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;firstName&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;yiju&quot;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;lastName&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.defineProperty 메서드로 프로퍼티 어트리뷰트 정의할 수 있다. 인수로는 객체의 참조, 데이터 프로퍼티의 키(문자열), 프로퍼티 디스크립터 객체를 전달한다.</li>
<li>디스크립터 객체 누락시키면 false가 기본값</li>
</ul>
<h3 id="궁금증"><a href="#궁금증" class="headerlink" title="궁금증"></a>궁금증</h3><p>왜 프로퍼티 동적으로 생성해줄 때, 프로퍼티 어트리뷰트 생략하는데 프로퍼티 어트리뷰트값이 true인데, define 메서드를 사용할 때 생략하면 기본값 false?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">value</span>:<span class="number">19</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">왜 다른가?</span><br></pre></td></tr></table></figure>

<p>동적으로 생성시에 편의를 위해서 true로 설정된다. 그렇지 않은 경우 Object.defineProperty() 메서드를 사용할 때, 생략하는 어트리뷰트는 false로 설정된다.</p>
<h3 id="writable-false"><a href="#writable-false" class="headerlink" title="writable : false"></a>writable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[writable]] 값이 false 인 경우 해당 프로퍼티의 [[value]]의 값 변경할 수 없다.</span></span><br><span class="line"><span class="comment">// 에러 발생하지 않고 무시</span></span><br><span class="line">person.<span class="property">lastName</span> = <span class="string">&quot;soondae&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="enumerable-false"><a href="#enumerable-false" class="headerlink" title="enumerable : false"></a>enumerable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[enumerable]] 값이 false 인 경우 해당 프로퍼티는 for...in 문이나 Object.keys 등으로 열거할 수 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person)); <span class="comment">// [&#x27;firstName&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="configurable-false"><a href="#configurable-false" class="headerlink" title="configurable : false"></a>configurable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[configurable]] 값이 false 인 경우 해당 프로퍼티를 삭제할 수 없다.</span></span><br><span class="line"><span class="comment">// 삭제해도 에러없이 무시된다.</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">lastName</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 또한, 해당 프로퍼티를 재정의 할 수도 없다.</span></span><br><span class="line"><span class="comment">// Object.defineProperty(person, &#x27;lastName&#x27;, &#123; enumerable : true &#125;);</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: firstName</span></span><br></pre></td></tr></table></figure>

<h2 id="접근자-프로퍼티-정의"><a href="#접근자-프로퍼티-정의" class="headerlink" title="접근자 프로퍼티 정의"></a>접근자 프로퍼티 정의</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;fullName&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&quot;yoonju hong&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &#x27;yoonju&#x27;, lastName: &#x27;Kim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lastName은 writable이 false여서 값이 안바뀌는 것을 볼 수 있다.</li>
</ul>
<h1 id="객체-변경-방지"><a href="#객체-변경-방지" class="headerlink" title="객체 변경 방지"></a>객체 변경 방지</h1><p>객체 변경을 방지하는 메서드를 제공한다. 종류에 따라 금지하는 강도가 다르다.</p>
<p>직속 프로퍼티만 방지(얕은 방지)</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>메서드</th>
<th>프로퍼티 추가</th>
<th>삭제</th>
<th>값 읽기</th>
<th>값 쓰기</th>
<th>프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td>X</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
<td>X (configurable : false)</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>X (writable : false)</td>
<td>X (configurable : false)</td>
</tr>
</tbody></table>
<p>객체 확장 금지 확인 메서드 - Object.isExtensible( ) false면 확장 금지된 객체</p>
<p>객체 밀봉 확인 메서드 - Object.isSealed( ) true면 밀봉된 객체</p>
<p>객체 동결 메서드 - Object.isFrozen( ) true면 동결된 객체</p>
<p>깊은 방지를 구현하려면 재귀적으로 객체 값을 갖는 모든 프로퍼티에 대해 Object.freeze 메서드를 호출해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepFreeze</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않는 객체만 동결</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> &amp;&amp; !<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(target)) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">freeze</span>(target);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> <span class="title function_">deepFreeze</span>(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">&quot;Seoul&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 깊은 객체 동결</span></span><br><span class="line"><span class="title function_">deepFreeze</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person.<span class="property">address</span>));</span><br><span class="line"></span><br><span class="line">person.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&quot;Busan&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/16/Javascript/%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%91%E1%85%A5%E1%84%90%E1%85%B5%20%E1%84%8B%E1%85%A5%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%E1%84%87%E1%85%B2%E1%84%90%E1%85%B3/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/12/Javascript/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%E1%84%8B%E1%85%AA%20var,let,const/"
                            aria-label=": 스코프와 var,let,const"
                        >
                            스코프와 var,let,const
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-12T13:57:17+09:00">
	
		    2022/08/12
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="스코프와-let-const-키워드"><a href="#스코프와-let-const-키워드" class="headerlink" title="스코프와 let, const 키워드"></a>스코프와 let, const 키워드</h1><p>오늘은 스코프와 ES6에서 새로 등장한 let,const 키워드에 대해 알아보자.</p>
<hr>
<h2 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h2><p>스코프란, 식별자가 참조할 수 있는 범위(유효범위)를 말한다. 자바스크립트 엔진이 식별자를 찾기 위해 사용하는 규칙이다.</p>
<ul>
<li>모든 식별자는 자신이 선언된 위치에 의해 상위 스코프를 결정한다.</li>
<li>식별자는 어떤 값을 구별하기 위해 유일 해야하므로 <span style="color:red">중복될 수 없다.</span> 단, 스코프가 다르면 중복될 수 있다.</li>
</ul>
<h3 id="지역-스코프"><a href="#지역-스코프" class="headerlink" title="지역 스코프"></a>지역 스코프</h3><p>자바스크립트는 함수 레벨 스코프를 갖는다. 그러므로 지역이란, 함수 몸체 내부를 말한다.</p>
<p>즉, 지역 스코프는 함수에 의해서 생성된다.</p>
<blockquote>
<p>let, const가 나오면서 블록 레벨 스코프를 갖는 식별자를 선언할 수 있다. 여기서 지역 스코프는 코드 블록에 의해 생성된다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>

<p>var 키워드는 함수 레벨 스코프를 갖는다. 즉, 함수 몸체 내부에서 var 키워드로 선언된 변수는 지역 스코프 범위를 참조할 수 있다. 함수 몸체 이외에서 선언된 변수는 모드 전역 스코프 범위로 본다.</p>
<h3 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h3><p>스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 모든 스코프는 하나의 계층적 구조로 연결된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 전역 스코프</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = -<span class="number">100</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 100</span></span><br><span class="line">  <span class="title function_">inner</span>(); <span class="comment">// -100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure>

<ol>
<li><p>전역 스코프 (최상위 스코프)</p>
</li>
<li><p>outer 지역 스코프</p>
</li>
<li><p>inner 지역 스코프</p>
</li>
</ol>
<p>자바스크립트 엔진은 변수를 참조하는 스코프에서 시작하여 <span style="color:red">상위 스코프 방향</span>으로 이동하며 변수를 검색한다.</p>
<blockquote>
<p>실제 자바스크립트 엔진은 코드를 실행하기 전 렉시컬 환경이라는 자료구조를 생성한다. 변수 선언이 실행되면 변수 식별자가 자료구조의 key로 등록되고 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경한다.</p>
</blockquote>
<h3 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h3><p>렉시컬 스코프란, 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.</p>
<p><span style="color:red">함수 호출이 아닌</span> 함수 정의(함수 선언문, 함수 표현식)가 실행되어 생성된 함수 객체는 자신이 정의된 스코프인 상위 스코프를 기억한다.</p>
<blockquote>
<p>즉, 내가(함수가) 정의된 스코프가 자신의 상위 스코드이다.</p>
</blockquote>
<hr>
<h2 id="전역변수와-var-키워드"><a href="#전역변수와-var-키워드" class="headerlink" title="전역변수와 var 키워드"></a>전역변수와 var 키워드</h2><p>변수는 생명주기가 있어 선언에 의해 생성되고 언젠가 소멸한다. 소멸하는 시점은 스코프에 따라 다르다.</p>
<ul>
<li><p>전역변수 : 런타임 이전에 자바스크립트 엔진에 의해 선언되고 애플리케이션이 종료되면 소멸한다.</p>
</li>
<li><p>지역변수 : 함수가 호출될 때 생성되고 함수가 종료하면 소멸한다. 함수가 호출되는 순간 함수 몸체에 있는 선언들이 호이스팅 된다.</p>
</li>
</ul>
<h3 id="전역변수의-문제점"><a href="#전역변수의-문제점" class="headerlink" title="전역변수의 문제점"></a>전역변수의 문제점</h3><ol>
<li><p>암묵적 결합<br>어디서든 참조하고 변경할 수 있어 의도치 않게 변경될 수 있다.</p>
</li>
<li><p>긴 생명주기</p>
</li>
</ol>
<p>메모리 자원도 오랜 기간 소비한다. 1번의 위험이 오래 지속되어 오류의 기회가 많아진다.</p>
<ol start="3">
<li>네임 스페이스 오염</li>
</ol>
<p>자바스크립트는 파일을 분리해도 전역 스코프를 공유한다는 점에서 다른 파일에서 동일한 이름의 전역 변수끼리 충돌이 일어날 수 있다.</p>
<blockquote>
<p>그러므로 전역변수를 꼭 써야하는 상황이 아니라면 사용하지 말자.</p>
</blockquote>
<h3 id="전역변수-사용-억제-방법"><a href="#전역변수-사용-억제-방법" class="headerlink" title="전역변수 사용 억제 방법"></a>전역변수 사용 억제 방법</h3><ol>
<li><p>즉시실행함수<br>즉시실행함수를만들어 함수 종료 시 변수도 사라져 메모리 해제도 빨리 되고 지역 스코프를 가져 충돌의 위험을 줄일 수 있다.</p>
</li>
<li><p>모듈패턴<br>클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈로 만든다.</p>
</li>
</ol>
<p>전역변수 억제와 캡슐화까지 가능하다.</p>
<blockquote>
<p>캡슐화란, 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 메서드를 하나로 묶는 것을 말한다. 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 한다.(정보은닉)</p>
</blockquote>
<h3 id="var-키워드"><a href="#var-키워드" class="headerlink" title="var 키워드"></a>var 키워드</h3><p>var 키워드는 함수 레벨 스코프를 따른다. 함수 몸체 외부에서 var 키워드로 선언시 전역 변수로 선언되고 전역 스코프를 갖는다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">// 10;</span></span><br></pre></td></tr></table></figure>

<p>var 키워드는 전역에서 선언시 전역 객체의 프로퍼티로 등록된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  z = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>키워드로 선언되지 않은 변수는 어디에서든지 항상 전역 변수이다.</p>
<p>선언되지 않은 변수는 해당 코드가 실행되어야 존재한다.</p>
<blockquote>
<p>키워드 없이 선언하는 것은 옳지 않다.</p>
</blockquote>
<p><span style="font-size:1.2rem">러버덕하면서 알게된 내용</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">//  &#123;value: 100, writable: true, enumerable: true, configurable: false&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, <span class="string">&quot;y&quot;</span>); <span class="comment">// &#123;value: 50, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>var 키워드로 선언된 변수와 암묵적 선언으로 선언된 변수 모두 전역 객체의 프로퍼티로 등록된다.</p>
<p>하지만, 객체의 프로퍼티를 보면 configurable 값이 다른 것을 볼 수 있는데, 이것이 true이면 재정의(삭제, 변경)가 가능하다는 의미이다.</p>
<p>따라서 암묵적 선언으로 전역 객체의 프로퍼티로 등록이 되면 재정의가 가능하므로 암묵적 선언은 사용하지 않는 것이 좋다.</p>
<hr>
<h2 id="let-const-키워드"><a href="#let-const-키워드" class="headerlink" title="let, const 키워드"></a>let, const 키워드</h2><p>let, const 키워드는 블록 레벨 스코프를 따른다. 그러므로 var 키워드의 함수 레벨 스코프보다 더 한정적인 스코프를 지원하여 작은 범위의 스코프를 다룰 수 있어 유용하다.</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>var 키워드와 비교하여 let 키워드를 알아보자.</p>
<ol>
<li><p>변수 중복 선언 금지</p>
</li>
<li><p>블록 레벨 스코프</p>
</li>
</ol>
<p>let 키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다. 전역 객체의 프로퍼티가 되는 것들은 var 키워드로 선언한 전역변수 및 전역함수, 그리고 선언하지 않는 변수에 값을 할당한 암묵적 전역이 있다. 이에 대해서는 실행 컨텍스트에 대해 배울 때 자세히 배우자.</p>
<ol start="3">
<li>변수 호이스팅</li>
</ol>
<p>var 키워드로 선언한 변수는 선언단계와 초기화 단계가 동시에 진행된다. 하지만 let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다.</p>
<p>선언단계가 자바스크립트 엔진에 의해 실행되고 <span style="color:red">초기화 단계는 변수 선언문에 도달했을 때</span>, 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br></pre></td></tr></table></figure>

<p>언뜻보면 let 키워드는 호이스팅이 일어나지 않는 것처럼 보이지만, 선언단계는 호이스팅이 되어 최상단에서 먼저 실행되었고 초기화 단계는 선언문에 도달했을 경우 진행되기 때문에 위와 같은 현상이 발생하는 것이다.</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>let 키워드와 비교해서 알아보자</p>
<ol>
<li>선언과 초기화</li>
</ol>
<p>const 키워드로 선언한 변수는 개발자가 선언과 초기화를 동시에 해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz; <span class="comment">// Uncaught SyntaxError : Unexpected identifier</span></span><br></pre></td></tr></table></figure>

<p>이전에 선언을 하면 선언단계와 초기화 단계가 진행된다 그랬었는데, 이것도 초기화가 맞지만 const를 사용하기 위해서는 개발자가 직접 초기화를 해줘야한다. 만약 초기화를 해주지 않고 나중에 값을 할당한다는 것이 재할당으로 해석되기 때문이다.</p>
<ol start="2">
<li>재할당 금지</li>
</ol>
<p>const 키워드로 선언한 변수에 원시값을 할당하면 값을 변경할 수 없다. 하지만 객체를 할당한 경우 값을 변경할 수 있다. 재할당 금지라는 말이 불변을 의미하지는 않는다. 왜냐하면 식별자가 가리키는 메모리 주소 공간은 참조값이 저장되어 있고 객체를 변경하여도 참조값은 변하지 않기 때문이다.</p>
<ol start="3">
<li>상수</li>
</ol>
<p>변하지 않는 값을 사용하기 위해 우리는 상수를 사용한다.</p>
<p>주로 상수의 이름은 대문자로 사용한다. 원시값을 할당한 경우 원시값은 변경 불가능한 값이고 재할당이 금지되므로 할당된 값을 변경할 방법은 없다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/12/Javascript/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%E1%84%8B%E1%85%AA%20var,let,const/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/11/Javascript/%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE/"
                            aria-label=": 함수"
                        >
                            함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-11T17:03:55+09:00">
	
		    2022/08/11
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="Function-함수"><a href="#Function-함수" class="headerlink" title="Function 함수"></a>Function 함수</h1><p>오늘은 자바스크립트의 함수에 대해 공부해보자.</p>
<p>자바스크립트에서 함수란, 코드블록으로 일련의 문(statement)을 감싸서 하나의 실행 단위로 정의한 것이다.</p>
<blockquote>
<p>함수를 목적에 맞게 사용하기 위해서는 함수이름, 매개변수, 인자 등을 알맞게 설정해줘야한다. 그렇지 않게 사용하는 것은 지양한다.</p>
</blockquote>
<h2 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h2><p>함수를 사용하는 목적은 필요할 때마다 호출하여 일련의 코드들을 재사용하기 위해 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnRank</span>(<span class="params">name, tall</span>) &#123;</span><br><span class="line">  <span class="comment">// 이름과 키라는 매개변수를 통해 순위를 반환해주는 함수</span></span><br><span class="line">  <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100번째 줄</span></span><br><span class="line"><span class="title function_">returnRank</span>(<span class="string">&quot;yiju&quot;</span>, <span class="number">188</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 300번째 줄</span></span><br><span class="line"><span class="title function_">returnRank</span>(<span class="string">&quot;kim&quot;</span>, <span class="number">160</span>);</span><br></pre></td></tr></table></figure>

<p>위와 같이 하나의 로직을 여러 곳에서 재사용하고 싶을 때 함수를 사용하면 함수 이름으로 <span style="color:red">가독성</span>도 높아지고 100번째 줄이나 300번째 줄에서 코드가 문제가 발생했을 경우 returnRank 함수가 선언된 부분만 유지보수를 해주면 되기 때문에 <span style="color:red">유지보수</span>가 간편해진다.</p>
<blockquote>
<p>단, 함수는 목적에 맞게 가급적 작게 만들고 매개변수도 3개를 넘지 않도록 만들 것을 지향한다.</p>
</blockquote>
<hr>
<h2 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h2><p>함수를 정의하는 방식은 4가지 방식이 있다.</p>
<ul>
<li>함수 선언문</li>
<li>함수 표현식</li>
<li>Function 생성자 함수</li>
<li>화살표 함수(ES6)</li>
</ul>
<p>기본적인 함수 선언문과 함수 표현식에 대해 알아보자</p>
<blockquote>
<p>자바스크립트에서 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의가 모호하다.(MDN에서도 모호..) 위에서 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 그렇기 때문에 “함수는 정의된다”로 표현한다. C언어에서 정의는 변수에 값을 할당하여 변수의 실체를 명확히 하는 것이다. 즉, 메모리 주소가 연결되면 정의라고 판단)</p>
</blockquote>
<h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>리터럴은 문자나 약속된 기호를 사용하여 값을 생성하는 표기법이다. 함수로 함수 리터럴을 사용하여 값을 생성할 수 있다. 함수 리터럴은 다음으로 구성되어 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>function 키워드</li>
<li>함수 이름 (add) <b>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자</b></li>
<li>매개변수 목록 (x,y)</li>
<li>함수 몸체({})</li>
</ul>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출 (함수이름과 똑같은 식별자를 사용)</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>함수 선언문은 표현식이 아닌 문이다.</li>
<li>함수 선언문은 함수 이름을 생략할 수 없다.</li>
</ul>
<p>앞서 언급했듯이 함수 이름은 함수 몸체 내에서만 참조 가능하다. 그렇다면 함수를 호출하려면 어떻게 할 수 있을까?</p>
<p>함수 선언문으로 사용되면 자바스크립트 엔진이 <b>암묵적</b>으로 함수 이름과 똑같은 식별자를 생성하고 함수 객체를 할당한다.</p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출 (함수 이름으로 호출)</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>자바스크립트 함수는 객체타입의 값이기 때문에 변수에 할당하거나 프로퍼티의 값으로 될 수 있고 배열과 같은 자료구조의 요소가 될 수 있다.</p>
<p>이러한 성질 때문에 자바스크립트 함수는 <span style="color:red">일급객체</span>다.</p>
<ul>
<li>함수 표현식은 함수 이름 생략하는 것이 일반적이다.</li>
<li>함수 표현식은 표현식인 문이다. 즉, 값처럼 사용할 수 있다. ex)변수할당</li>
</ul>
<hr>
<h2 id="중의적-코드-기명-함수-리터럴"><a href="#중의적-코드-기명-함수-리터럴" class="headerlink" title="중의적 코드 : 기명 함수 리터럴"></a>중의적 코드 : 기명 함수 리터럴</h2><p>함수 선언문은 함수 이름을 생략할 수 없으며 표현식이 아닌 문이므로 변수에 할당할 수 없다. 그러면 아래의 코드는 어떻게 동작할지 예상해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 리터럴 단독 사용 문맥 =&gt; 함수 선언문으로 해석</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 할당하는 문맥 =&gt; 함수 리터럴 표현식으로 해석</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 피연산자로 사용되는 문맥 =&gt; 함수 리터럴 표현식으로 해석</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferenceError : bar is not defined</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서는 함수 선언문이 변수에 할당된 것처럼 보인다. 이게 어떻게 가능할까?</p>
<p>우리는 블록문 {}에서 앞서 중의적 표현과 문맥에 대해 다룬 적이 있다.</p>
<p>자바스크립트 엔진이 {}를 객체 리터럴로 인지할 것인지, 아니면 코드 블록문으로 인지할 것인지는 <strong style="font-size:1.5rem">문맥</strong>에 따라 다르게 결정된다.</p>
<p>이와 같이 기명 함수 리터럴도 중의적인 코드이므로 문맥에 따라 해석이 달라질 수 있다. 다음은 자바스크립트 엔진이 기명 함수 리터럴을 해석하는 방식이다.</p>
<ol>
<li><p>기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석</p>
</li>
<li><p>함수 리터럴이 값으로 평가되어야 하는 문맥, 예시처럼 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다.</p>
</li>
</ol>
<p>() 그룹 연산자 안에서 기명 함수 리터럴은 함수 리터럴 표현식으로 해석된다.</p>
<p>함수 리터럴에서 함수 이름은 함수 몸체 내부에서만 참조가능하기 때문에 외부에서 함수이름으로 호출시 에러 발생</p>
<blockquote>
<p>함수 선언문의 경우 함수이름으로 암묵적으로 식별자를 생성하여 객체를 할당해주기 때문에 함수 이름으로 호출 가능</p>
</blockquote>
<hr>
<h2 id="함수-선언문-vs-함수-표현식"><a href="#함수-선언문-vs-함수-표현식" class="headerlink" title="함수 선언문 vs 함수 표현식"></a>함수 선언문 vs 함수 표현식</h2><p>함수 선언문과 함수 표현식은 <strong>생성 시점</strong>이 다르다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(add); <span class="comment">// ƒ add(x, y) &#123;return x + y;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>함수 선언문 : 모든 선언문이 런타임 이전에 JS엔진에 먼저 실행된다. 즉, 암묵적으로 함수 이름과 동일한 식별자를 생성하여 함수 객체를 할당한다. <span style="color:red">함수 호이스팅</span></p>
</li>
<li><p>함수 표현식 : 변수 선언 부분은 변수 호이스팅이 발생하여 undefined로 초기화되고 변수 할당문은 런타임에서 평가되어 함수 객체로 할당된다.</p>
</li>
</ul>
<hr>
<h2 id="함수호출"><a href="#함수호출" class="headerlink" title="함수호출"></a>함수호출</h2><p>일반 객체와 함수가 다른점은 함수는 호출을 할 수 있다는 것이다. 호출과 참조는 다르다. 호출은 실행흐름을 바꾸기도 하며 코드문들의 결과값을 반환해준다.</p>
<p>() 함수 호출 연산자를 사용하여 함수를 호출할 수 있다. 그러면 실행흐름이 함수로 옮겨지고 return 키워드를 만나게되면 그 즉시 함수 실행을 종료하고 return 키워드 우측 표현식에 대한 값을 반환한다.</p>
<blockquote>
<p>return 키워드 다음 행의 문들은 무시된다. return 키워드 다음에 개행하여 코드를 작성하면 자동 세미콜론 삽입 기능에 의해 큰 오류를 발생시킬 수 있다.</p>
</blockquote>
<h3 id="인수"><a href="#인수" class="headerlink" title="인수"></a>인수</h3><p>함수를 호출할 때 매개변수에 들어갈 인수를 전달해줘야한다. 하지만 인수가 매개변수보다 적거나 많더라도 오류를 발생시키지 않는다.</p>
<ul>
<li>매개변수보다 인수를 적게 전달할 경우 부족한 매개변수는 undefined 처리된다.</li>
<li>매개변수보다 인수가 많아도 오류 발생 시키지 않는다. 단, 모든 인수는 arguments 객체의 프로퍼티로 보관된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y = <span class="number">0</span>,z</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, ,<span class="number">5</span>); <span class="comment">// X</span></span><br></pre></td></tr></table></figure>

<p>중간에 y값의 매개변수를 생략하고 싶어서 공백으로 둬서 호출할 수 없다.</p>
<p>만약 인자를 순서를 신경쓰지 않고 전달해주고 싶다면 객체를 인자로 전달해주면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>단, 함수 내부에서 객체를 변경하게 되면 참조값으로 복사되었기 때문에 <span style="color:red">함수 외부의 객체가 변경되는 부수효과</span>가 발생할 수 있으니 주의해야한다.</p>
<hr>
<h2 id="순수함수와-비순수함수"><a href="#순수함수와-비순수함수" class="headerlink" title="순수함수와 비순수함수"></a>순수함수와 비순수함수</h2><p>외부 상태에 의존하거나 참조하거나 즉, 부수효과가 없는 함수를 순수함수라고 하고 그렇지 않은 함수를 비순수함수라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 함수는 a,b 매개변수가 함수 내부로 전달되어도 외부 변수 x의 값이 변경되면 결과값이 달라지기 때문에 순수함수가 아니다.</p>
<p>순수함수는 오직 매개변수만을 통해 함수 내부로 전달된 인수에게만 의존하여 값을 생성해 반환한다. <span style="color:red">전달받은 인수는 변경하지 않는다.</span></p>
<blockquote>
<p>하지만 우리가 순수함수만으로 프로그래밍을 하는 것은 불가능하다. 함수형 프로그래밍은 반복문, 조건문을 제거하여 복잡성을 해결하고 전역 변수 사용을 억제 및 생명주기 최소화하여 상태변경을 최소화하는 것을 목표로 하기 때문에 순수함수만을 사용하는 것은 옳지 않다.</p>
</blockquote>
<h3 id="콜백함수"><a href="#콜백함수" class="headerlink" title="콜백함수"></a>콜백함수</h3><p>함수의 매개변수를 통해 함수 내부로 전달되는 함수를 콜백함수라고 한다. 또한 콜백함수를 매개변수를 통해 받은 함수는 고차함수라고 한다.</p>
<p>콜백함수는 함수 외부에서 고차함수 내부로 주입하기 때문에 자유롭게 교체가 가능하고 경우에 따라 변경되는 로직을 가진 외부 함수를 내부로 전달할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복호출</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">n, f</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="title function_">f</span>(i); <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeat</span>(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeat</span>(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>콜백함수를 전달할 때에는 콜백함수를 호출하지 않고 함수 전달만 해야한다.</li>
</ul>
<p><strong style="font-size:1.5rem">콜백함수는 비순수함수인가?</strong></p>
<p>“앞서 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 <span style="color:red">객체</span>를 전달받으면 비순수함수가 된다.”</p>
<p>&#x3D;&gt; 맞다 콜백함수도 비순수 함수이다. 나중에 addEventListener 함수도 콜백함수를 매개변수로 받아 DOM을 조작하는 것도 배울 텐데 DOM을 조작한다는 것 자체가 비순수함수가 되는 것이다. 다시말해 순수함수만으로 코드를 짜는것은 불가능하다.</p>
<hr>
<h2 id="소감"><a href="#소감" class="headerlink" title="소감"></a>소감</h2><p>모던 자바스크립트 12장 함수 파트를 읽으면서 함수 정의와 목적에 대해 배웠고 그동안 무의식적으로 사용했던 함수 이름을 통한 호출에 대해 이유를 알게되어 재밌었다.</p>
<p>코드 맥락에 맞게 자바스크립트 엔진이 해석하는게 달라질 수 있다는 점과 콜백함수와 순수, 비순수 함수에 대해 제대로 알고 넘어갈 수 있어 좋았다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/11/Javascript/%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/11/"
                aria-label="최근 포스트"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>최근 포스트</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/archives/page/13/"
                aria-label="이전 포스트"
            >
              <span>이전 포스트</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 12 of 13</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 loco9939. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loco9939</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-wcqoifde3xwnijjx9xd2irfrrksglozwqpgaqfvxoft22e4znrk7db1xxnsx.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
