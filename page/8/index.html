
<!DOCTYPE html>
<html lang="ko">
    <link rel="canonical" href="https://loco9939.github.io/page/8/"/>

<head>
    <meta name="google-site-verification" content="7ur7A9bi79NuylPOO6FjMynEeinWe-v-kmDPZD-bcqY" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Loco&#39;s Dev Blog">
    <title>Loco&#39;s Dev Blog</title>
    <meta name="author" content="loco9939">
    
        <meta name="keywords" content="loco9939,javascript,">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"Website","@id":"https://loco9939.github.io","author":{"@type":"Person","name":"loco9939","sameAs":["https://github.com/loco9939","mailto"]},"name":"Loco's Dev Blog","description":"","url":"https://loco9939.github.io","keywords":"loco9939, javascript"}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Loco&#39;s Dev Blog">
<meta property="og:url" content="https://loco9939.github.io/page/8/index.html">
<meta property="og:site_name" content="Loco&#39;s Dev Blog">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="loco9939">
<meta property="article:tag" content="loco9939">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-alaac2o0p8lb5n7mx8aazw1dzhwcsltexgjtf9twurzytkujqiefoq1soijy.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Loco&#39;s Dev Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/loco9939"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/Event/"
                            aria-label=": Event"
                        >
                            Event
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:38:57+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="이벤트-드리븐-프로그래밍"><a href="#이벤트-드리븐-프로그래밍" class="headerlink" title="이벤트 드리븐 프로그래밍"></a>이벤트 드리븐 프로그래밍</h1><p>브라우저는 처리해야할 특정 사건이 발생하면 이를 감지하여 **이벤트(event)를 발생(trigger)**시킨다. 사용자가 어떤 행동을 하였을 때 브라우저가 이를 감지하여 함수를 호출하고 싶을 때 이벤트 드리븐 프로그래밍 방식을 사용한다.</p>
<p>즉, 이벤트란? 브라우저가 특정 사건이 발생한 것을 감지하고 함수를 호출하기 위해 필요한 것이다.</p>
<p><strong>즉, 함수를 언제 호출할지 알 수 없으므로 개발자가 명시적으로 함수를 호출하는 것이 아니라 브라우저에게 함수 호출을 위임하는 것이다.</strong></p>
<ul>
<li>이벤트 발생시 호출될 함수 ⇒ <strong>이벤트 핸들러</strong></li>
<li>이벤트 발생시 브라우저에게 이벤트 핸들러의 호출을 위임 ⇒ <strong>이벤트 핸들러 등록</strong></li>
</ul>
<p>Window, Document, HTMLElement 타입의 객체는 onclick과 같이 특정 이벤트에 대응하는 다양한 이벤트 핸들러 프로퍼티를 가지고 있다. 이 이벤트 핸들러 프로퍼티에 함수를 할당하면 해당 이벤트가 발생했을 때, <strong>할당한 함수가 브라우저에 의해 호출된다.</strong></p>
<p>이와 같이 프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 이벤트 드리븐 프로그래밍이라고 한다.</p>
<h1 id="이벤트-타입"><a href="#이벤트-타입" class="headerlink" title="이벤트 타입"></a>이벤트 타입</h1><p>이벤트 타입은 이벤트의 종류를 나타내는 문자열이다. 대표적으로 마우스 이벤트(click, mouseup, mousemove, mouseover…), 키보드 이벤트(keydown, keypress…), 포커스 이벤트(focus, focusin…) 등 다양한 이벤트가 있다.</p>
<aside>
💡 mousedown은 클릭후 손가락 떼지 않은 상태, click은 클릭하고 마우스에서 뗀 것

</aside>

<ul>
<li>이벤트 핸들러 프로퍼티 방식과 addEventListener 메서드 방식으로 등록할 수 있다.</li>
</ul>
<h1 id="이벤트-핸들러-등록-방식"><a href="#이벤트-핸들러-등록-방식" class="headerlink" title="이벤트 핸들러 등록 방식"></a>이벤트 핸들러 등록 방식</h1><h2 id="이벤트-핸들러-프로퍼티-방식"><a href="#이벤트-핸들러-프로퍼티-방식" class="headerlink" title="이벤트 핸들러 프로퍼티 방식"></a>이벤트 핸들러 프로퍼티 방식</h2><p>이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.</p>
<ul>
<li>이벤트 핸들러는 대부분 이벤트를 발생시킬 이벤트 타깃에 바인딩한다. <strong>하지만 반드시 이벤트 타깃에 이벤트 핸들러를 바인딩해야하는 것은 아니다.</strong></li>
<li>이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러만 바인딩할 수 있다는 단점이 있다.</li>
</ul>
<h2 id="addEventListener-메서드-방식"><a href="#addEventListener-메서드-방식" class="headerlink" title="addEventListener 메서드 방식"></a>addEventListener 메서드 방식</h2><p>EventTarget.prototype.addEventListener 메서드를 사용하여 이벤트 핸들러를 등록할 수 있다.</p>
<ul>
<li>이벤트 타입을 전달시 on 접두사를 붙이지 않는다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 이벤트 핸들러 프로퍼티 방식</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		$button.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;button click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">		&#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// addEventListener 메서드 방식</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;button click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>이벤트 핸들러 프로퍼티 방식과 달리 <code>addEventListener</code> 메서드에는 이벤트 핸들러를 인수로 전달한다.</li>
<li>위 예제대로 두가지 방식을 같이 사용하여도 서로에게 영향을 주지 않으므로 클릭 이벤트 발생 시 2개의 이벤트 핸들러가 모두 호출된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// addEventListener 메서드는 동일한 요소에서 발생한 동일한 이벤트에 대해</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 하나 이상의 이벤트 핸들러를 등록할 수 있다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[1]button click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;[2]button click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>동일한 HTML 요소에서 발생한 동일한 이벤트에 대해 이벤트 핸들러 프로퍼티 방식은 하나 이상의 이벤트 핸들러를 등록할 수 없지만, <code>addEventListener</code> 메서드는 <strong>하나 이상의 이벤트 핸들러를 등록</strong>할 수 있다.</li>
</ul>
<h1 id="이벤트-핸들러-제거"><a href="#이벤트-핸들러-제거" class="headerlink" title="이벤트 핸들러 제거"></a>이벤트 핸들러 제거</h1><p>addEventListener 메서드로 등록된 이벤트를 제거하기 위해 removeEventListener 메서드를 사용한다.</p>
<ul>
<li>단, addEventListener 메서드에게 전달한 인수와 removeEventListener 메서드에게 전달한 인수가 같아야 한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $button = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;button click&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 이벤트 핸들러 등록</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 이벤트 핸들러 제거</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// addEventListener 메서드에 전달한 인수와 removeEventListener 메서드에</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick, <span class="literal">true</span>); <span class="comment">// 실패</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $button.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;click&#x27;</span>, handleClick); <span class="comment">// 성공</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>이벤트 핸들러로 전달한 등록 이벤트 핸들러가 동일해야 하므로 <strong>무명 함수를 이벤트 핸들러로 등록한 경우 제거할 수 없다.</strong> 이 경우 이벤트 핸들러를 제거하기 위해서는 이벤트 핸들러 참조를 변수나 자료구조에 저장하고 있어야 한다.</li>
</ul>
<aside>
💡 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러를 제거하는 방식은 null을 할당하는 것이다.

</aside>

<h1 id="이벤트-객체"><a href="#이벤트-객체" class="headerlink" title="이벤트 객체"></a>이벤트 객체</h1><p><strong>이벤트 발생 시</strong> 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. <strong>생성된 이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달된다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>클릭하세요. 클릭한 곳의 좌표가 표시됩니다.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $msg = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.message&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 클릭 이벤트에 의해 생성된 이벤트 객체는 이벤트 핸들러의 첫 번째 인수로 전달된다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">showCoords</span>(<span class="params">e</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $msg.<span class="property">textContent</span> = <span class="string">`clientX: <span class="subst">$&#123;e.clientX&#125;</span>, clientY: <span class="subst">$&#123;e.clientY&#125;</span>`</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">document</span>.<span class="property">onclick</span> = showCoords;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>이벤트 객체는 이벤트 핸들러의 첫번째 인수로 전달되어 매개변수 e에 암묵적으로 할당된다. 이는 브라우저가 이벤트 핸들러 호출할 때, 이벤트 객체를 인수로 전달하기 때문이다.</li>
</ul>
<blockquote>
<p>이벤트 타입에 따라 생성되는 이벤트 객체의 고유한 프로퍼티가 달라진다.</p>
</blockquote>
<h2 id="이벤트-객체의-공통-프로퍼티"><a href="#이벤트-객체의-공통-프로퍼티" class="headerlink" title="이벤트 객체의 공통 프로퍼티"></a>이벤트 객체의 공통 프로퍼티</h2><table>
<thead>
<tr>
<th>공통 프로퍼티</th>
<th>설명</th>
<th>타입</th>
</tr>
</thead>
<tbody><tr>
<td>type</td>
<td>이벤트 타입</td>
<td>string</td>
</tr>
<tr>
<td>target</td>
<td>이벤트를 발생시킨 DOM 요소</td>
<td>DOM 요소 노드</td>
</tr>
<tr>
<td>currentTarget</td>
<td>이벤트 핸들러가 바인딩된 DOM 요소</td>
<td>DOM 요소 노드</td>
</tr>
<tr>
<td>eventPhase</td>
<td>이벤트 전파 단계 (0: 이벤트없음, 1: 캡처링 단계, 2: 타깃 단계, 3: 버블링 단계)</td>
<td>number</td>
</tr>
<tr>
<td>bubbles</td>
<td>false면 버블링하지 않는다.</td>
<td>boolean</td>
</tr>
<tr>
<td>cancelable</td>
<td>preventDefault 메서드 호출하여 이벤트 기본 동작 취소 가능한지 여부 false면 취소할 수 없다.</td>
<td>boolean</td>
</tr>
<tr>
<td>defaultPrevented</td>
<td>preventDefault 메서드 호출하여 이벤트 취소했는지 여부</td>
<td>boolean</td>
</tr>
<tr>
<td>isTrusted</td>
<td>사용자 행위에 의해 발생한 이벤트인지 여부, click메서드, dispatchEvent 메서드를 통해 인위적으로 발생시킨 이벤트인 경우 false</td>
<td>boolean</td>
</tr>
</tbody></table>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;message&quot;</span>&gt;</span>off<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $checkbox = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;input[type=checkbox]&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $msg = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.message&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// change 이벤트가 발생하면 Event 타입의 이벤트 객체가 생성된다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $checkbox.<span class="property">onchange</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(e) === <span class="title class_">Event</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// e.target은 change 이벤트를 발생시킨 DOM 요소 $checkbox를 가리키고</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// e.target.checked는 체크박스 요소의 현재 체크 상태를 나타낸다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $msg.<span class="property">textContent</span> = e.<span class="property">target</span>.<span class="property">checked</span> ? <span class="string">&#x27;on&#x27;</span> : <span class="string">&#x27;off&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>사용자 입력에 의해 checked 프로퍼티 값 변경되면 change 이벤트 발생하고 Event 타입의 이벤트 객체가 생성된다.</li>
<li>이벤트 객체의 <strong>target 프로퍼티</strong>는 이벤트를 발생시킨 객체를 나타낸다. 즉, <strong>change 이벤트를 발생시킨 DOM 요소인 $checkbox</strong> 이다.</li>
<li>이벤트 객체의 currentTarget 프로퍼티는 이벤트 핸들러가 바인딩된 DOM 요소를 가리킨다.</li>
<li>일반적으로 이벤트 객체의 target 프로퍼티와 currentTarget 프로퍼티는 동일한 객체를 가리키지만 나중에 이벤트 위임에서는 서로 다른 객체를 가리킬 수 도 있다.</li>
</ul>
<h1 id="이벤트-전파"><a href="#이벤트-전파" class="headerlink" title="이벤트 전파"></a>이벤트 전파</h1><p>DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다.</p>
<ul>
<li>생성된 이벤트 객체는 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;apple&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $fruits = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fruits&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// #fruits 요소의 하위 요소인 li 요소를 클릭한 경우</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $fruits.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`이벤트 단계: <span class="subst">$&#123;e.eventPhase&#125;</span>`</span>); <span class="comment">// 3: 버블링 단계</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`이벤트 타깃: <span class="subst">$&#123;e.target&#125;</span>`</span>); <span class="comment">// [object HTMLLIElement]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`커런트 타깃: <span class="subst">$&#123;e.currentTarget&#125;</span>`</span>); <span class="comment">// [object HTMLUListElement]</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제는 ul 요소에 이벤트 핸들러 바인딩하고 ul 요소의 하위 요소인 li 요소를 클릭하여 이벤트를 발생 시켜보자. <strong>event.target은 li 요소이고, event.currentTarget은 ul 요소이다.</strong></li>
</ul>
<h2 id="과정"><a href="#과정" class="headerlink" title="과정"></a>과정</h2><ol>
<li>li 요소 클릭시 클릭 이벤트 발생하여 <strong>클릭 이벤트 객체를 생성</strong>한다. <strong>클릭된 li 요소가 이벤트 타깃</strong>이 된다. 이 때 이벤트 객체는 window에서 시작해서 이벤트 타깃 방향으로 전파된다. <strong>(캡처링 단계)</strong></li>
<li>이벤트 객체는 이벤트를 발생시킨 이벤트 타깃에 도달한다. <strong>(타깃 단계)</strong></li>
<li>이벤트 객체는 이벤트 타깃에서 시작해서 window 방향으로 전파된다. <strong>(버블링 단계)</strong></li>
</ol>
<ul>
<li>이벤트 핸들러 어트리뷰트&#x2F;프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃단계와 버블링 단계의 이벤트만 캐치할 수 있지만, <strong>addEventListener 메소드로 등록한 이벤트 핸들러는 타깃단계, 버블링단계, 캡처링 단계의 이벤트도 선별적으로 캐치</strong>할 수 있다. 캡처링 단계의 이벤트 캐치하려면 addEventListener 메소드의 3번째 인수로 true를 전달해야한다.</li>
</ul>
<p><strong>즉, 이벤트는 이벤트를 발생시킨 이벤트 타깃을 물론 상위 DOM 요소에서도 캐치할 수 있다.</strong></p>
<p>다음 이벤트들은 버블링을 통해 전파되지 않는다. 왜냐하면 event.bubbles 값이 false</p>
<ul>
<li>focus&#x2F;blur</li>
<li>load&#x2F;unload&#x2F;abort&#x2F;error</li>
<li>mouseenter&#x2F;mouseleave</li>
</ul>
<p>이러한 이벤트를 사용하여 캡처링으로 이벤트를 캐치하는 것보다 대안의 이벤트들을 사용하여 버블링을 통해 캐치하는 것이 더 합리적이다.</p>
<h1 id="이벤트-위임"><a href="#이벤트-위임" class="headerlink" title="이벤트 위임"></a>이벤트 위임</h1><p>이벤트 위임은 여러 개의 <strong>하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법</strong>을 말한다. 이벤트 위임을 통해 상위 DOM 요소에 이벤트 핸들러 등록하면 여러 개의 하위 DOM 요소에 이벤트 핸들러를 등록할 필요가 없다. 또한 동적으로 하위 DOM 요소 추가하더라도 일일이 추가된 DOM 요소에 이벤트 핸들러를 등록할 필요가 없다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-id">#fruits</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">display</span>: flex;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">list-style-type</span>: none;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">padding</span>: <span class="number">0</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-id">#fruits</span> <span class="selector-tag">li</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">cursor</span>: pointer;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    <span class="selector-id">#fruits</span> <span class="selector-class">.active</span> &#123;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">color</span>: red;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">      <span class="attribute">text-decoration</span>: underline;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-css"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;apple&quot;</span> <span class="attr">class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;banana&quot;</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;orange&quot;</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>선택된 내비게이션 아이템: <span class="tag">&lt;<span class="name">em</span> <span class="attr">class</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>apple<span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $fruits = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fruits&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $msg = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.msg&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 사용자 클릭에 의해 선택된 내비게이션 아이템(li 요소)에 active 클래스를 추가하고</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 그 외의 모든 내비게이션 아이템의 active 클래스를 제거한다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">&#123; target &#125;</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 이벤트를 발생시킨 요소(target)가 ul#fruits의 자식 요소가 아니라면 무시한다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">if</span> (!target.<span class="title function_">matches</span>(<span class="string">&#x27;#fruits &gt; li&#x27;</span>)) <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      [...$fruits.<span class="property">children</span>].<span class="title function_">forEach</span>($fruit =&gt; &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $fruit.<span class="property">classList</span>.<span class="title function_">toggle</span>(<span class="string">&#x27;active&#x27;</span>, $fruit === target);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        $msg.<span class="property">textContent</span> = target.<span class="property">id</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 이벤트 위임: 상위 요소(ul#fruits)는 하위 요소의 이벤트를 캐치할 수 있다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    $fruits.<span class="property">onclick</span> = activate;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>이벤트 객체의 currentTarget 프로퍼티는 언제나 $fruits 요소를 가리키지만 이벤트 객체의 target 프로퍼티는 실제로 이벤트를 발생시킨 DOM 요소를 가리킨다.</li>
</ul>
<p>만약 $fruits 요소의 하위 요소에서 클릭 이벤트가 발생했다면 이벤트 객체의 currentTarget 프로퍼티와 target 프로퍼티는 다른 DOM 요소를 가리킨다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/Event/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/DOM%EA%B3%BC-NODE-attribute-vs-property/"
                            aria-label=": DOM과 NODE(attribute vs property)"
                        >
                            DOM과 NODE(attribute vs property)
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:38:24+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>렌더링 엔진에 의해 HTML 문서를 브라우저가 이해할 수 있는 자료구조인 DOM을 생성한다. <strong>DOM이란, HTML문서의 계층적인 구조와 정보를 표현하며 이를 제어할 수 있는 API, 즉 프로퍼티와 메서드를 제공하는 트리 자료구조이다.</strong></p>
<h1 id="노드"><a href="#노드" class="headerlink" title="노드"></a>노드</h1><p>HTML 요소는 렌더링 엔진에 의해 DOM을 구성하는 요소 노드 객체로 변환된다. HTML 요소의 어트리뷰트는 어트리뷰트 노드로, HTML 요소의 텍스트 컨텐츠는 텍스트 노드로 변환된다.</p>
<p>노드 객체들로 구성된 트리 자료구조를 DOM이라한다.</p>
<blockquote>
<p>노드도 자바스크립트 객체이므로 프로토타입에 의한 상속 구조를 갖는다.</p>
</blockquote>
<h2 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h2><p>상속관계를 아는 것보다 어떤 DOM API를 사용하여 동적으로 변경하고 조작할 수 있는지를 알아야한다.</p>
<p><code>querySelector, querySelectorAll</code> 메서드가 다소 느리긴 하더라도 CSS 선택자로 요소 노드 취득시 구체적인 조건과 일관된 방식으로 요소 노드 취득할 수 있으므로 id 어트리뷰트가 있는 요소는 <code>getElementById</code> 메서드를 사용하고 그 외의 경우에는 <code>querySelector, querySelectorAll</code> 메서드를 사용하자.</p>
<h2 id="HTMLCollection과-NodeList"><a href="#HTMLCollection과-NodeList" class="headerlink" title="HTMLCollection과 NodeList"></a>HTMLCollection과 NodeList</h2><p>DOM 컬렉션 객체이 두 객체는 DOM API가 여러 개의 결과값을 반환하기 위한 객체이다. 둘 다 <strong>유사 배열 객체</strong>이면서 <strong>이터러블</strong>이다. 그러므로 for…of문으로 순회할 수 있으며 스프레드 문법을 사용하여 간단히 배열로 변환할 수 있다.</p>
<ul>
<li>HTMLCollection과 NodeList는 <strong>노드 객체의 상태 변화를 실시간으로 반영하는 살아있는 객체</strong>이다.</li>
<li>HTMLCollection은 언제나 live 객체로 동작한다.</li>
<li>NodeList는 <strong>대부분의 경우 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지</strong>하는 non-live 객체로 동작하지만 <strong>경우에 따라 live 객체로 동작</strong>한다.</li>
</ul>
<h3 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h3><p>HTMLCollection, NodeList 객체를 사용하지 말아라. 유사 배열 객체이면서 이터러블인 <strong>NodeList,</strong> <strong>HTMLCollection 객체를 배열로 변환하면 부작용을 제거할 수 있다.</strong> 유용한 배열 고차함수 forEach, map, filter 등을 사용할 수 있다.</p>
<h1 id="DOM-조작"><a href="#DOM-조작" class="headerlink" title="DOM 조작"></a>DOM 조작</h1><p>DOM 조작은 새로운 노드를 생성하여 DOM에 추가하거나 기존 노드 삭제 또는 교체 하는 것을 말한다. <strong>이 경우 리플로우와 리페인트가 발생한다.</strong></p>
<h2 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h2><p>시작 태그와 종료 태그 사이의 모든 마크업을 문자열로 반환한다. HTML 마크업도 포함된 문자열을 반환하는 것이 textContent 프로퍼티와 차이점이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// #foo 요소의 콘텐츠 영역 내의 HTML 마크업을 문자열로 취득한다.</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;foo&#x27;</span>).<span class="property">innerHTML</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// &quot;Hello &lt;span&gt;world!&lt;/span&gt;&quot;</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>요소 노드의 innerHTML 프로퍼티에 문자열 할당하면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이 때 <strong>HTML 마크업이 포함되어 있으면 파싱되어 요소 노드의 자식 노드로 DOM에 반영된다.</strong></li>
</ul>
<aside>
💡 단, innerHTML 프로퍼티에 사용자로부터 입력받은 데이터를 그대로 할당하는 것은 크**로스 사이트 스크립팅 공격에 취약하므로 위험**하다.

</aside>

<h2 id="복수의-노드-생성과-추가-⭐️"><a href="#복수의-노드-생성과-추가-⭐️" class="headerlink" title="복수의 노드 생성과 추가 ⭐️"></a>복수의 노드 생성과 추가 ⭐️</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $fruits = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fruits&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Banana&#x27;</span>, <span class="string">&#x27;Orange&#x27;</span>].<span class="title function_">forEach</span>(<span class="function"><span class="params">text</span> =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 1. 요소 노드 생성</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> $li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;li&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 2. 텍스트 노드 생성</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="keyword">const</span> textNode = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(text);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 3. 텍스트 노드를 $li 요소 노드의 자식 노드로 추가</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $li.<span class="title function_">appendChild</span>(textNode);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      <span class="comment">// 4. $li 요소 노드를 #fruits 요소 노드의 마지막 자식 노드로 추가</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">      $fruits.<span class="title function_">appendChild</span>($li);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>위 예제는 3개의 요소 노드가 생성하여 DOM에 3번 추가하여 DOM이 3번 변경된다. 이러한 방법은 <strong>리플로우를 많이 발생 시키므로 피해야한다.</strong></li>
</ul>
<p>⇒ 컨테이너 요소를 미리 생성한 후 DOM에 추가할 3개 요소 노드를 컨테이너 요소의 자식 노드로 추가한 뒤 컨테이너 요소를 #fruits 요소에 자식으로 추가한다. 하지만 이 또한, 불필요한 컨테이너 요소(div)가 DOM에 추가되어 바람직 하지 않다.</p>
<h1 id="어트리뷰트"><a href="#어트리뷰트" class="headerlink" title="어트리뷰트"></a>어트리뷰트</h1><h2 id="어트리뷰트-노드와-attributes-프로퍼티"><a href="#어트리뷰트-노드와-attributes-프로퍼티" class="headerlink" title="어트리뷰트 노드와 attributes 프로퍼티"></a>어트리뷰트 노드와 attributes 프로퍼티</h2><p>HTML 문서의 요소는 여러 개의 어트리뷰트를 가질 수 있다. ex) class, checked, aria-label…</p>
<ul>
<li>모든 HTML 요소에 공통적인 것부터 해당 요소만 사용할 수 있는 어트리뷰트가 있다.</li>
<li>HTML 요소의 어트리뷰트는 어트리뷰트 노드로 변환되어 요소 노드와 연결된다. 이는 NamedNodeMap 객체에 담겨 요소 노드의 attributes 프로퍼티에 저장된다.</li>
<li><strong>attributes 프로퍼티는 getter만 존재하는 접근자 프로퍼티이다.</strong></li>
</ul>
<h2 id="HTML-어트리뷰트-vs-DOM-프로퍼티"><a href="#HTML-어트리뷰트-vs-DOM-프로퍼티" class="headerlink" title="HTML 어트리뷰트 vs DOM 프로퍼티"></a>HTML 어트리뷰트 vs DOM 프로퍼티</h2><ul>
<li>HTML 어트리뷰트는 <strong>초기값 (변하지 않는다.)</strong></li>
<li>DOM 프로퍼티는 HTML 프로퍼티를 초기값으로 가지고 <strong>변경될 수 있다.</strong></li>
</ul>
<p>첫렌더링 까지 어트리뷰트 노드의 어트리뷰트 값과 요소 노드의 value 프로퍼티에 할당된 값은 HTML 어트리뷰트 값과 동일하다. 하지만 첫 렌더링 이후 사용자가 input 요소에 무언가 입력시 바뀌게 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ungmo2&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> $input = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;user&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// attributes 프로퍼티에 저장된 value 어트리뷰트 값</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>($input.<span class="title function_">getAttribute</span>(<span class="string">&#x27;value&#x27;</span>)); <span class="comment">// ungmo2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="comment">// 요소 노드의 value 프로퍼티에 저장된 value 어트리뷰트 값</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>($input.<span class="property">value</span>); <span class="comment">// ungmo2</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>input 요소 노드는 상태를 가지고 있고 사용자의 입력에 의한 변경된 <strong>최신 상태를 관리해야 할뿐더러</strong> HTML 어트리뷰트로 지정한 <strong>초기 상태도 관리해야</strong>한다.</li>
</ul>
<p>즉, 요소 노드의 <strong>초기 상태는 어트리뷰트 노드가 관리</strong>하며 요소 노드의 <strong>최신 상태는 DOM 프로퍼티가 관리</strong>한다.</p>
<h3 id="HTML-어트리뷰트와-DOM-프로퍼티의-대응-관계"><a href="#HTML-어트리뷰트와-DOM-프로퍼티의-대응-관계" class="headerlink" title="HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계"></a>HTML 어트리뷰트와 DOM 프로퍼티의 대응 관계</h3><p>대부분은 HTML 어트리뷰트는 HTML 어트리뷰트 이름과 동일한 DOM 프로퍼티와 1:1로 대응한다. 반드시는 아니다.</p>
<ul>
<li>id 어트리뷰트와 id 프로퍼티는 1:1 대응, 동일한 값으로 연동한다.</li>
<li>input 요소의 value 어트리뷰트는 value 프로퍼티와 1:1 대응, <strong>value 어트리뷰트는 초기상태</strong>를, <strong>value 프로퍼티는 최신 상태</strong>를 갖는다.</li>
<li>class 어트리뷰트에 대응하는 DOM 프로퍼티는 className, classList 프로퍼티이다.</li>
</ul>
<h3 id="DOM-프로퍼티-값의-타입"><a href="#DOM-프로퍼티-값의-타입" class="headerlink" title="DOM 프로퍼티 값의 타입"></a>DOM 프로퍼티 값의 타입</h3><p>getAttribute 메서드로 취득한 어트리뷰트 값은 언제나 문자열이지만 DOM 프로퍼티로 취득한 최신 상태 값은 문자열이 아닐 수 있다. boolean 타입일 수 있다.</p>
<p>ex) checkbox요소의 checked 어트리뷰트 값은 문자열 이지만 checked 프로퍼티 값은 불리언이다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/DOM%EA%B3%BC-NODE-attribute-vs-property/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95/"
                            aria-label=": 브라우저 렌더링 과정"
                        >
                            브라우저 렌더링 과정
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:37:14+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="브라우저란"><a href="#브라우저란" class="headerlink" title="브라우저란?"></a>브라우저란?</h1><p>브라우저는 HTML, CSS, Javascript로 작성된 텍스트 문서를 서버에게 요청하여 응답을 받아 의미있는 단위인 토큰으로 파싱하여 시각적으로 렌더링 해주는 역할을 담당한다.</p>
<h1 id="브라우저-렌더링-과정"><a href="#브라우저-렌더링-과정" class="headerlink" title="브라우저 렌더링 과정"></a>브라우저 렌더링 과정</h1><h2 id="1-요청과-응답"><a href="#1-요청과-응답" class="headerlink" title="1. 요청과 응답"></a>1. 요청과 응답</h2><p>서버에 요청하기 위해 브라우저는 주소창을 제공한다. 주소창에 URL을 입력하면 URL의 호스트 이름이 DNS를 통해 IP주소로 변환되고 IP 주소를 갖는 서버에게 요청을 전송한다.</p>
<p>이렇게 요청을 보내면 서버는 서버의 루트 폴더에 존재하는 정적파일로 응답을 보낸다. 기본적으로 index.html</p>
<h2 id="2-HTML-파싱과-DOM-생성"><a href="#2-HTML-파싱과-DOM-생성" class="headerlink" title="2. HTML 파싱과 DOM 생성"></a>2. HTML 파싱과 DOM 생성</h2><p>브라우저 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다. 의미없는 문자열 데이터를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야한다.</p>
<p><strong>그래서 HTML 문서를 파싱하여 <span style="color:red">브라우저가 이해할 수 있는 자료구조인 DOM을 생성</span>한다.</strong></p>
<ol>
<li>서버는 요청의 응답하기 위해 요청한 HTML 파일을 읽어 메모리에 저장한 뒤 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.</li>
<li>브라우저는 이를 받아 meta 태그의 charset 방식에 따라(UTF-8) 문자열로 변환한다.</li>
<li>문자열로 변환된 HTML문서를 토큰화한다.</li>
<li>각 토큰을 객체로 변환하여 노드를 생성한다. 노드는 DOM을 구성하는 기본 요소이다. ex) 문서 노드, 요소 노드 등</li>
<li>HTML 문서는 중첩관계를 통해 부자관계가 형성된다. 이러한 부자관계를 반영하여 <strong>모든 노드들을 트리 자료구조로 구성한다. 이러한 노드들로 구성된 트리 자료구조를 DOM이라 부른다.</strong></li>
</ol>
<h2 id="3-CSS-파싱과-CSSOM-생성"><a href="#3-CSS-파싱과-CSSOM-생성" class="headerlink" title="3. CSS 파싱과 CSSOM 생성"></a>3. CSS 파싱과 CSSOM 생성</h2><p>렌더링 엔진은 HTML을 한줄씩 읽어나가며 순차적으로 파싱하여 DOM을 생성해 나간다. <strong>DOM을 생성하다가 CSS를 로드하는 link 태그나 style 태그를 만나면 <span style="color:red">DOM 생성을 일시중단</span>한다.</strong></p>
<p>그 결과 CSS 파일을 서버에 요청하여 응답받은 CSS 파일이나 style 태그 내의 CSS를 HTML과 동일한 과정으로 토큰화 생성 → CSSOM 생성 과정을 거친다. 이후 파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작한다.</p>
<h2 id="4-렌더-트리-생성"><a href="#4-렌더-트리-생성" class="headerlink" title="4. 렌더 트리 생성"></a>4. 렌더 트리 생성</h2><p>앞선 과정에서 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. 이 때 <strong>브라우저 화면에 렌더링되지 않는 노드<span style="color:red">(meta태그, script 태그 등)</span>와 CSS에 의해 표시되지 않는<span style="color:red">(display:none)</span> 노드들은 포함하지 않는다.</strong></p>
<p>지금까지의 렌더링 과정은 여러번 반복되서 실행될 수 있다. <strong>렌더링이 반복 실행되는 원인은 다음과 같다.</strong></p>
<ul>
<li>자바스크립트에 의한 노드 추가 또는 삭제</li>
<li>브라우저 창의 리사이징에 의한 viewport 크기 변경</li>
<li>HTML 요소의 레이아웃(위치와 크기)을 변경시키는 width, height, margin, padding, border, display, position 등의 스타일 변경</li>
</ul>
<p><strong>이러한 리렌더링은 비용이 많이 들고 성능에 악영향을 주므로 <span style="color:red">리렌더링이 적게 발생하도록 하여야한다.</span></strong></p>
<h2 id="5-자바스크립트-파싱과-실행"><a href="#5-자바스크립트-파싱과-실행" class="headerlink" title="5. 자바스크립트 파싱과 실행"></a>5. 자바스크립트 파싱과 실행</h2><p>HTML 파싱의 결과물 DOM은 HTML 문서의 구조와 정보뿐 아니라 HTML 요소와 스타일을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다.</p>
<p>즉, DOM API를 사용하여 이미 생성된 DOM을 동적으로 조작할 수 있다.</p>
<p>CSS 파싱과정과 마찬가지로 script 태그 만나면 DOM 생성을 일시 중단한다.</p>
<p>이후 자바스크립트 파일을 서버에 요청하여 응답받은 파일이나 script 태그내의 코드를 파싱하기 위해 <strong>자바스크립트 엔진에 제어권을 넘긴다. <span style="color:red">(렌더링 엔진 → 자바스크립트 엔진으로 제어권 이동)</span></strong></p>
<p>이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권 넘겨 HTML 파싱 중단된 시점부터 다시 DOM 생성을 재개한다.</p>
<p>자바스크립트 엔진은 자바스크립트 코드를 파싱하기 시작한다. 자바스크립트를 해석하여 <strong>AST(추상적 구문 트리)를 생성</strong>한다. 그리고 <strong>AST를 기반으로</strong> 인터프리터가 실행할 수 있는 중간 코드인 <strong>바이트 코드를 생성</strong>하여 실행한다.</p>
<h2 id="6-리플로우와-리페인트"><a href="#6-리플로우와-리페인트" class="headerlink" title="6. 리플로우와 리페인트"></a>6. 리플로우와 리페인트</h2><p>만약 자바스크립트 코드에 DOM, CSSOM을 변경하는 DOM API가 사용된 경우 DOM, CSSOM이 변경되고 변경된 DOM, CSSOM으로 다시 렌더트리로 결합되고 레이아웃과 페인트 과정을 거쳐 브라우저 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라고 한다.</p>
<h1 id="자바스크립트-파싱에-의한-HTML-파싱중단"><a href="#자바스크립트-파싱에-의한-HTML-파싱중단" class="headerlink" title="자바스크립트 파싱에 의한 HTML 파싱중단"></a>자바스크립트 파싱에 의한 HTML 파싱중단</h1><p>렌더링 엔진과 자바스크립트 엔진은 서로 제어권을 이동시키면서 병렬적으로 파싱하지 않고 <strong>직렬적으로 파싱을 수행한다.</strong> 브라우저는 이처럼 <strong>동기적</strong>으로, 즉 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행한다.</p>
<p>script 태그를 만나면 제어권이 이동하기 때문에 HTML 문서 내의 script 태그의 위치는 중요한 의미를 갖는다.</p>
<p>대표적인 문제로는 HTML이 생성되기 전에 자바스크립트 코드가 HTML요소를 동적으로 조작하려고 하면 <strong>정상적으로 동작하지 않을 수 있다.</strong> 이에 대한 해결책으로는 아래와 같다.</p>
<ul>
<li>body 태그 제일 하단에 script 태그(자바스크립트)를 위치 시키는 것</li>
</ul>
<h2 id="script-태그의-async-x2F-defer-어트리뷰트"><a href="#script-태그의-async-x2F-defer-어트리뷰트" class="headerlink" title="script 태그의 async&#x2F;defer 어트리뷰트"></a>script 태그의 async&#x2F;defer 어트리뷰트</h2><p>앞서 알아본 문제를 근본적으로 해결하기 위해서 HTML5부터 script 태그에 <strong>async</strong>와 <strong>defer 어트리뷰트</strong>가 추가되었다.</p>
<p>두 어트리뷰트는 src 어트리뷰트를 통해 외부의 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;extern.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;extern.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이 둘을 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 진행된다. 단 두 어트리뷰트의 실행 시점의 차이가 있다.</p>
<ol>
<li>async 어트리뷰트</li>
</ol>
<p>자바스크립트의 파싱과 실행은 <strong>자바스크립트 파일의 로드가 완료된 직후 진행</strong>된다. 이 때 HTML 파싱이 중단된다.</p>
<p>여러개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 <strong>로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다.</strong></p>
<p>즉, 순서보장이 필요한 script 태그는 async 어트리뷰트 지정하지 않아야 한다.</p>
<ol start="2">
<li>defer 어트리뷰트</li>
</ol>
<p>자바스크립트의 파싱과 실행은 <strong>HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후</strong>(DOMContentLoaded 이벤트가 발생한다) 진행된다.</p>
<blockquote>
<p>모듈은 기본적으로 defer이다. async는 잘 사용하지 않지만 폰트의 경우 용량도 크고 순서가 크게 상관이 없으니 최대한 빨리 가져오기 위해 async를 사용하기도 한다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EB%AA%A8%EB%93%88-%EB%8B%A4%EC%8B%9C%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0/"
                            aria-label=": 모듈 다시내보내기"
                        >
                            모듈 다시내보내기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:36:41+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="📌-모듈-다시-내보내기-기능"><a href="#📌-모듈-다시-내보내기-기능" class="headerlink" title="📌 모듈 다시 내보내기 기능"></a>📌 모듈 다시 내보내기 기능</h1><p>import한 모듈을 즉시 다시 내보내기 기능을 구현할 수 있다.</p>
<h2 id="사용하는-이유"><a href="#사용하는-이유" class="headerlink" title="사용하는 이유"></a>사용하는 이유</h2><p>진입점인 index.js 파일이 있다고 가정하자. 이 진입점을 내보내서 다른 개발자들이 안의 모듈들을 사용하려고 할 때, 다른 개발자가 모듈의 내부 구조를 건드리게 하면 안된다.</p>
<p>그러기 위해서 공개할 모듈만 index.js 파일에 넣어 내보내기를 하고 나머지는 숨기는 것이 현명하다.</p>
<p>때문에 내보낼 기능들을 분산하여 구현한 뒤 index.js에서 해당 기능들을 가져와서 다시 내보내기 하면 원하는 목적을 이룰 수 있다.</p>
<h2 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// currency, currencyKR 모듈을 다시 내보냅니다.</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./currency/currency.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetchBooks 모듈을 다시 내보냅니다.</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./fetchBooks.js&quot;</span>;</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">import</span>, <span class="keyword">export</span> 할 때 <span class="keyword">as</span> 라는 문법을 사용할 수 있다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">as</span>를 사용하면 이름을 바꿔서 모듈을 가져올 수 있다.</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; currencyKR <span class="keyword">as</span> currency &#125; <span class="keyword">from</span> <span class="string">&quot;../../utils/index.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>currencyKR 기능을 currency 라는 이름으로 바꿔서 import 해주었다.</p>
<h1 id="🏓-소감"><a href="#🏓-소감" class="headerlink" title="🏓 소감"></a>🏓 소감</h1><p>module에 대해서는 쓸 때마다 헷갈렸었는데, 이렇게 모르는 것이 생길 때마다 공부하여 정리하다보면 익숙해지면서 알게 될 것 같다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EB%AA%A8%EB%93%88-%EB%8B%A4%EC%8B%9C%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EA%B3%BC-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0/"
                            aria-label=": 이터러블과 이터레이터"
                        >
                            이터러블과 이터레이터
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:36:03+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="이터레이션-프로토콜"><a href="#이터레이션-프로토콜" class="headerlink" title="이터레이션 프로토콜"></a>이터레이션 프로토콜</h1><p>ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위한 규약이다.</p>
<p>즉, ES6 이후부터는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜 규약을 준수하는 이터러블로 통일하였다.</p>
<h2 id="이터러블-프로토콜"><a href="#이터러블-프로토콜" class="headerlink" title="이터러블 프로토콜"></a>이터러블 프로토콜</h2><p>Symbol.iterator를 프로퍼티 키로 메서드 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출 시 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.</p>
<p>위의 규약을 준수한 객체를 이터러블이라고 한다. 이터러블은 다음이 가능하다.</p>
<ul>
<li>for…of 문 순회</li>
<li>spread 문법</li>
<li>배열 디스트럭처링 할당의 대상</li>
</ul>
<blockquote>
<p>일반객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않으므로 이터러블이 아니다.</p>
</blockquote>
<h2 id="이터레이터-프로토콜"><a href="#이터레이터-프로토콜" class="headerlink" title="이터레이터 프로토콜"></a>이터레이터 프로토콜</h2><p>이터러블의 Symbol.iterator 메서드 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하고 next 메서드 호출 시 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이터레이터는 이터러블 요소를 탐색하기 위한 포인터 역할을 한다.</p>
<h1 id="이터레이션-프로토콜의-필요성"><a href="#이터레이션-프로토콜의-필요성" class="headerlink" title="이터레이션 프로토콜의 필요성"></a>이터레이션 프로토콜의 필요성</h1><p>이터러블은 for..of문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 볼 수 있다.</p>
<p>다양한 데이터 공급자(Array, String, Map 등)가 이터레이션 프로토콜이라는 하나의 규약만 준수하도록 규정하면 데이터 소비자(for..of, 스프레드 문법 등)는 이터레이션 프로토콜만 지원하도록 구현하면 된다.</p>
<p>즉, 이터레이션 프로토콜은 다양한 데이터 공급자가 <strong>하나의 순회방식을 갖도록 규정</strong>하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 <strong>데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할</strong>을 한다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>어떤 객체가 Symbol.iterator 메서드를 호출하여 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.</p>
<p>위와 같은 규약을 이터러블 프로토콜이라 하며 이터러블 프로토콜을 준수한 객체를 이터러블이라 한다.</p>
<p>next 메서드를 소유한 이터레이터가 next 메서드 호출하면 이터러블 순회하면서 이터레이터 리절트 객체 반환한다.</p>
<p>위와 같은 규약을 이터레이터 프로토콜이라 하며 이터레이터 프로토콜을 준수한 객체를 이터레이터라고한다.</p>
<ul>
<li>이터레이터 : next 메서드 소유하여 호출시 이터레이터 리절트 객체 반환</li>
<li>이터러블 : Symbol.iterator 메서드를 호출하여 이터레이터 반환</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EA%B3%BC-%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%ED%99%94%EC%82%B4%ED%91%9C%ED%95%A8%EC%88%98/"
                            aria-label=": 메서드와 화살표함수"
                        >
                            메서드와 화살표함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T11:35:17+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="ES6-이후-메서드"><a href="#ES6-이후-메서드" class="headerlink" title="ES6 이후 메서드"></a>ES6 이후 메서드</h1><p>ES6 이전의 함수는 사용 목적에 따라 일반함수로 호출이 가능했고 생성자 함수로 호출이 가능했다. <strong>즉, ES6 이전의 모든 함수는 callable이면서 constructor다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [ 2, 4, 6 ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>심지어 콜백함수도 constructor이기 때문에 불필요한 프로토타입 객체를 생성한다.</li>
</ul>
<p>이처럼 ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없어 호출방식에 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성한다. 이는 혼란스러워 실수를 유발하고 성능에도 좋지 않다.</p>
<ul>
<li>ES6 이후부터는 오류에 엄격하도록 만들고 있다. ⇒ 오류를 발생시킬 여지가 있는 것들은 그 부분을 개선해주고 있다.</li>
</ul>
<p><strong>ES6 사양에서 메서드는 <span style="color:red">메서드 축약표현으로 정의된 함수만을 의미</span>한다.</strong></p>
<p>⇒ <strong>인스턴스 생성할 수 없는 non-constructor이다.</strong></p>
<ul>
<li>인스턴스 생성 불가</li>
<li>prototype 프로퍼티 없다</li>
<li>프로토타입 생성 불가</li>
</ul>
<p><strong>ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.</strong></p>
<h1 id="함수-사용-목적에-따라-구분한-ES6에서의-함수"><a href="#함수-사용-목적에-따라-구분한-ES6에서의-함수" class="headerlink" title="함수 사용 목적에 따라 구분한 ES6에서의 함수"></a>함수 사용 목적에 따라 구분한 ES6에서의 함수</h1><p>이를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 3가지로 구분하였다.</p>
<table>
<thead>
<tr>
<th>ES6 함수의 구분</th>
<th>constructor</th>
<th>prototype</th>
<th>super</th>
<th>arguments</th>
</tr>
</thead>
<tbody><tr>
<td>일반함수</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>메서드</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>화살표 함수</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><p>function 키워드 함수보다 표현만 간단한 것이 아니라 내부 동작도 간략한다.</p>
<p>주로 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위해 사용한다.</p>
<h2 id="화살표-함수-정의"><a href="#화살표-함수-정의" class="headerlink" title="화살표 함수 정의"></a>화살표 함수 정의</h2><p>함수 선언문 안되고 함수 표현식으로만 정의 가능하다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x, y</span>) =&gt; x * y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x</span>) =&gt; x * y; <span class="comment">// 매개변수 1개면 소괄호 생략 가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params"></span>) =&gt; x * y; <span class="comment">// 매개변수 없으면 소괄호 생략 불가</span></span><br></pre></td></tr></table></figure>

<h2 id="화살표-함수-몸체-정의"><a href="#화살표-함수-몸체-정의" class="headerlink" title="화살표 함수 몸체 정의"></a>화살표 함수 몸체 정의</h2><p>함수 몸체 감싸는 {} 중괄호를 생략한 경우 표현식이 아닌 문일 경우 에러를 발생 시킨다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concise body</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">power</span> = x =&gt; x ** <span class="number">2</span>;</span><br><span class="line"><span class="title function_">power</span>(<span class="number">2</span>); <span class="comment">// -&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 동일하다.</span></span><br><span class="line"><span class="comment">// block body</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">power</span> = x =&gt; &#123; <span class="keyword">return</span> x ** <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="keyword">const</span> x = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 같이 해석된다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> <span class="keyword">const</span> x = <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>객체 리터럴을 반환하는 경우 소괄호로 감싸줘야한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">create</span> = (<span class="params">id, content</span>) =&gt; (&#123; id, content &#125;);</span><br><span class="line"><span class="title function_">create</span>(<span class="number">1</span>, <span class="string">&quot;JavaScript&quot;</span>); <span class="comment">// -&gt; &#123;id: 1, content: &quot;JavaScript&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 동일하다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">create</span> = (<span class="params">id, content</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; id, content &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="화살표-함수와-일반함수-차이"><a href="#화살표-함수와-일반함수-차이" class="headerlink" title="화살표 함수와 일반함수 차이"></a>화살표 함수와 일반함수 차이</h2><ol>
<li>화살표 함수는 non-constructor로, 인스턴스 생성할 수 없다.</li>
</ol>
<ul>
<li>인스턴스 생성 불가</li>
<li>prototype 프로퍼티 없다</li>
<li>프로토타입 생성 불가</li>
</ul>
<ol>
<li>화살표 함수는 중복된 매개변수 이름 선언시 에러 발생</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params">a, a</span>) =&gt; a + a;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>

<ol>
<li>화살표 함수는 this, arguments, super, <a target="_blank" rel="noopener" href="http://new.target/">new.target</a> 바인딩 갖지 않는다.</li>
</ol>
<p>따라서 화살표 함수 내부에서 위의 것들을 참조할 때 스코프 체인상 가장 가까운 <strong>상위 함수 중 화살표 함수가 아닌 함수의 this, arguements, super, new.target을 참조한다.</strong></p>
<h3 id="주의사항-메서드를-화살표-함수로-정의하지-않기"><a href="#주의사항-메서드를-화살표-함수로-정의하지-않기" class="headerlink" title="주의사항 : 메서드를 화살표 함수로 정의하지 않기"></a>주의사항 : 메서드를 화살표 함수로 정의하지 않기</h3><p>단, 메서드를 화살표 함수로 정의하면 안된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는</span></span><br><span class="line"><span class="comment">// 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는</span></span><br><span class="line"><span class="comment">// window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.</span></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<p>메서드 정의할 때는 메서드 축약 표현을 사용하는 것이 좋다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi Lee</span></span><br></pre></td></tr></table></figure>

<ul>
<li>메서드 내부에서 this는 메서드를 호출한 인스턴스에 바인딩된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"><span class="comment">// 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.</span></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>프로토타입 객체의 프로퍼티에 화살표 함수를 사용하는 것도 문제가 된다.</li>
<li>프로퍼티 동작 추가 시에는 <strong>ES6 메서드 정의 사용할 수 없으므로 일반함수로 정의해야한다.</strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EB%A9%94%EC%84%9C%EB%93%9C%EC%99%80-%ED%99%94%EC%82%B4%ED%91%9C%ED%95%A8%EC%88%98/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EC%83%81%EC%86%8D/"
                            aria-label=": 상속"
                        >
                            상속
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T10:53:32+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바스크립트에서 상속을 구현하기 위해 프로토타입을 기반으로 구현한다고 이전시간에 배워보았다.</p>
<p>그럼 상속을 구현하는 방법이 과연 이 방법뿐일까? 한번 알아보자.</p>
<h1 id="직접상속"><a href="#직접상속" class="headerlink" title="직접상속"></a>직접상속</h1><h2 id="Object-create에-의한-직접-상속-정적메서드"><a href="#Object-create에-의한-직접-상속-정적메서드" class="headerlink" title="Object.create에 의한 직접 상속 (정적메서드)"></a>Object.create에 의한 직접 상속 (정적메서드)</h2><p>Object.create 메서드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(생성할 객체의 프로토타입, 생성할 객체의 프로퍼티키와 프로퍼티 디스크립터 객체로 이뤄진 객체)</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">create</span>(prototype[, propertiesObject])</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입이 null인 객체를 생성한다. 생성된 객체는 프로토타입 체인의 종점에 위치한다.</span></span><br><span class="line"><span class="comment">// obj → null</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// Object.prototype을 상속받지 못한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()); <span class="comment">// TypeError: obj.toString is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj → Object.prototype → null</span></span><br><span class="line"><span class="comment">// obj = &#123; x: 1 &#125;;와 동일하다.</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">1</span>, <span class="attr">writable</span>: <span class="literal">true</span>, <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">configurable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 위 코드는 다음과 동일하다.</span></span><br><span class="line"><span class="comment">// obj = Object.create(Object.prototype);</span></span><br><span class="line"><span class="comment">// obj.x = 1;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 빈객체만 생성하는 것이 아니다.</span></span><br><span class="line"><span class="keyword">const</span> obj1 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj, &#123;</span><br><span class="line">  <span class="attr">x</span>: &#123; <span class="attr">value</span>: <span class="number">10</span> &#125;,</span><br><span class="line">  <span class="attr">y</span>: &#123; <span class="attr">value</span>: <span class="number">20</span>, <span class="attr">writable</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123;x: 10, y: 20&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="comment">// 객체리터럴로 생성된 객체를 직접 상속받는다.</span></span><br><span class="line"><span class="comment">// obj → myProto → Object.prototype → null</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(myProto);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">x</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === myProto); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj → Person.prototype → Object.prototype → null</span></span><br><span class="line"><span class="comment">// obj = new Person(&#x27;Lee&#x27;)와 동일하다.</span></span><br><span class="line">obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;Lee&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span>); <span class="comment">// Lee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Object.create 메서드의 첫번째 인수로 전달한 객체를 프로토타입으로 하는 프로토타입 체인에 속하는 객체를 생성한다. 즉, 객체를 생성하면서 직접적인 상속을 구현하는 것이다.</p>
<ul>
<li>new 연산자 없이 객체 생성 가능</li>
<li>프로토타입을 지정하면서 객체 생성 가능</li>
<li>객체 리터럴로 생성된 객체도 상속받을 수 있다.</li>
</ul>
<p>Object.prototype의 빌트인 메서드를 직접 호출하는 것은 위험하다. 그 이유는 Object.create 메서드를 사용하여 <span style="color:red">프로토타입 체인 종점에 위치하는 객체</span>를 생성할 수도 있기 때문이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입이 null인 객체, 즉 프로토타입 체인의 종점에 위치하는 객체를 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">obj.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj) === <span class="literal">null</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// obj는 Object.prototype의 빌트인 메서드를 사용할 수 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;a&quot;</span>)); <span class="comment">// TypeError: obj.hasOwnProperty is not a function</span></span><br></pre></td></tr></table></figure>

<p>그러므로 Object.prototype의 빌트인 메서드는 call,apply 등을 통해 간접적으로 호출하는 것을 권장한다.</p>
<p>하지만 위 방법은 너무 길다…</p>
<p><span style="font-size:1.2rem">그래서 새로나온 문법을 사용하자</span></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">hasOwn</span>(obj, property);</span><br></pre></td></tr></table></figure>

<p>위 방법을 사용하여 같은 기능을 구현할 수 있다.</p>
<h1 id="정적-프로퍼티-x2F-메소드"><a href="#정적-프로퍼티-x2F-메소드" class="headerlink" title="정적 프로퍼티&#x2F;메소드"></a>정적 프로퍼티&#x2F;메소드</h1><p>생성자 함수로 <span style="color:red">인스턴스를 생성하지 않아도</span> 참조,호출할 수 있는 프로퍼티, 메소드를 말한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 프로퍼티</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">staticProp</span> = <span class="string">&quot;static prop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">staticMethod</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;staticMethod&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수에 추가한 정적 프로퍼티/메서드는 생성자 함수로 참조/호출한다.</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">staticMethod</span>(); <span class="comment">// staticMethod</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 정적 프로퍼티/메서드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</span></span><br><span class="line"><span class="comment">// 인스턴스로 참조/호출할 수 있는 프로퍼티/메서드는 프로토타입 체인 상에 존재해야 한다.</span></span><br><span class="line">me.<span class="title function_">staticMethod</span>(); <span class="comment">// TypeError: me.staticMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수로 생성한 인스턴스로 정적 프로퍼티와 메소드를 참조, 호출할 수 없다.</p>
<p>생성자 함수가 생성한 인스턴스는 프로퍼티, 메소드를 참조할 때 <span style="color:red">프로토타입 체인 내에서만 할 수 있다.</span></p>
<p>정적 프로퍼티,메소드는 인스턴스의 프로토타입 체인 내에 없기 때문에 참조, 호출할 수 없다.</p>
<aside>
💡 MDN에 보면 정적메서드와 프로토타입 메서드를 구분하여 소개한다. 정적 메서드는 Object.isExtensible(), Object.keys() 처럼 중간에 prototype이 들어가지 않지만 프로토타입 메서드는 Object.prototype.hasOwnProperty() 처럼 중간에 prototype이 들어간다.
</aside>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EC%83%81%EC%86%8D/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"
                            aria-label=": 객체지향 프로그래밍과 프로토타입"
                        >
                            객체지향 프로그래밍과 프로토타입
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T10:52:35+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <p>자바스크립트는 public,private,protected 등의 키워드가 없어서 객체지향 프로그래밍이 아니라는 오해를 받지만 자바스크립트는 클래스 기반 객체지향 프로그래밍 언어보다 효율적이며 더 강력한 <span style="color:red">프로토타입 기반의 객체지향 프로그래밍 언어</span>이다.</p>
<h1 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h1><p>객체지향 프로그래밍이란, 특성을 나타내는 속성들의 집합을 통해 실체를 나타내어 구별하거나 인식하는 개념을 프로그래밍에 접목시킨 프로그래밍 패러다임이다. 여기서 프로그램에 필요한 속성만을 간추려 추상화 한것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">고양이 = &#123;</span><br><span class="line">  동물</span><br><span class="line">  귀여움</span><br><span class="line">  털이있음</span><br><span class="line">  다리가 <span class="number">4</span>개임...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">	<span class="attr">address</span>:<span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="프로토타입과-상속"><a href="#프로토타입과-상속" class="headerlink" title="프로토타입과 상속"></a>프로토타입과 상속</h1><p>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 불필요한 메서드 중복 소유</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>); <span class="comment">// 얘도 getArea 가지고</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>); <span class="comment">// 쟤도 getArea 가지네?</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>위 예시는 Circle 생성자 함수가 인스턴스를 생성할 때마다 동일한 동작을 하는 getArea 메서드를 중복 생성하는데, 이 경우 모든 인스턴스가 메서드를 중복 소유하여 메모리 낭비를 야기시킬 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 프로토타입 상속을 기반으로 불필요한 중복 제거</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수가 생성한 모든 인스턴스가 getArea 메서드를 공유하여 사용할 수 있도록 프로토타입에 추가</span></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getArea</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="property">PI</span> * <span class="variable language_">this</span>.<span class="property">radius</span> ** <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="property">getArea</span> === circle2.<span class="property">getArea</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><p>프로토타입 객체(줄여서 프로토타입)은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체로서 다른 객체의 공유 프로퍼티(메서드 포함)를 제공한다.</p>
<ul>
<li>객체간 상속을 구현하기 위해 사용</li>
<li>프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자유롭게 사용</li>
</ul>
<p>앞으로 나올 개념은 그림이 없으면 이해하기 어렵다. 이 블로그는 나의 생각을 정리해 둔 것이므로 이해를 돕기 위해서 모던 자바스크립트 Deep Dive 책을 참고하도록하자. 혹은 Poiema Web 사이트를 참고하자.</p>
<blockquote>
<p>객체 생성 방식에 따라 객체가 생성될 때, 프로토타입이 결정되고 [[Prototype]] 내부 슬롯의 값으로 저장된다.</p>
</blockquote>
<h3 id="함수객체의-prototype-프로퍼티"><a href="#함수객체의-prototype-프로퍼티" class="headerlink" title="함수객체의 prototype 프로퍼티"></a>함수객체의 prototype 프로퍼티</h3><p>함수 객체만이 갖는 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</p>
<p>함수 정의 방식에 따라 일반함수 정의할 경우 constructor이고 ES6에서 정한 메서드 축약표현, 화살표 함수로 함수 정의할 경우 non-constructor이다.</p>
<p>non-constructor인 화살표 함수, 메서드 축약표현으로 정의한 메서드는 prototype 프로퍼티를 소유하지 않는다. ⇒ <span style="color:red">프로토타입도 생성하지 않는다.</span></p>
<blockquote>
<p>프로토타입 객체(프로토타입), 생성자 함수의 prototype 프로퍼티, 프로토타입의 constructor 프로퍼티, 생성자 함수가 생성한 객체(인스턴스)의 <strong>proto</strong> 등 헷갈리는 용어들이 많이 나오니 혼동하지 않도록 한다.</p>
</blockquote>
<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3><p>모든 프로토타입은 constructor 프로퍼티를 갖는다. constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다.</p>
<p>프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍으로 존재하며 <span style="color:red">생성자 함수가 생성되는 시점과 더불어 프로토타입도 생성</span>된다.</p>
<hr>
<h2 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h2><p><span style="color:red">생성자 함수가 생성되는 시점과 더불어 프로토타입도 생성</span>된다.</p>
<p>사용자 정의 생성자 함수는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 만약 함수 표현식이라면 에러(변수호이스팅)</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>함수 선언문은 함수 호이스팅이 일어나 런타임 이전에 자바스크립트 엔진에 의해 실행된다.</p>
</li>
<li><p>이 때 함수 객체가 생성되고 더불어 생성된 프로토타입은 Person 생성자 함수의 prototype의 프로퍼티에 바인딩된다.</p>
</li>
</ol>
<p>이 때 생성된 프로토타입은 오직 constructor 프로퍼티만 갖는 객체이다.</p>
<blockquote>
<p>생성된 프로토타입의 프로토타입은 항상 Object.prototype이다.</p>
</blockquote>
<p>반면, 빌트인 생성자 함수의 경우 전역 객체가 생성되는 시점에 생성된다.</p>
<p>즉, 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화 되어 존재한다. 이 후 객체를 생성하면 프로토타입은 생성된 객체의 [[Prototype]] 내부 슬롯에 할당된다. 그 결과 생성된 객체는 프로토타입의 상속을 받는다.</p>
<hr>
<h2 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h2><p>객체는 다양한 방식으로 생성되어 세부적인 객체 생성 방식의 차이는 있지만 모두 추상연산 OrdinaryObjectCreate에 의해 생성된다는 공통점이 있다.</p>
<p>추상연산 OrdinaryObjectCreate는 필수적으로 자신이 생성할 객체의 프로토타입을 인수로 전달받는다.</p>
<p>즉, 프로토타입은 추상연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.</p>
<ol>
<li>객체 리터럴로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Object 생성자 함수로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>사용자 정의 생성자 함수로 생성된 객체의 프로토타입</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">생성자함수.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure>

<p>생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 이 프로토타입은 constructor 프로퍼티만 가지고 있다.</p>
<hr>
<h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><p>자바스크립트는 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 [[Prototype]] 내부슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입 메서드</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHello</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Kim&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(me.<span class="title function_">hasOwnProperty</span>(<span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>Person 생성자 함수에 의해 생성된 me 인스턴스는 Object.prototype의 메서드인 hasOwnProperty 메서드를 호출할 수 있다. 이것은 Person.prototype뿐만 아니라 Object.prototype도 상속 받았다는 것을 알 수 있다.</p>
<p>단, <span style="color:red">me 객체의 프로토타입은 Person.prototype</span>이다.</p>
<p>그리고 Person.prototype의 프로토타입은 Object.prototype이다.</p>
<blockquote>
<p>프로토타입 최상위에 있는 객체는 언제나 Object.prototype(프로토타입 체인의 종점)이다. 그러므로 Object.prototype의 [[Prototype]] 내부 슬롯은 null 이다.</p>
</blockquote>
<h3 id="식별자와-프로퍼티-차이"><a href="#식별자와-프로퍼티-차이" class="headerlink" title="식별자와 프로퍼티 차이"></a>식별자와 프로퍼티 차이</h3><p>식별자는 함수의 중첩관계로 이루어진 스코프의 계층적 구조로 이뤄진 스코프 체인에서 검색하여 찾는다.</p>
<p>반면에 객체의 프로퍼티는 해당 객체의 프로퍼티가 없다면 프로토타입 체인을 따라 [[Prototype]] 내부 슬롯에 바인딩된 프로토타입으로 이동하면서 프로퍼티를 검색한다.</p>
<p>스코프 체인과 프로토타입 체인은 별도로 동작하지 않고 서로 협력하여 식별자와 프로퍼티를 검색하는데 사용된다.</p>
<h1 id="소감"><a href="#소감" class="headerlink" title="소감"></a>소감</h1><p>프로토타입에 대해 설명하기가 무척 어렵고 난해했는데 그림을 보며 공부하니 이해가 수월하였다. TIL을 정리하면서 저작권때문에 그림을 첨부할 순 없었지만 머릿속으로 다시 그려보면서 정리하니 기억에 오래 남을 것 같다.</p>
<p>이제 러버덕을 하면서 말로 설명해보는 시간을 가져야겠다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/"
                            aria-label=": 프로퍼티와 프로퍼티 어트리뷰트"
                        >
                            프로퍼티와 프로퍼티 어트리뷰트
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T10:51:49+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="프로퍼티-어트리뷰트"><a href="#프로퍼티-어트리뷰트" class="headerlink" title="프로퍼티 어트리뷰트"></a>프로퍼티 어트리뷰트</h1><p>오늘은 프로퍼티 어트리뷰트에 대해서 알아보자. 한국말로 번역하면 속성 속성이다. 하지만 자바스크립트에서 속성은 두가지로 구분하여 사용하여야 한다. 이번 시간에는 속성 중 하나인 프로퍼티에 대해 알아보자</p>
<h1 id="내부슬롯-internal-slot"><a href="#내부슬롯-internal-slot" class="headerlink" title="내부슬롯 internal slot"></a>내부슬롯 internal slot</h1><p>내부슬롯과 내부메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 프로퍼티와 메서드이다.</p>
<p>내부슬롯은 개발자가 직접 접근할 수는 없다.</p>
<p>하지만, [[Prototype]] 내부슬롯은 <strong>proto</strong>를 통해 간접적으로 접근할 수 있다.</p>
<h1 id="프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1><p>자바스크립트 엔진은 프로퍼티 생성 시 <span style="color:red;">프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트</span>를 기본값으로 자동 정의한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">name</span>: <span class="string">&quot;kim&quot;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptors</span>(a).<span class="property">age</span>.<span class="property">value</span> = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;name: &#x27;kim&#x27;, age: 28&#125;</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 어트리뷰트란 <span style="color:red">내부슬롯</span>이다. 따라서 직접 접근할 순 없지만, Object.getOwnPropertyDescriptor 메서드로 간접적으로 접근할 수 있다.</p>
<p>다만 간접적으로 접근만 가능한 것이므로 위 메서드로 값을 변경하거나 할 수는 없다.</p>
<p>⇒ 프로퍼티 생성될 때 [[value]]는 프로퍼티 값으로 초기화 되고 나머지는 true로 초기화된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name : <span class="string">&#x27;Lee&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&#x27;name&#x27;</span>); <span class="comment">// &#123;value: &#x27;Lee&#x27;, writable:true,... configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>프로퍼티 디스크립터 객체를 반환한다. 존재하지 않거나 상속받은 프로퍼티라면 undefined 반환</li>
</ul>
<h2 id="데이터-프로퍼티와-접근자-프로퍼티"><a href="#데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="데이터 프로퍼티와 접근자 프로퍼티"></a>데이터 프로퍼티와 접근자 프로퍼티</h2><h3 id="1-데이터-프로퍼티"><a href="#1-데이터-프로퍼티" class="headerlink" title="1. 데이터 프로퍼티"></a>1. 데이터 프로퍼티</h3><p>키와 값으로 구성된 일반적인 프로퍼티</p>
<ul>
<li>프로퍼티의 값 [[value]]</li>
<li>값의 갱신 가능여부 [[writable]] : false이면 프로퍼티의 [[value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티</li>
<li>열거 가능여부 [[enumerable]] : for…in 혹은 Object.keys 메서드로 열거 가능 여부</li>
<li>재정의 가능여부 [[configurable]] : false이면 해당 프로퍼티 삭제, 프로퍼티 어트리뷰트 값의 변경 금지</li>
</ul>
<h3 id="2-접근자-프로퍼티"><a href="#2-접근자-프로퍼티" class="headerlink" title="2. 접근자 프로퍼티"></a>2. 접근자 프로퍼티</h3><p>자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티</p>
<ul>
<li>[[get]] : 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[get]]의 값 즉, getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</li>
<li>[[set]] : 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[set]]의 값 즉, setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</li>
<li>[[enumerate]]</li>
<li>[[configurable]]</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="comment">// 데이터 프로퍼티</span></span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&quot;Donald&quot;</span>,</span><br><span class="line">  <span class="attr">lastName</span>: <span class="string">&quot;Duck&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">fullName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">fullName</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">firstName</span> + <span class="string">&quot; &quot;</span> + person.<span class="property">lastName</span>); <span class="comment">// Donald Duck</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName값을 저장하면 setter 함수가 호출</span></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&quot;Daisy Duck&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &quot;Daisy&quot;, lastName: &quot;Duck&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">fullName</span>); <span class="comment">// Daisy Duck</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// firstName은 데이터 프로퍼티</span></span><br><span class="line"><span class="keyword">let</span> descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&quot;firstName&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor);</span><br><span class="line"><span class="comment">// &#123;value:&quot;Daisy&quot;, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName은 접근자 프로퍼티</span></span><br><span class="line">descriptor = <span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(person, <span class="string">&quot;fullName&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(descriptor); <span class="comment">// &#123;get: f, set: f, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="접근자-프로퍼티와-데이터-프로퍼티-구분-방법"><a href="#접근자-프로퍼티와-데이터-프로퍼티-구분-방법" class="headerlink" title="접근자 프로퍼티와 데이터 프로퍼티 구분 방법"></a>접근자 프로퍼티와 데이터 프로퍼티 구분 방법</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 일반 객체의 __proto__는 접근자 프로퍼티</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;__proto__&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;get: f, set: f, enumerable: true, configurable: true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 객체의 prototype은 데이터 프로퍼티</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;, <span class="string">&quot;prototype&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;value: &#123;...&#125;, writable: true, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>

<p>위 예시는 접근자 프로퍼티의 경우 다음과 같은 프로퍼티 어트리뷰트가 나오고 데이터 프로퍼티의 경우 출력되는 프로퍼티 어트리뷰트가 다른 것을 확인할 수 있다.</p>
<h1 id="프로퍼티-정의"><a href="#프로퍼티-정의" class="headerlink" title="프로퍼티 정의"></a>프로퍼티 정의</h1><p>프로퍼티를 정의한다. 라는 것은 새로운 프로퍼티 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 기존 프로퍼티 어트리뷰트를 재정의하는 것을 말한다.</p>
<h2 id="데이터-프로퍼티-정의"><a href="#데이터-프로퍼티-정의" class="headerlink" title="데이터 프로퍼티 정의"></a>데이터 프로퍼티 정의</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;firstName&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;yiju&quot;</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;lastName&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>Object.defineProperty 메서드로 프로퍼티 어트리뷰트 정의할 수 있다. 인수로는 객체의 참조, 데이터 프로퍼티의 키(문자열), 프로퍼티 디스크립터 객체를 전달한다.</li>
<li>디스크립터 객체 누락시키면 false가 기본값</li>
</ul>
<h3 id="궁금증"><a href="#궁금증" class="headerlink" title="궁금증"></a>궁금증</h3><p>왜 프로퍼티 동적으로 생성해줄 때, 프로퍼티 어트리뷰트 생략하는데 프로퍼티 어트리뷰트값이 true인데, define 메서드를 사용할 때 생략하면 기본값 false?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;Kim&#x27;</span>;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj,<span class="string">&#x27;age&#x27;</span>,&#123;</span><br><span class="line">	<span class="attr">value</span>:<span class="number">19</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">왜 다른가?</span><br></pre></td></tr></table></figure>

<p>동적으로 생성시에 편의를 위해서 true로 설정된다. 그렇지 않은 경우 Object.defineProperty() 메서드를 사용할 때, 생략하는 어트리뷰트는 false로 설정된다.</p>
<h3 id="writable-false"><a href="#writable-false" class="headerlink" title="writable : false"></a>writable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[writable]] 값이 false 인 경우 해당 프로퍼티의 [[value]]의 값 변경할 수 없다.</span></span><br><span class="line"><span class="comment">// 에러 발생하지 않고 무시</span></span><br><span class="line">person.<span class="property">lastName</span> = <span class="string">&quot;soondae&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="enumerable-false"><a href="#enumerable-false" class="headerlink" title="enumerable : false"></a>enumerable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[enumerable]] 값이 false 인 경우 해당 프로퍼티는 for...in 문이나 Object.keys 등으로 열거할 수 없다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(person)); <span class="comment">// [&#x27;firstName&#x27;]</span></span><br></pre></td></tr></table></figure>

<h3 id="configurable-false"><a href="#configurable-false" class="headerlink" title="configurable : false"></a>configurable : false</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[configurable]] 값이 false 인 경우 해당 프로퍼티를 삭제할 수 없다.</span></span><br><span class="line"><span class="comment">// 삭제해도 에러없이 무시된다.</span></span><br><span class="line"><span class="keyword">delete</span> person.<span class="property">lastName</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 또한, 해당 프로퍼티를 재정의 할 수도 없다.</span></span><br><span class="line"><span class="comment">// Object.defineProperty(person, &#x27;lastName&#x27;, &#123; enumerable : true &#125;);</span></span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot redefine property: firstName</span></span><br></pre></td></tr></table></figure>

<h2 id="접근자-프로퍼티-정의"><a href="#접근자-프로퍼티-정의" class="headerlink" title="접근자 프로퍼티 정의"></a>접근자 프로퍼티 정의</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;fullName&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// getter 함수</span></span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="variable language_">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter 함수</span></span><br><span class="line">  <span class="title function_">set</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    [<span class="variable language_">this</span>.<span class="property">firstName</span>, <span class="variable language_">this</span>.<span class="property">lastName</span>] = name.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.<span class="property">fullName</span> = <span class="string">&quot;yoonju hong&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person); <span class="comment">// &#123;firstName: &#x27;yoonju&#x27;, lastName: &#x27;Kim&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lastName은 writable이 false여서 값이 안바뀌는 것을 볼 수 있다.</li>
</ul>
<h1 id="객체-변경-방지"><a href="#객체-변경-방지" class="headerlink" title="객체 변경 방지"></a>객체 변경 방지</h1><p>객체 변경을 방지하는 메서드를 제공한다. 종류에 따라 금지하는 강도가 다르다.</p>
<p>직속 프로퍼티만 방지(얕은 방지)</p>
<table>
<thead>
<tr>
<th>구분</th>
<th>메서드</th>
<th>프로퍼티 추가</th>
<th>삭제</th>
<th>값 읽기</th>
<th>값 쓰기</th>
<th>프로퍼티 어트리뷰트 재정의</th>
</tr>
</thead>
<tbody><tr>
<td>객체 확장 금지</td>
<td>Object.preventExtensions</td>
<td>X</td>
<td>O</td>
<td>O</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>객체 밀봉</td>
<td>Object.seal</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
<td>X (configurable : false)</td>
</tr>
<tr>
<td>객체 동결</td>
<td>Object.freeze</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>X (writable : false)</td>
<td>X (configurable : false)</td>
</tr>
</tbody></table>
<p>객체 확장 금지 확인 메서드 - Object.isExtensible( ) false면 확장 금지된 객체</p>
<p>객체 밀봉 확인 메서드 - Object.isSealed( ) true면 밀봉된 객체</p>
<p>객체 동결 메서드 - Object.isFrozen( ) true면 동결된 객체</p>
<p>깊은 방지를 구현하려면 재귀적으로 객체 값을 갖는 모든 프로퍼티에 대해 Object.freeze 메서드를 호출해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepFreeze</span>(<span class="params">target</span>) &#123;</span><br><span class="line">  <span class="comment">// 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않는 객체만 동결</span></span><br><span class="line">  <span class="keyword">if</span> (target &amp;&amp; <span class="keyword">typeof</span> target === <span class="string">&quot;object&quot;</span> &amp;&amp; !<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(target)) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">freeze</span>(target);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">keys</span>(target).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> <span class="title function_">deepFreeze</span>(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="attr">address</span>: &#123; <span class="attr">city</span>: <span class="string">&quot;Seoul&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 깊은 객체 동결</span></span><br><span class="line"><span class="title function_">deepFreeze</span>(person);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isFrozen</span>(person.<span class="property">address</span>));</span><br><span class="line"></span><br><span class="line">person.<span class="property">address</span>.<span class="property">city</span> = <span class="string">&quot;Busan&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);</span><br></pre></td></tr></table></figure>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%96%B4%ED%8A%B8%EB%A6%AC%EB%B7%B0%ED%8A%B8/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2023/03/03/JavaScript/%ED%95%A8%EC%88%98/"
                            aria-label=": 함수"
                        >
                            함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2023-03-03T10:50:56+09:00">
	
		    2023/03/03
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/JavaScript/">JavaScript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="Function-함수"><a href="#Function-함수" class="headerlink" title="Function 함수"></a>Function 함수</h1><p>오늘은 자바스크립트의 함수에 대해 공부해보자.</p>
<p>자바스크립트에서 함수란, 코드블록으로 일련의 문(statement)을 감싸서 하나의 실행 단위로 정의한 것이다.</p>
<blockquote>
<p>함수를 목적에 맞게 사용하기 위해서는 함수이름, 매개변수, 인자 등을 알맞게 설정해줘야한다. 그렇지 않게 사용하는 것은 지양한다.</p>
</blockquote>
<h2 id="목적"><a href="#목적" class="headerlink" title="목적"></a>목적</h2><p>함수를 사용하는 목적은 필요할 때마다 호출하여 일련의 코드들을 재사용하기 위해 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">returnRank</span>(<span class="params">name, tall</span>) &#123;</span><br><span class="line">  <span class="comment">// 이름과 키라는 매개변수를 통해 순위를 반환해주는 함수</span></span><br><span class="line">  <span class="keyword">return</span> rank;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 100번째 줄</span></span><br><span class="line"><span class="title function_">returnRank</span>(<span class="string">&quot;yiju&quot;</span>, <span class="number">188</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 300번째 줄</span></span><br><span class="line"><span class="title function_">returnRank</span>(<span class="string">&quot;kim&quot;</span>, <span class="number">160</span>);</span><br></pre></td></tr></table></figure>

<p>위와 같이 하나의 로직을 여러 곳에서 재사용하고 싶을 때 함수를 사용하면 함수 이름으로 <span style="color:red">가독성</span>도 높아지고 100번째 줄이나 300번째 줄에서 코드가 문제가 발생했을 경우 returnRank 함수가 선언된 부분만 유지보수를 해주면 되기 때문에 <span style="color:red">유지보수</span>가 간편해진다.</p>
<blockquote>
<p>단, 함수는 목적에 맞게 가급적 작게 만들고 매개변수도 3개를 넘지 않도록 만들 것을 지향한다.</p>
</blockquote>
<hr>
<h2 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h2><p>함수를 정의하는 방식은 4가지 방식이 있다.</p>
<ul>
<li>함수 선언문</li>
<li>함수 표현식</li>
<li>Function 생성자 함수</li>
<li>화살표 함수(ES6)</li>
</ul>
<p>기본적인 함수 선언문과 함수 표현식에 대해 알아보자</p>
<blockquote>
<p>자바스크립트에서 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의가 모호하다.(MDN에서도 모호..) 위에서 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 그렇기 때문에 “함수는 정의된다”로 표현한다. C언어에서 정의는 변수에 값을 할당하여 변수의 실체를 명확히 하는 것이다. 즉, 메모리 주소가 연결되면 정의라고 판단)</p>
</blockquote>
<h3 id="함수-리터럴"><a href="#함수-리터럴" class="headerlink" title="함수 리터럴"></a>함수 리터럴</h3><p>리터럴은 문자나 약속된 기호를 사용하여 값을 생성하는 표기법이다. 함수로 함수 리터럴을 사용하여 값을 생성할 수 있다. 함수 리터럴은 다음으로 구성되어 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>function 키워드</li>
<li>함수 이름 (add) <b>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자</b></li>
<li>매개변수 목록 (x,y)</li>
<li>함수 몸체({})</li>
</ul>
<h3 id="함수-선언문"><a href="#함수-선언문" class="headerlink" title="함수 선언문"></a>함수 선언문</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출 (함수이름과 똑같은 식별자를 사용)</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>함수 선언문은 표현식이 아닌 문이다.</li>
<li>함수 선언문은 함수 이름을 생략할 수 없다.</li>
</ul>
<p>앞서 언급했듯이 함수 이름은 함수 몸체 내에서만 참조 가능하다. 그렇다면 함수를 호출하려면 어떻게 할 수 있을까?</p>
<p>함수 선언문으로 사용되면 자바스크립트 엔진이 <b>암묵적</b>으로 함수 이름과 똑같은 식별자를 생성하고 함수 객체를 할당한다.</p>
<h3 id="함수-표현식"><a href="#함수-표현식" class="headerlink" title="함수 표현식"></a>함수 표현식</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 호출 (함수 이름으로 호출)</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>자바스크립트 함수는 객체타입의 값이기 때문에 변수에 할당하거나 프로퍼티의 값으로 될 수 있고 배열과 같은 자료구조의 요소가 될 수 있다.</p>
<p>이러한 성질 때문에 자바스크립트 함수는 <span style="color:red">일급객체</span>다.</p>
<ul>
<li>함수 표현식은 함수 이름 생략하는 것이 일반적이다.</li>
<li>함수 표현식은 표현식인 문이다. 즉, 값처럼 사용할 수 있다. ex)변수할당</li>
</ul>
<hr>
<h2 id="중의적-코드-기명-함수-리터럴"><a href="#중의적-코드-기명-함수-리터럴" class="headerlink" title="중의적 코드 : 기명 함수 리터럴"></a>중의적 코드 : 기명 함수 리터럴</h2><p>함수 선언문은 함수 이름을 생략할 수 없으며 표현식이 아닌 문이므로 변수에 할당할 수 없다. 그러면 아래의 코드는 어떻게 동작할지 예상해보자.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 기명 함수 리터럴 단독 사용 문맥 =&gt; 함수 선언문으로 해석</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// foo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 변수에 할당하는 문맥 =&gt; 함수 리터럴 표현식으로 해석</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">add</span>(<span class="number">2</span>, <span class="number">3</span>)); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 피연산자로 사용되는 문맥 =&gt; 함수 리터럴 표현식으로 해석</span></span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// ReferenceError : bar is not defined</span></span><br></pre></td></tr></table></figure>

<p>위 코드에서는 함수 선언문이 변수에 할당된 것처럼 보인다. 이게 어떻게 가능할까?</p>
<p>우리는 블록문 {}에서 앞서 중의적 표현과 문맥에 대해 다룬 적이 있다.</p>
<p>자바스크립트 엔진이 {}를 객체 리터럴로 인지할 것인지, 아니면 코드 블록문으로 인지할 것인지는 <strong style="font-size:1.5rem">문맥</strong>에 따라 다르게 결정된다.</p>
<p>이와 같이 기명 함수 리터럴도 중의적인 코드이므로 문맥에 따라 해석이 달라질 수 있다. 다음은 자바스크립트 엔진이 기명 함수 리터럴을 해석하는 방식이다.</p>
<ol>
<li><p>기명 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석</p>
</li>
<li><p>함수 리터럴이 값으로 평가되어야 하는 문맥, 예시처럼 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다.</p>
</li>
</ol>
<p>() 그룹 연산자 안에서 기명 함수 리터럴은 함수 리터럴 표현식으로 해석된다.</p>
<p>함수 리터럴에서 함수 이름은 함수 몸체 내부에서만 참조가능하기 때문에 외부에서 함수이름으로 호출시 에러 발생</p>
<blockquote>
<p>함수 선언문의 경우 함수이름으로 암묵적으로 식별자를 생성하여 객체를 할당해주기 때문에 함수 이름으로 호출 가능</p>
</blockquote>
<hr>
<h2 id="함수-선언문-vs-함수-표현식"><a href="#함수-선언문-vs-함수-표현식" class="headerlink" title="함수 선언문 vs 함수 표현식"></a>함수 선언문 vs 함수 표현식</h2><p>함수 선언문과 함수 표현식은 <strong>생성 시점</strong>이 다르다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(add); <span class="comment">// ƒ add(x, y) &#123;return x + y;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sub); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 선언문</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식</span></span><br><span class="line"><span class="keyword">var</span> sub = <span class="keyword">function</span> (<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>함수 선언문 : 모든 선언문이 런타임 이전에 JS엔진에 먼저 실행된다. 즉, 암묵적으로 함수 이름과 동일한 식별자를 생성하여 함수 객체를 할당한다. <span style="color:red">함수 호이스팅</span></p>
</li>
<li><p>함수 표현식 : 변수 선언 부분은 변수 호이스팅이 발생하여 undefined로 초기화되고 변수 할당문은 런타임에서 평가되어 함수 객체로 할당된다.</p>
</li>
</ul>
<hr>
<h2 id="함수호출"><a href="#함수호출" class="headerlink" title="함수호출"></a>함수호출</h2><p>일반 객체와 함수가 다른점은 함수는 호출을 할 수 있다는 것이다. 호출과 참조는 다르다. 호출은 실행흐름을 바꾸기도 하며 코드문들의 결과값을 반환해준다.</p>
<p>() 함수 호출 연산자를 사용하여 함수를 호출할 수 있다. 그러면 실행흐름이 함수로 옮겨지고 return 키워드를 만나게되면 그 즉시 함수 실행을 종료하고 return 키워드 우측 표현식에 대한 값을 반환한다.</p>
<blockquote>
<p>return 키워드 다음 행의 문들은 무시된다. return 키워드 다음에 개행하여 코드를 작성하면 자동 세미콜론 삽입 기능에 의해 큰 오류를 발생시킬 수 있다.</p>
</blockquote>
<h3 id="인수"><a href="#인수" class="headerlink" title="인수"></a>인수</h3><p>함수를 호출할 때 매개변수에 들어갈 인수를 전달해줘야한다. 하지만 인수가 매개변수보다 적거나 많더라도 오류를 발생시키지 않는다.</p>
<ul>
<li>매개변수보다 인수를 적게 전달할 경우 부족한 매개변수는 undefined 처리된다.</li>
<li>매개변수보다 인수가 많아도 오류 발생 시키지 않는다. 단, 모든 인수는 arguments 객체의 프로퍼티로 보관된다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x,y = <span class="number">0</span>,z</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y+z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>, ,<span class="number">5</span>); <span class="comment">// X</span></span><br></pre></td></tr></table></figure>

<p>중간에 y값의 매개변수를 생략하고 싶어서 공백으로 둬서 호출할 수 없다.</p>
<p>만약 인자를 순서를 신경쓰지 않고 전달해주고 싶다면 객체를 인자로 전달해주면 된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span> &#125;,</span><br><span class="line">  <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>단, 함수 내부에서 객체를 변경하게 되면 참조값으로 복사되었기 때문에 <span style="color:red">함수 외부의 객체가 변경되는 부수효과</span>가 발생할 수 있으니 주의해야한다.</p>
<hr>
<h2 id="순수함수와-비순수함수"><a href="#순수함수와-비순수함수" class="headerlink" title="순수함수와 비순수함수"></a>순수함수와 비순수함수</h2><p>외부 상태에 의존하거나 참조하거나 즉, 부수효과가 없는 함수를 순수함수라고 하고 그렇지 않은 함수를 비순수함수라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 함수는 a,b 매개변수가 함수 내부로 전달되어도 외부 변수 x의 값이 변경되면 결과값이 달라지기 때문에 순수함수가 아니다.</p>
<p>순수함수는 오직 매개변수만을 통해 함수 내부로 전달된 인수에게만 의존하여 값을 생성해 반환한다. <span style="color:red">전달받은 인수는 변경하지 않는다.</span></p>
<blockquote>
<p>하지만 우리가 순수함수만으로 프로그래밍을 하는 것은 불가능하다. 함수형 프로그래밍은 반복문, 조건문을 제거하여 복잡성을 해결하고 전역 변수 사용을 억제 및 생명주기 최소화하여 상태변경을 최소화하는 것을 목표로 하기 때문에 순수함수만을 사용하는 것은 옳지 않다.</p>
</blockquote>
<h3 id="콜백함수"><a href="#콜백함수" class="headerlink" title="콜백함수"></a>콜백함수</h3><p>함수의 매개변수를 통해 함수 내부로 전달되는 함수를 콜백함수라고 한다. 또한 콜백함수를 매개변수를 통해 받은 함수는 고차함수라고 한다.</p>
<p>콜백함수는 함수 외부에서 고차함수 내부로 주입하기 때문에 자유롭게 교체가 가능하고 경우에 따라 변경되는 로직을 가진 외부 함수를 내부로 전달할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 외부에서 전달받은 f를 n만큼 반복호출</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repeat</span>(<span class="params">n, f</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="title function_">f</span>(i); <span class="comment">// i를 전달하면서 f를 호출</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logAll = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeat</span>(<span class="number">5</span>, logAll); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> logOdds = <span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">repeat</span>(<span class="number">5</span>, logOdds); <span class="comment">// 1 3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>콜백함수를 전달할 때에는 콜백함수를 호출하지 않고 함수 전달만 해야한다.</li>
</ul>
<p><strong style="font-size:1.5rem">콜백함수는 비순수함수인가?</strong></p>
<p>“앞서 함수 내부에서 외부 상태를 직접 참조하지 않더라도 매개변수를 통해 <span style="color:red">객체</span>를 전달받으면 비순수함수가 된다.”</p>
<p>&#x3D;&gt; 맞다 콜백함수도 비순수 함수이다. 나중에 addEventListener 함수도 콜백함수를 매개변수로 받아 DOM을 조작하는 것도 배울 텐데 DOM을 조작한다는 것 자체가 비순수함수가 되는 것이다. 다시말해 순수함수만으로 코드를 짜는것은 불가능하다.</p>
<hr>
<h2 id="소감"><a href="#소감" class="headerlink" title="소감"></a>소감</h2><p>모던 자바스크립트 12장 함수 파트를 읽으면서 함수 정의와 목적에 대해 배웠고 그동안 무의식적으로 사용했던 함수 이름을 통한 호출에 대해 이유를 알게되어 재밌었다.</p>
<p>코드 맥락에 맞게 자바스크립트 엔진이 해석하는게 달라질 수 있다는 점과 콜백함수와 순수, 비순수 함수에 대해 제대로 알고 넘어갈 수 있어 좋았다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2023/03/03/JavaScript/%ED%95%A8%EC%88%98/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/page/7/"
                aria-label="최근 포스트"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>최근 포스트</span>
            </a>
          </li>
        
        
          <li class="pagination-next">
            <a
                class="btn btn--default btn--small"
                href="/page/9/"
                aria-label="이전 포스트"
            >
              <span>이전 포스트</span>
              <i class="fa fa-angle-right text-base icon-ml"></i>
            </a>
          </li>
        
        <li class="pagination-number">page 8 of 25</li>
    </ul>
</div>

</section>


                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 loco9939. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loco9939</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-wcqoifde3xwnijjx9xd2irfrrksglozwqpgaqfvxoft22e4znrk7db1xxnsx.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
