
<!DOCTYPE html>
<html lang="ko">
    <link rel="canonical" href="https://loco9939.github.io/categories/javascript/page/2/"/>

<head>
    <meta name="google-site-verification" content="7ur7A9bi79NuylPOO6FjMynEeinWe-v-kmDPZD-bcqY" />
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="Loco&#39;s Dev Blog">
    <title>카테고리: Javascript - Loco&#39;s Dev Blog</title>
    <meta name="author" content="loco9939">
    
        <meta name="keywords" content="loco9939,javascript,">
    
    
    
        
            <link rel="alternate" type="application/atom+xml" title="RSS" href="/atom.xml">
        
    
    <script type="application/ld+json">{}</script>
    <meta property="og:type" content="blog">
<meta property="og:title" content="Loco&#39;s Dev Blog">
<meta property="og:url" content="https://loco9939.github.io/categories/Javascript/page/2/index.html">
<meta property="og:site_name" content="Loco&#39;s Dev Blog">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="loco9939">
<meta property="article:tag" content="loco9939">
<meta property="article:tag" content="javascript">
<meta name="twitter:card" content="summary">
    
    
        
    
    
    
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-alaac2o0p8lb5n7mx8aazw1dzhwcsltexgjtf9twurzytkujqiefoq1soijy.min.css">

    <!--STYLES END-->
    

    

    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    

<header id="header" data-behavior="1">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            Loco&#39;s Dev Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="링크 열기: /#about"
            >
        
        
        </a>
    
</header>

            <!-- Define author's picture -->


<nav id="sidebar" data-behavior="1">
    <div class="sidebar-container">
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="Home"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Home</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="카테고리"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">카테고리</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="태그"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">태그</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="아카이브"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">아카이브</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="검색"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">검색</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="About"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">About</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://twitter.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Twitter"
                        >
                        <i class="sidebar-button-icon fab fa-twitter" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Twitter</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://facebook.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Facebook"
                        >
                        <i class="sidebar-button-icon fab fa-facebook" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Facebook</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://plus.google.com/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Google +"
                        >
                        <i class="sidebar-button-icon fab fa-google-plus" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Google +</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/mailto"
                            
                            rel="noopener"
                            title="Mail"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Mail</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/atom.xml"
                            
                            rel="noopener"
                            title="RSS"
                        >
                        <i class="sidebar-button-icon fa fa-rss" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">RSS</span>
                    </a>
            </li>
            
        </ul>
        
    </div>
</nav>

            
            <div id="main" data-behavior="1"
                 class="
                        hasCoverMetaIn
                        ">
                
    <section class="postShorten-group main-content-wrap">
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/29/JavaScript/%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC/"
                            aria-label=": 브라우저 렌더링 과정"
                        >
                            브라우저 렌더링 과정
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-29T18:59:35+09:00">
	
		    2022/08/29
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="브라우저란"><a href="#브라우저란" class="headerlink" title="브라우저란?"></a>브라우저란?</h1><p>브라우저는 HTML, CSS, Javascript로 작성된 텍스트 문서를 서버에게 요청하여 응답을 받아 의미있는 단위인 토큰으로 파싱하여 시각적으로 렌더링 해주는 역할을 담당한다.</p>
<h1 id="브라우저-렌더링-과정"><a href="#브라우저-렌더링-과정" class="headerlink" title="브라우저 렌더링 과정"></a>브라우저 렌더링 과정</h1><h2 id="1-요청과-응답"><a href="#1-요청과-응답" class="headerlink" title="1. 요청과 응답"></a>1. 요청과 응답</h2><p>서버에 요청하기 위해 브라우저는 주소창을 제공한다. 주소창에 URL을 입력하면 URL의 호스트 이름이 DNS를 통해 IP주소로 변환되고 IP 주소를 갖는 서버에게 요청을 전송한다.</p>
<p>이렇게 요청을 보내면 서버는 서버의 루트 폴더에 존재하는 정적파일로 응답을 보낸다. 기본적으로 index.html</p>
<h2 id="2-HTML-파싱과-DOM-생성"><a href="#2-HTML-파싱과-DOM-생성" class="headerlink" title="2. HTML 파싱과 DOM 생성"></a>2. HTML 파싱과 DOM 생성</h2><p>브라우저 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다. 의미없는 문자열 데이터를 브라우저가 이해할 수 있는 자료구조(객체)로 변환하여 메모리에 저장해야한다.</p>
<p><strong>그래서 HTML 문서를 파싱하여 <span style="color:red">브라우저가 이해할 수 있는 자료구조인 DOM을 생성</span>한다.</strong></p>
<ol>
<li>서버는 요청의 응답하기 위해 요청한 HTML 파일을 읽어 메모리에 저장한 뒤 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다.</li>
<li>브라우저는 이를 받아 meta 태그의 charset 방식에 따라(UTF-8) 문자열로 변환한다.</li>
<li>문자열로 변환된 HTML문서를 토큰화한다.</li>
<li>각 토큰을 객체로 변환하여 노드를 생성한다. 노드는 DOM을 구성하는 기본 요소이다. ex) 문서 노드, 요소 노드 등</li>
<li>HTML 문서는 중첩관계를 통해 부자관계가 형성된다. 이러한 부자관계를 반영하여 <strong>모든 노드들을 트리 자료구조로 구성한다. 이러한 노드들로 구성된 트리 자료구조를 DOM이라 부른다.</strong></li>
</ol>
<h2 id="3-CSS-파싱과-CSSOM-생성"><a href="#3-CSS-파싱과-CSSOM-생성" class="headerlink" title="3. CSS 파싱과 CSSOM 생성"></a>3. CSS 파싱과 CSSOM 생성</h2><p>렌더링 엔진은 HTML을 한줄씩 읽어나가며 순차적으로 파싱하여 DOM을 생성해 나간다. <strong>DOM을 생성하다가 CSS를 로드하는 link 태그나 style 태그를 만나면 <span style="color:red">DOM 생성을 일시중단</span>한다.</strong></p>
<p>그 결과 CSS 파일을 서버에 요청하여 응답받은 CSS 파일이나 style 태그 내의 CSS를 HTML과 동일한 과정으로 토큰화 생성 → CSSOM 생성 과정을 거친다. 이후 파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작한다.</p>
<h2 id="4-렌더-트리-생성"><a href="#4-렌더-트리-생성" class="headerlink" title="4. 렌더 트리 생성"></a>4. 렌더 트리 생성</h2><p>앞선 과정에서 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. 이 때 <strong>브라우저 화면에 렌더링되지 않는 노드<span style="color:red">(meta태그, script 태그 등)</span>와 CSS에 의해 표시되지 않는<span style="color:red">(display:none)</span> 노드들은 포함하지 않는다.</strong></p>
<p>지금까지의 렌더링 과정은 여러번 반복되서 실행될 수 있다. <strong>렌더링이 반복 실행되는 원인은 다음과 같다.</strong></p>
<ul>
<li>자바스크립트에 의한 노드 추가 또는 삭제</li>
<li>브라우저 창의 리사이징에 의한 viewport 크기 변경</li>
<li>HTML 요소의 레이아웃(위치와 크기)을 변경시키는 width, height, margin, padding, border, display, position 등의 스타일 변경</li>
</ul>
<p><strong>이러한 리렌더링은 비용이 많이 들고 성능에 악영향을 주므로 <span style="color:red">리렌더링이 적게 발생하도록 하여야한다.</span></strong></p>
<h2 id="5-자바스크립트-파싱과-실행"><a href="#5-자바스크립트-파싱과-실행" class="headerlink" title="5. 자바스크립트 파싱과 실행"></a>5. 자바스크립트 파싱과 실행</h2><p>HTML 파싱의 결과물 DOM은 HTML 문서의 구조와 정보뿐 아니라 HTML 요소와 스타일을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다.</p>
<p>즉, DOM API를 사용하여 이미 생성된 DOM을 동적으로 조작할 수 있다.</p>
<p>CSS 파싱과정과 마찬가지로 script 태그 만나면 DOM 생성을 일시 중단한다.</p>
<p>이후 자바스크립트 파일을 서버에 요청하여 응답받은 파일이나 script 태그내의 코드를 파싱하기 위해 <strong>자바스크립트 엔진에 제어권을 넘긴다. <span style="color:red">(렌더링 엔진 → 자바스크립트 엔진으로 제어권 이동)</span></strong></p>
<p>이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권 넘겨 HTML 파싱 중단된 시점부터 다시 DOM 생성을 재개한다.</p>
<p>자바스크립트 엔진은 자바스크립트 코드를 파싱하기 시작한다. 자바스크립트를 해석하여 <strong>AST(추상적 구문 트리)를 생성</strong>한다. 그리고 <strong>AST를 기반으로</strong> 인터프리터가 실행할 수 있는 중간 코드인 <strong>바이트 코드를 생성</strong>하여 실행한다.</p>
<h2 id="6-리플로우와-리페인트"><a href="#6-리플로우와-리페인트" class="headerlink" title="6. 리플로우와 리페인트"></a>6. 리플로우와 리페인트</h2><p>만약 자바스크립트 코드에 DOM, CSSOM을 변경하는 DOM API가 사용된 경우 DOM, CSSOM이 변경되고 변경된 DOM, CSSOM으로 다시 렌더트리로 결합되고 레이아웃과 페인트 과정을 거쳐 브라우저 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라고 한다.</p>
<h1 id="자바스크립트-파싱에-의한-HTML-파싱중단"><a href="#자바스크립트-파싱에-의한-HTML-파싱중단" class="headerlink" title="자바스크립트 파싱에 의한 HTML 파싱중단"></a>자바스크립트 파싱에 의한 HTML 파싱중단</h1><p>렌더링 엔진과 자바스크립트 엔진은 서로 제어권을 이동시키면서 병렬적으로 파싱하지 않고 <strong>직렬적으로 파싱을 수행한다.</strong> 브라우저는 이처럼 <strong>동기적</strong>으로, 즉 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행한다.</p>
<p>script 태그를 만나면 제어권이 이동하기 때문에 HTML 문서 내의 script 태그의 위치는 중요한 의미를 갖는다.</p>
<p>대표적인 문제로는 HTML이 생성되기 전에 자바스크립트 코드가 HTML요소를 동적으로 조작하려고 하면 <strong>정상적으로 동작하지 않을 수 있다.</strong> 이에 대한 해결책으로는 아래와 같다.</p>
<ul>
<li>body 태그 제일 하단에 script 태그(자바스크립트)를 위치 시키는 것</li>
</ul>
<h2 id="script-태그의-async-x2F-defer-어트리뷰트"><a href="#script-태그의-async-x2F-defer-어트리뷰트" class="headerlink" title="script 태그의 async&#x2F;defer 어트리뷰트"></a>script 태그의 async&#x2F;defer 어트리뷰트</h2><p>앞서 알아본 문제를 근본적으로 해결하기 위해서 HTML5부터 script 태그에 <strong>async</strong>와 <strong>defer 어트리뷰트</strong>가 추가되었다.</p>
<p>두 어트리뷰트는 src 어트리뷰트를 통해 외부의 자바스크립트 파일을 로드하는 경우에만 사용할 수 있다.</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;extern.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">src</span>=<span class="string">&quot;extern.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이 둘을 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 진행된다. 단 두 어트리뷰트의 실행 시점의 차이가 있다.</p>
<ol>
<li>async 어트리뷰트</li>
</ol>
<p>자바스크립트의 파싱과 실행은 <strong>자바스크립트 파일의 로드가 완료된 직후 진행</strong>된다. 이 때 HTML 파싱이 중단된다.</p>
<p>여러개의 script 태그에 async 어트리뷰트를 지정하면 script 태그의 순서와는 상관없이 <strong>로드가 완료된 자바스크립트부터 먼저 실행되므로 순서가 보장되지 않는다.</strong></p>
<p>즉, 순서보장이 필요한 script 태그는 async 어트리뷰트 지정하지 않아야 한다.</p>
<ol start="2">
<li>defer 어트리뷰트</li>
</ol>
<p>자바스크립트의 파싱과 실행은 <strong>HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후</strong>(DOMContentLoaded 이벤트가 발생한다) 진행된다.</p>
<blockquote>
<p>모듈은 기본적으로 defer이다. async는 잘 사용하지 않지만 폰트의 경우 용량도 크고 순서가 크게 상관이 없으니 최대한 빨리 가져오기 위해 async를 사용하기도 한다.</p>
</blockquote>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/29/JavaScript/%E1%84%87%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%AE%E1%84%8C%E1%85%A5%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/29/JavaScript/%EB%AA%A8%EB%93%88%20%EB%8B%A4%EC%8B%9C%20%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0/"
                            aria-label=": 모듈 다시 내보내기"
                        >
                            모듈 다시 내보내기
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-29T18:59:35+09:00">
	
		    2022/08/29
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="📌-모듈-다시-내보내기-기능"><a href="#📌-모듈-다시-내보내기-기능" class="headerlink" title="📌 모듈 다시 내보내기 기능"></a>📌 모듈 다시 내보내기 기능</h1><p>import한 모듈을 즉시 다시 내보내기 기능을 구현할 수 있다.</p>
<h2 id="사용하는-이유"><a href="#사용하는-이유" class="headerlink" title="사용하는 이유"></a>사용하는 이유</h2><p>진입점인 index.js 파일이 있다고 가정하자. 이 진입점을 내보내서 다른 개발자들이 안의 모듈들을 사용하려고 할 때, 다른 개발자가 모듈의 내부 구조를 건드리게 하면 안된다.</p>
<p>그러기 위해서 공개할 모듈만 index.js 파일에 넣어 내보내기를 하고 나머지는 숨기는 것이 현명하다.</p>
<p>때문에 내보낼 기능들을 분산하여 구현한 뒤 index.js에서 해당 기능들을 가져와서 다시 내보내기 하면 원하는 목적을 이룰 수 있다.</p>
<h2 id="사용방법"><a href="#사용방법" class="headerlink" title="사용방법"></a>사용방법</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// currency, currencyKR 모듈을 다시 내보냅니다.</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./currency/currency.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fetchBooks 모듈을 다시 내보냅니다.</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./fetchBooks.js&quot;</span>;</span><br><span class="line"><span class="keyword">as</span></span><br><span class="line"><span class="keyword">import</span>, <span class="keyword">export</span> 할 때 <span class="keyword">as</span> 라는 문법을 사용할 수 있다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">as</span>를 사용하면 이름을 바꿔서 모듈을 가져올 수 있다.</span><br><span class="line"></span><br><span class="line"><span class="comment">// module.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; currencyKR <span class="keyword">as</span> currency &#125; <span class="keyword">from</span> <span class="string">&quot;../../utils/index.js&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>currencyKR 기능을 currency 라는 이름으로 바꿔서 import 해주었다.</p>
<h1 id="🏓-소감"><a href="#🏓-소감" class="headerlink" title="🏓 소감"></a>🏓 소감</h1><p>module에 대해서는 쓸 때마다 헷갈렸었는데, 이렇게 모르는 것이 생길 때마다 공부하여 정리하다보면 익숙해지면서 알게 될 것 같다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/29/JavaScript/%EB%AA%A8%EB%93%88%20%EB%8B%A4%EC%8B%9C%20%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/26/JavaScript/%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5/"
                            aria-label=": 이터러블과 이터레이터"
                        >
                            이터러블과 이터레이터
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-26T19:27:20+09:00">
	
		    2022/08/26
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="이터레이션-프로토콜"><a href="#이터레이션-프로토콜" class="headerlink" title="이터레이션 프로토콜"></a>이터레이션 프로토콜</h1><p>ES6에서 도입된 이터레이션 프로토콜은 순회 가능한 데이터 컬렉션을 만들기 위한 규약이다.</p>
<p>즉, ES6 이후부터는 순회 가능한 데이터 컬렉션을 이터레이션 프로토콜 규약을 준수하는 이터러블로 통일하였다.</p>
<h2 id="이터러블-프로토콜"><a href="#이터러블-프로토콜" class="headerlink" title="이터러블 프로토콜"></a>이터러블 프로토콜</h2><p>Symbol.iterator를 프로퍼티 키로 메서드 직접 구현하거나 프로토타입 체인을 통해 상속받은 Symbol.iterator 메서드를 호출 시 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.</p>
<p>위의 규약을 준수한 객체를 이터러블이라고 한다. 이터러블은 다음이 가능하다.</p>
<ul>
<li>for…of 문 순회</li>
<li>spread 문법</li>
<li>배열 디스트럭처링 할당의 대상</li>
</ul>
<blockquote>
<p>일반객체는 Symbol.iterator 메서드를 구현하거나 상속받지 않으므로 이터러블이 아니다.</p>
</blockquote>
<h2 id="이터레이터-프로토콜"><a href="#이터레이터-프로토콜" class="headerlink" title="이터레이터 프로토콜"></a>이터레이터 프로토콜</h2><p>이터러블의 Symbol.iterator 메서드 호출하면 이터레이터 프로토콜을 준수한 이터레이터를 반환한다. 이터레이터는 next 메서드를 소유하고 next 메서드 호출 시 이터러블을 순회하며 value와 done 프로퍼티를 갖는 이터레이터 리절트 객체를 반환한다. 이터레이터는 이터러블 요소를 탐색하기 위한 포인터 역할을 한다.</p>
<h1 id="이터레이션-프로토콜의-필요성"><a href="#이터레이션-프로토콜의-필요성" class="headerlink" title="이터레이션 프로토콜의 필요성"></a>이터레이션 프로토콜의 필요성</h1><p>이터러블은 for..of문, 스프레드 문법, 배열 디스트럭처링 할당과 같은 데이터 소비자에 의해 사용되므로 데이터 공급자의 역할을 한다고 볼 수 있다.</p>
<p>다양한 데이터 공급자(Array, String, Map 등)가 이터레이션 프로토콜이라는 하나의 규약만 준수하도록 규정하면 데이터 소비자(for..of, 스프레드 문법 등)는 이터레이션 프로토콜만 지원하도록 구현하면 된다.</p>
<p>즉, 이터레이션 프로토콜은 다양한 데이터 공급자가 <strong>하나의 순회방식을 갖도록 규정</strong>하여 데이터 소비자가 효율적으로 다양한 데이터 공급자를 사용할 수 있도록 <strong>데이터 소비자와 데이터 공급자를 연결하는 인터페이스 역할</strong>을 한다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>어떤 객체가 Symbol.iterator 메서드를 호출하여 이터레이터 프로토콜을 준수한 이터레이터를 반환한다.</p>
<p>위와 같은 규약을 이터러블 프로토콜이라 하며 이터러블 프로토콜을 준수한 객체를 이터러블이라 한다.</p>
<p>next 메서드를 소유한 이터레이터가 next 메서드 호출하면 이터러블 순회하면서 이터레이터 리절트 객체 반환한다.</p>
<p>위와 같은 규약을 이터레이터 프로토콜이라 하며 이터레이터 프로토콜을 준수한 객체를 이터레이터라고한다.</p>
<ul>
<li>이터레이터 : next 메서드 소유하여 호출시 이터레이터 리절트 객체 반환</li>
<li>이터러블 : Symbol.iterator 메서드를 호출하여 이터레이터 반환</li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/26/JavaScript/%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%85%E1%85%A5%E1%84%87%E1%85%B3%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%84%90%E1%85%A5/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/25/JavaScript/%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%AA%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE/"
                            aria-label=": 메서드와 화살표 함수"
                        >
                            메서드와 화살표 함수
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-25T17:54:12+09:00">
	
		    2022/08/25
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="ES6-이후-메서드"><a href="#ES6-이후-메서드" class="headerlink" title="ES6 이후 메서드"></a>ES6 이후 메서드</h1><p>ES6 이전의 함수는 사용 목적에 따라 일반함수로 호출이 가능했고 생성자 함수로 호출이 가능했다. <strong>즉, ES6 이전의 모든 함수는 callable이면서 constructor다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">map</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">// [ 2, 4, 6 ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>심지어 콜백함수도 constructor이기 때문에 불필요한 프로토타입 객체를 생성한다.</li>
</ul>
<p>이처럼 ES6 이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없어 호출방식에 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입 객체를 생성한다. 이는 혼란스러워 실수를 유발하고 성능에도 좋지 않다.</p>
<ul>
<li>ES6 이후부터는 오류에 엄격하도록 만들고 있다. ⇒ 오류를 발생시킬 여지가 있는 것들은 그 부분을 개선해주고 있다.</li>
</ul>
<p><strong>ES6 사양에서 메서드는 <span style="color:red">메서드 축약표현으로 정의된 함수만을 의미</span>한다.</strong></p>
<p>⇒ <strong>인스턴스 생성할 수 없는 non-constructor이다.</strong></p>
<ul>
<li>인스턴스 생성 불가</li>
<li>prototype 프로퍼티 없다</li>
<li>프로토타입 생성 불가</li>
</ul>
<p><strong>ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 [[HomeObject]]를 갖는다.</strong></p>
<h1 id="함수-사용-목적에-따라-구분한-ES6에서의-함수"><a href="#함수-사용-목적에-따라-구분한-ES6에서의-함수" class="headerlink" title="함수 사용 목적에 따라 구분한 ES6에서의 함수"></a>함수 사용 목적에 따라 구분한 ES6에서의 함수</h1><p>이를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 3가지로 구분하였다.</p>
<table>
<thead>
<tr>
<th>ES6 함수의 구분</th>
<th>constructor</th>
<th>prototype</th>
<th>super</th>
<th>arguments</th>
</tr>
</thead>
<tbody><tr>
<td>일반함수</td>
<td>O</td>
<td>O</td>
<td>X</td>
<td>O</td>
</tr>
<tr>
<td>메서드</td>
<td>X</td>
<td>X</td>
<td>O</td>
<td>O</td>
</tr>
<tr>
<td>화살표 함수</td>
<td>X</td>
<td>X</td>
<td>X</td>
<td>X</td>
</tr>
</tbody></table>
<h1 id="화살표-함수"><a href="#화살표-함수" class="headerlink" title="화살표 함수"></a>화살표 함수</h1><p>function 키워드 함수보다 표현만 간단한 것이 아니라 내부 동작도 간략한다.</p>
<p>주로 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위해 사용한다.</p>
<h2 id="화살표-함수-정의"><a href="#화살표-함수-정의" class="headerlink" title="화살표 함수 정의"></a>화살표 함수 정의</h2><p>함수 선언문 안되고 함수 표현식으로만 정의 가능하다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x, y</span>) =&gt; x * y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">x</span>) =&gt; x * y; <span class="comment">// 매개변수 1개면 소괄호 생략 가능</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params"></span>) =&gt; x * y; <span class="comment">// 매개변수 없으면 소괄호 생략 불가</span></span><br></pre></td></tr></table></figure>

<h2 id="화살표-함수-몸체-정의"><a href="#화살표-함수-몸체-정의" class="headerlink" title="화살표 함수 몸체 정의"></a>화살표 함수 몸체 정의</h2><p>함수 몸체 감싸는 {} 중괄호를 생략한 경우 표현식이 아닌 문일 경우 에러를 발생 시킨다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concise body</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">power</span> = x =&gt; x ** <span class="number">2</span>;</span><br><span class="line"><span class="title function_">power</span>(<span class="number">2</span>); <span class="comment">// -&gt; 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 동일하다.</span></span><br><span class="line"><span class="comment">// block body</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">power</span> = x =&gt; &#123; <span class="keyword">return</span> x ** <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; <span class="keyword">const</span> x = <span class="number">1</span>; <span class="comment">// SyntaxError: Unexpected token &#x27;const&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 같이 해석된다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params"></span>) =&gt; &#123; <span class="keyword">return</span> <span class="keyword">const</span> x = <span class="number">1</span>; &#125;;</span><br></pre></td></tr></table></figure>

<p>객체 리터럴을 반환하는 경우 소괄호로 감싸줘야한다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">create</span> = (<span class="params">id, content</span>) =&gt; (&#123; id, content &#125;);</span><br><span class="line"><span class="title function_">create</span>(<span class="number">1</span>, <span class="string">&quot;JavaScript&quot;</span>); <span class="comment">// -&gt; &#123;id: 1, content: &quot;JavaScript&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 위 표현은 다음과 동일하다.</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">create</span> = (<span class="params">id, content</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; id, content &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="화살표-함수와-일반함수-차이"><a href="#화살표-함수와-일반함수-차이" class="headerlink" title="화살표 함수와 일반함수 차이"></a>화살표 함수와 일반함수 차이</h2><ol>
<li>화살표 함수는 non-constructor로, 인스턴스 생성할 수 없다.</li>
</ol>
<ul>
<li>인스턴스 생성 불가</li>
<li>prototype 프로퍼티 없다</li>
<li>프로토타입 생성 불가</li>
</ul>
<ol>
<li>화살표 함수는 중복된 매개변수 이름 선언시 에러 발생</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">arrow</span> = (<span class="params">a, a</span>) =&gt; a + a;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure>

<ol>
<li>화살표 함수는 this, arguments, super, <a target="_blank" rel="noopener" href="http://new.target/">new.target</a> 바인딩 갖지 않는다.</li>
</ol>
<p>따라서 화살표 함수 내부에서 위의 것들을 참조할 때 스코프 체인상 가장 가까운 <strong>상위 함수 중 화살표 함수가 아닌 함수의 this, arguements, super, new.target을 참조한다.</strong></p>
<h3 id="주의사항-메서드를-화살표-함수로-정의하지-않기"><a href="#주의사항-메서드를-화살표-함수로-정의하지-않기" class="headerlink" title="주의사항 : 메서드를 화살표 함수로 정의하지 않기"></a>주의사항 : 메서드를 화살표 함수로 정의하지 않기</h3><p>단, 메서드를 화살표 함수로 정의하면 안된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="attr">sayHi</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sayHi 프로퍼티에 할당된 화살표 함수 내부의 this는 상위 스코프인 전역의 this가 가리키는</span></span><br><span class="line"><span class="comment">// 전역 객체를 가리키므로 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는</span></span><br><span class="line"><span class="comment">// window.name과 같다. 전역 객체 window에는 빌트인 프로퍼티 name이 존재한다.</span></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<p>메서드 정의할 때는 메서드 축약 표현을 사용하는 것이 좋다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Good</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi Lee</span></span><br></pre></td></tr></table></figure>

<ul>
<li>메서드 내부에서 this는 메서드를 호출한 인스턴스에 바인딩된다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Lee&quot;</span>);</span><br><span class="line"><span class="comment">// 이 예제를 브라우저에서 실행하면 this.name은 빈 문자열을 갖는 window.name과 같다.</span></span><br><span class="line">person.<span class="title function_">sayHi</span>(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<ul>
<li>프로토타입 객체의 프로퍼티에 화살표 함수를 사용하는 것도 문제가 된다.</li>
<li>프로퍼티 동작 추가 시에는 <strong>ES6 메서드 정의 사용할 수 없으므로 일반함수로 정의해야한다.</strong></li>
</ul>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/25/JavaScript/%E1%84%86%E1%85%A6%E1%84%89%E1%85%A5%E1%84%83%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%92%E1%85%AA%E1%84%89%E1%85%A1%E1%86%AF%E1%84%91%E1%85%AD%20%E1%84%92%E1%85%A1%E1%86%B7%E1%84%89%E1%85%AE/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/19/JavaScript/tagged%20templates/"
                            aria-label=": tagged templates"
                        >
                            tagged templates
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-19T19:33:57+09:00">
	
		    2022/08/19
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="📌-template-literals"><a href="#📌-template-literals" class="headerlink" title="📌 template literals"></a>📌 template literals</h1><p>템플릿 리터럴은 내장된 표현식을 허용하는 문자열 리터럴이다.</p>
<h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h2><ul>
<li>&#96; 백틱이라는 기호를 사용한다.</li>
<li>${}를 사용하여 표현식을 삽입할 수 있다.</li>
<li>개행을 포함한다.</li>
</ul>
<h2 id="tagged-templates"><a href="#tagged-templates" class="headerlink" title="tagged templates"></a>tagged templates</h2><p>템플릿 리터럴의 발전된 형태로 태그드 템플릿이 있다.</p>
<p>마치 함수처럼 사용할 수 있다.</p>
<h2 id="예제-1"><a href="#예제-1" class="headerlink" title="예제 1"></a>예제 1</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> virtualNode = &#123;</span><br><span class="line"><span class="attr">name</span>: <span class="string">&#x27;figure&#x27;</span>,</span><br><span class="line"><span class="attr">className</span>: <span class="string">&#x27;tagged-template-literals&#x27;</span>,</span><br><span class="line"><span class="attr">style</span>: &#123; <span class="attr">cssText</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="title function_">styled</span> = (<span class="params">strings, Node, ...value</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> el = strings.<span class="title function_">slice</span>(<span class="number">1</span>,<span class="number">3</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc,cur</span>) =&gt;</span> acc+cur.<span class="title function_">trim</span>(),<span class="string">&#x27;&#x27;</span>).<span class="title function_">split</span>(<span class="string">&#x27;;&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    el.<span class="title function_">forEach</span>(<span class="function">(<span class="params">elem,i</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title class_">Node</span>.<span class="property">style</span>.<span class="property">cssText</span> += elem + value[i] + <span class="string">&#x27;;&#x27;</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Node</span>;</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> values = &#123;</span><br><span class="line">    <span class="attr">margin</span>: <span class="string">&#x27;10px&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;#d08471&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> received = styled<span class="string">`<span class="subst">$&#123;virtualNode&#125;</span>margin: <span class="subst">$&#123;values.margin&#125;</span>;color: <span class="subst">$&#123;values.color&#125;</span>;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(received);</span><br></pre></td></tr></table></figure>

<ul>
<li>마치 함수처럼 인수를 받아서 템플릿 리터럴에 넣어 반환값을 원하는 대로 지정해줄 수 있다.</li>
<li>리액트의 StyledComponent가 태그드 템플릿을 활용하여 탄생하게 되었다.</li>
</ul>
<h1 id="🏓-소감"><a href="#🏓-소감" class="headerlink" title="🏓 소감"></a>🏓 소감</h1><p>문자타입과 다른 타입을 파라미터로 사용하는 함수를 만들 때 원하는 반환값을 직관적으로 사용할 수 있어 용이해보인다.</p>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/19/JavaScript/tagged%20templates/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    
    <article class="postShorten postShorten--thumbnailimg-bottom">
        <div class="postShorten-wrap">
            
            <div class="postShorten-header">
                <h1 class="postShorten-title">
                    
                        <a
                            class="link-unstyled"
                            href="/2022/08/19/JavaScript/this/"
                            aria-label=": this"
                        >
                            this
                        </a>
                    
                </h1>
                <div class="postShorten-meta">
    <time datetime="2022-08-19T19:33:57+09:00">
	
		    2022/08/19
    	
    </time>
    
        <span>카테고리 </span>
        
    <a class="category-link" href="/categories/Javascript/">Javascript</a>


    
</div>

            </div>
            
                <div class="postShorten-content">
                    <h1 id="this-키워드"><a href="#this-키워드" class="headerlink" title="this 키워드"></a>this 키워드</h1><p>메서드로 프로퍼티를 참조하고 변경하기 위해서는 우선 자신이 속한 객체를 가리키는 식별자를 참조해야만 가능한 일이다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">  <span class="comment">// 프로퍼티: 객체 고유의 상태 데이터</span></span><br><span class="line">  <span class="attr">radius</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="comment">// 메서드: 상태 데이터를 참조하고 조작하는 동작</span></span><br><span class="line">  <span class="title function_">getDiameter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 이 메서드가 자신이 속한 객체의 프로퍼티나 다른 메서드를 참조하려면</span></span><br><span class="line">    <span class="comment">// 자신이 속한 객체인 circle을 참조할 수 있어야 한다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * circle.<span class="property">radius</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle.<span class="title function_">getDiameter</span>()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>객체 리터럴은 circle 변수에 할당되기 직전에 평가된다?<br>&#x3D; 할당 연산자에 의해서 피연산자를 할당해주기 위해서는 우측의 객체 리터럴이 평가된 값으로 존재해야 할당을 해줄 수 있기 때문이다.</li>
</ul>
<p>하지만 위처럼 재귀적으로 자신이 속한 객체를 참조하는 것은 바람직하지 않다.</p>
<p>그 예시를 생성자 함수를 통해 설명해보자</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="comment">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span></span><br><span class="line">  ????.<span class="property">radius</span> = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Circle</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getDiameter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 이 시점에는 생성자 함수 자신이 생성할 인스턴스를 가리키는 식별자를 알 수 없다.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * ????.<span class="property">radius</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로 인스턴스를 생성하려면 먼저 생성자 함수를 정의해야 한다.</span></span><br><span class="line"><span class="keyword">const</span> circle = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>생성자 함수 내부에서 프로퍼티나 메서드를 추가하기 위해서는 자신이 생성할 인스턴스를 참조할 수 있어야 하는데, 인스턴스를 생성하려면 생성자 함수가 존재해야한다.</li>
</ul>
<p>따라서 자신이 속한 객체, 자신이 생성할 인스턴스를 가리킬 <strong>특별한 식별자가 필요하다.</strong></p>
<p><strong>this란, 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다. this를 통해 자신이 속한 객체나 자신이 생성할 인스턴스의 프로퍼티나 메서드를 참조할 수 있다.</strong></p>
<ul>
<li>this는 코드 어디서든 참조할 수 있다. (전역에서도 가능)</li>
</ul>
<aside>
💡 단, this가 가리키는 값(this 바인딩)은 함수 호출 방식에 의해 동적으로 결정된다.

</aside>

<p>this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이므로 객체의 메서드 내부 또는 생성자 함수 내부에서만 의미가 있다. 따라서 strict mode가 선언된 일반 함수 내부의 this는 undefined가 바인딩된다. (일반함수에선 필요 없다)</p>
<h1 id="함수-호출방식과-this-바인딩"><a href="#함수-호출방식과-this-바인딩" class="headerlink" title="함수 호출방식과 this 바인딩"></a>함수 호출방식과 this 바인딩</h1><p><strong>this에 바인딩될 값은 함수 호출 방식에 의해 동적으로 결정된다.</strong></p>
<h2 id="1-일반-함수-호출"><a href="#1-일반-함수-호출" class="headerlink" title="1. 일반 함수 호출"></a>1. 일반 함수 호출</h2><p>전역 객체에 바인딩된다.</p>
<p>중첩 함수 또한 일반 함수로 호출 시 함수 내부의 this는 전역 객체에 바인딩 된다.</p>
<p>매서드 내에서 정의된 중첩함수도 일반 함수로 호출되면 역시 전역 객체에 바인딩 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티다.</span></span><br><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// const 키워드로 선언한 전역 변수 value는 전역 객체의 프로퍼티가 아니다.</span></span><br><span class="line"><span class="comment">// const value = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메서드 내에서 정의한 중첩 함수</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bar&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 메서드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    <span class="title function_">bar</span>();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>콜백함수가 일반함수로 호출된다면 콜백함수 내부의 this에도 전역객체가 바인딩된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;foo&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// &#123;value: 100, foo: ƒ&#125;</span></span><br><span class="line">    <span class="comment">// 콜백 함수 내부의 this에는 전역 객체가 바인딩된다.</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback&#x27;s this: &quot;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;callback&#x27;s this.value: &quot;</span>, <span class="variable language_">this</span>.<span class="property">value</span>); <span class="comment">// 1</span></span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<p>하지만 메서드 내의 중첩함수와 콜백함수는 외부함수를 돕는 헬퍼 함수의 역할을 하는데 <strong>외부함수인 메서드와 중첩함수 또는 콜백함수의 this가 일치하지 않는다</strong>는 것은 중첩함수 또는 콜백함수가 헬퍼 함수로 동작하는 것을 어렵게 만든다.</p>
<h3 id="화살표함수-내부에서-this"><a href="#화살표함수-내부에서-this" class="headerlink" title="화살표함수 내부에서 this"></a>화살표함수 내부에서 this</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">100</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 화살표 함수 내부의 this는 상위 스코프의 this를 가리킨다.</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">value</span>), <span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>

<h2 id="2-메서드-호출"><a href="#2-메서드-호출" class="headerlink" title="2. 메서드 호출"></a>2. 메서드 호출</h2><p>메서드 내부의 this는 메서드를 소유한 객체가 아닌 <span style="color:red">메서드를 호출한 객체에 바인딩</span>된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 메서드 내부의 this는 메서드를 호출한 객체에 바인딩된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> people = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">  <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">getName</span>()); <span class="comment">// Lee</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(people.<span class="title function_">getName</span>()); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<ul>
<li>person 객체의 getName 프로퍼티가 가리키는 함수 객체는 person 객체에 포함된 것이 아니라 독립적으로 존재하는 별도의 객체이다? 내 생각에는 this가 가리키는 것이 메서드를 소유한 객체라고 생각해도 맞지 않나?<br>person 객체에 getName 프로퍼티 키가 가리키는 함수 객체를 소유하고 있는 것이 아니라 참조값을 가지므로 독립적으로 존재하는 객체를 가리키고 있는 것이 맞다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anotherPerson = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Kim&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// getName 메서드를 anotherPerson 객체의 메서드로 할당</span></span><br><span class="line">anotherPerson.<span class="property">getName</span> = person.<span class="property">getName</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getName 메서드를 호출한 객체는 anotherPerson이다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="title function_">getName</span>()); <span class="comment">// Kim</span></span><br></pre></td></tr></table></figure>

<ul>
<li>새로운 객체의 프로퍼티에 person.getName 프로퍼티를 할당해줄 수 있다.</li>
</ul>
<p>this는 getName 메서드를 호출한 객체에 바인딩된다.</p>
<p>프로토타입 메서드 내부에서도 마찬가지로 바인딩된다.</p>
<h2 id="3-생성자-함수-호출"><a href="#3-생성자-함수-호출" class="headerlink" title="3. 생성자 함수 호출"></a>3. 생성자 함수 호출</h2><p>생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩 된다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Circle</span>(<span class="params">radius</span>) &#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">radius</span> = radius;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">getDiameter</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="variable language_">this</span>.<span class="property">radius</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> <span class="title class_">Circle</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle1.<span class="title function_">getDiameter</span>()); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(circle2.<span class="title function_">getDiameter</span>()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Function-prototype-apply-x2F-call-x2F-bind-메서드에-의한-간접-호출"><a href="#4-Function-prototype-apply-x2F-call-x2F-bind-메서드에-의한-간접-호출" class="headerlink" title="4. Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접 호출"></a>4. Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접 호출</h2><p>apply, call, bind 메서드는 Function.prototype의 메서드이다. 이들 메서드는 <strong>모든 함수가 상속받아 사용 가능하다.</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getThisBinding</span>()); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">apply</span>(thisArg)); <span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">call</span>(thisArg)); <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>call,apply 메서드는 함수를 호출하면서 첫번째 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.</p>
<ul>
<li>위 예제에서는 getThisBinding() 함수에 인수를 전달해주지 않는다.</li>
<li><strong>call, apply의 반환값은 호출한 함수의 반환값이다.</strong></li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getThisBinding 함수를 호출하면서 인수로 전달한 객체를 getThisBinding 함수의 this에 바인딩한다.</span></span><br><span class="line"><span class="comment">// apply 메서드는 호출할 함수의 인수를 배열로 묶어 전달한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">apply</span>(thisArg, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</span><br><span class="line"><span class="comment">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// call 메서드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">call</span>(thisArg, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line"><span class="comment">// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span></span><br><span class="line"><span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<p>call,apply 메서드로 함수를 호출하면서 호출한 함수에 인수를 전달해줄 수 있다.</p>
<h3 id="유사배열-객체에-배열-메서드-사용"><a href="#유사배열-객체에-배열-메서드-사용" class="headerlink" title="유사배열 객체에 배열 메서드 사용"></a>유사배열 객체에 배열 메서드 사용</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">convertArgsToArray</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// arguments 객체를 배열로 변환</span></span><br><span class="line">  <span class="comment">// Array.prototype.slice를 인수없이 호출하면 배열의 복사본을 생성한다.</span></span><br><span class="line">  <span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// const arr = Array.prototype.slice.apply(arguments);</span></span><br><span class="line">  <span class="comment">// const arr = Array.from(arguments)</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(arr);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">convertArgsToArray</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>arguments 객체는 배열이 아니므로 배열 메서드를 사용할 수 없지만 apply, call 메서드를 사용하면 가능하다.</li>
</ul>
<blockquote>
<p>새로 나온 Array.from() 정적 메서드를 사용할 수 있다. 하지만 arguments 객체를 잘 안쓴다.</p>
</blockquote>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getThisBinding</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this로 사용할 객체</span></span><br><span class="line"><span class="keyword">const</span> thisArg = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bind 메서드는 첫 번째 인수로 전달한 thisArg로 this 바인딩이 교체된</span></span><br><span class="line"><span class="comment">// getThisBinding 함수를 새롭게 생성해 반환한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">bind</span>(thisArg)); <span class="comment">// getThisBinding</span></span><br><span class="line"><span class="comment">// bind 메서드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(getThisBinding.<span class="title function_">bind</span>(thisArg)()); <span class="comment">// &#123;a: 1&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>bind 메서드는 함수를 호출하지 않고 인수로 전달받은 객체로 this 바인딩이 교체된 함수를 새롭게 생성하여 반환한다.</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// ①</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(callback, <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>); <span class="comment">// ② Hi! my name is .</span></span><br><span class="line">  <span class="comment">// 일반 함수로 호출된 콜백 함수 내부의 this.name은 브라우저 환경에서 window.name과 같다.</span></span><br><span class="line">  <span class="comment">// 브라우저 환경에서 window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이며 기본값은 &#x27;&#x27;이다.</span></span><br><span class="line">  <span class="comment">// Node.js 환경에서 this.name은 undefined다.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>person.foo의 콜백함수가 호출되기 전 1의 시점에서 this는 foo 메서드를 호출한 객체(person)를 가리킨다.</li>
<li>그러나 person.foo의 콜백함수가 일반 함수로서 호출된 2의 시점에서 this는 전역객체 windows를 가리킨다.</li>
<li>person.foo의 콜백함수는 헬퍼함수로 person.foo를 돕는 역할을 하기 때문에 서로의 this가 같아야한다.</li>
</ul>
<p>이 때, bind 메서드를 사용하여 this를 일치시킨다.</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Lee&quot;</span>,</span><br><span class="line">  <span class="title function_">foo</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    <span class="comment">// bind 메서드로 callback 함수 내부의 this 바인딩을 전달</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(callback.<span class="title function_">bind</span>(<span class="variable language_">this</span>), <span class="number">100</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Hi! my name is <span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span>.`</span>); <span class="comment">// Hi! my name is Lee.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>callback 함수에 this가 바인딩된 새로운 함수를 반환</li>
</ul>
<p><strong>코드해설</strong></p>
<p>즉, foo안의 this는 person 객체를가리키는데, 콜백함수 호출하면 this가 window를 가리킨다. 그러므로 bind함수를 사용하여 foo 메서드가 가리키는 this를 callback 함수에 바인딩해줘서 콜백함수가 가리키는 this와 일치 시켜준다.</p>
<blockquote>
<p>bind, call, apply, that으로 this 바인딩을 일치 시켜주는 것 보다 화살표 함수를 사용하는 것이 간편하다. 하지만 여러 가지 방식에 대해서도 알아두자.</p>
</blockquote>
<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this 바인딩</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메서드 호출</td>
<td>메서드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수 호출</td>
<td>생성자 함수가 (미래에) 생성할 인스턴스</td>
</tr>
<tr>
<td>Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 의한 간접호출</td>
<td>Function.prototype.apply&#x2F;call&#x2F;bind 메서드에 첫번째로 전달한 객체</td>
</tr>
</tbody></table>

                    
                        


                    
                    
                        <p>
                            <a
                                href="/2022/08/19/JavaScript/this/#post-footer"
                                class="postShorten-excerpt_link link"
                                aria-label=""
                            >
                                댓글 공유
                            </a>
                        </p>
                    
                </div>
            
        </div>
        
    </article>
    
    <div class="pagination-bar">
    <ul class="pagination">
        
          <li class="pagination-prev">
            <a
                class="btn btn--default btn--small"
                href="/categories/Javascript/"
                aria-label="최근 포스트"
            >
              <i class="fa fa-angle-left text-base icon-mr"></i>
              <span>최근 포스트</span>
            </a>
          </li>
        
        
        <li class="pagination-number">page 2 of 2</li>
    </ul>
</div>

</section>



                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2023 loco9939. All Rights Reserved.
    </span>
</footer>

            </div>
            
        </div>
        


<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <h4 id="about-card-name">loco9939</h4>
        
            <div id="about-card-bio"><p>author.bio</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>author.job</p>

            </div>
        
        
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-wcqoifde3xwnijjx9xd2irfrrksglozwqpgaqfvxoft22e4znrk7db1xxnsx.min.js"></script>

<!--SCRIPTS END-->





    </body>
</html>
