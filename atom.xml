<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Loco&#39;s Dev Blog</title>
  
  <subtitle>Frontend Developer</subtitle>
  <link href="https://loco9939.github.io/atom.xml" rel="self"/>
  
  <link href="https://loco9939.github.io/"/>
  <updated>2023-02-06T07:36:36.987Z</updated>
  <id>https://loco9939.github.io/</id>
  
  <author>
    <name>loco9939</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>useEffect로 이전 상태 기반하여 상태 업데이트 하기</title>
    <link href="https://loco9939.github.io/2023/02/06/React/useEffect%EB%A1%9C-%EC%9D%B4%EC%A0%84-%EC%83%81%ED%83%9C-%EA%B8%B0%EB%B0%98%ED%95%98%EC%97%AC-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EA%B8%B0/useEffect%EB%A1%9C-%EC%9D%B4%EC%A0%84-%EC%83%81%ED%83%9C-%EA%B8%B0%EB%B0%98%ED%95%98%EC%97%AC-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EA%B8%B0/"/>
    <id>https://loco9939.github.io/2023/02/06/React/useEffect%EB%A1%9C-%EC%9D%B4%EC%A0%84-%EC%83%81%ED%83%9C-%EA%B8%B0%EB%B0%98%ED%95%98%EC%97%AC-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EA%B8%B0/useEffect%EB%A1%9C-%EC%9D%B4%EC%A0%84-%EC%83%81%ED%83%9C-%EA%B8%B0%EB%B0%98%ED%95%98%EC%97%AC-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%98%EA%B8%B0/</id>
    <published>2023-02-06T07:24:27.000Z</published>
    <updated>2023-02-06T07:36:36.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="useEffect란"><a href="#useEffect란" class="headerlink" title="useEffect란?"></a>useEffect란?</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(setup, dependencies?)</span><br></pre></td></tr></table></figure><p>외부 시스템과 컴포넌트를 동기화 하는데 사용하는 React Hook이다. <strong>즉, 외부 시스템과 동기화하는 작업이 아니라면 useEffect를 사용하지 않는 것이 좋다.</strong></p><h2 id="params"><a href="#params" class="headerlink" title="params"></a>params</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>Effect 로직 함수로, 선택적으로 cleanup 함수를 반환할 수 있다.</p><ul><li>컴포넌트가 처음 DOM에 추가 되었을 때, setup 함수가 실행된다.</li><li>의존성이 변경되어 리렌더링이 발생한 이후, <span style='color:red;'>리액트는 이전 값으로 cleanup 함수 먼저 실행하고 새로운 값으로 setup 함수를 실행한다.</span></li><li><strong>컴포넌트가 DOM에서 제거된 후, 리액트는 클린업 함수를 한 번 실행한다.</strong></li></ul><h3 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies?"></a>dependencies?</h3><p>setup 함수 코드 내부와 관련된 리액트 값들의 리스트이다. 리액트 값들은 컴포넌트 내부에서 선언된 props, state, 변수, 함수들을 의미한다.</p><ul><li>리액트는 이전 값과 dependencies를 Object.is() 메서드로 비교한다.</li><li>만약 dependencies를 명확히 기재하지 않는다면, 컴포넌트 리렌더링이 발생할 때마다 Effect가 다시 실행된다.</li></ul><h2 id="이전-상태를-기반으로-useEffect로-상태-업데이트-하기"><a href="#이전-상태를-기반으로-useEffect로-상태-업데이트-하기" class="headerlink" title="이전 상태를 기반으로 useEffect로 상태 업데이트 하기"></a>이전 상태를 기반으로 useEffect로 상태 업데이트 하기</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slider.js - 의존성 있는 경우</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setIndex</span>(index + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, [index]);</span><br></pre></td></tr></table></figure><p>위 코드는 slider 프로젝트를 제작하다가 나온 코드이다. setInterval을 Effect 로직에 사용하였는데, 의존성으로 indexrk 있어 index가 변경될 때마다 해당 Effect 로직이 cleanup되고 setup되고를 반복하게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// slieder.js - 의존성 빈 배열인 경우</span></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">setIndex</span>(<span class="function">(<span class="params">i</span>) =&gt;</span> i + <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p>위와 같이 바꿀 경우 코드는 동일하게 동작하지만, 이전 상태를 기반으로 상태를 업데이트할 때에는 이전 값을 직접 넣어주기보단 updater 함수를 콜백함수로 전달해줌으로서 의존성 데이터를 줄일 수 있다.</p><p><strong>그 결과, 처음 컴포넌트가 렌더링되고 한번만 실행되기 때문에 불필요한 setup과 cleanup 과정을 줄일 수 있다.</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;useEffect란&quot;&gt;&lt;a href=&quot;#useEffect란&quot; class=&quot;headerlink&quot; title=&quot;useEffect란?&quot;&gt;&lt;/a&gt;useEffect란?&lt;/h1&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    <category term="React" scheme="https://loco9939.github.io/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>&lt;Suspense&gt; 컴포넌트는 무엇인가?</title>
    <link href="https://loco9939.github.io/2023/02/02/React/Suspense-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/Suspense-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/"/>
    <id>https://loco9939.github.io/2023/02/02/React/Suspense-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/Suspense-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80/</id>
    <published>2023-02-02T07:29:47.000Z</published>
    <updated>2023-02-02T08:19:14.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="컴포넌트란"><a href="#컴포넌트란" class="headerlink" title=" 컴포넌트란?"></a><Suspense> 컴포넌트란?</h1><p>자식 요소가 로딩중이 완료될 때 까지 fallback에 제공된 컴포넌트를 보여준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="주의사항"><a href="#주의사항" class="headerlink" title="주의사항"></a>주의사항</h2><ul><li>리액트는 처음 마운트 되기 전에 렌더링이 중단된다면, 어떤 상태도 보존하지 않는다. 컴포넌트가 로드되면 리액트는 중단된 트리를 처음부터 렌더링을 시도한다.</li><li><Suspense> 컴포넌트는 컴포넌트 내부에서 startTransition이나 useDeferredValue로 인한 업데이트가 아닌 경우라면 fallback이 표시된다.</li><li>컴포넌트가 다시 일시 중단되었기 때문에 이미 보여진 컨텐츠를 감출 필요가 있다면, layout effect를 비운다. 다시 컨텐츠를 보여줄 준비가 됐을 때, 리액트는 layout effect를 발생시킨다. 이는 컨텐츠가 숨겨진 동안 DOM layout을 측정하지 않도록 한다.</li></ul><h2 id="사용법"><a href="#사용법" class="headerlink" title="사용법"></a>사용법</h2><p>컨텐츠가 로딩되는 동안에 fallback을 보여준다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Suspense</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Albums</span> <span class="keyword">from</span> <span class="string">&quot;./Albums.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ArtistPage</span>(<span class="params">&#123; artist &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;artist.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loading</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Albums</span> <span class="attr">artistId</span>=<span class="string">&#123;artist.id&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Loading</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>🌀 Loading...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="컨텐츠를-한번에-공개"><a href="#컨텐츠를-한번에-공개" class="headerlink" title="컨텐츠를 한번에 공개"></a>컨텐츠를 한번에 공개</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Biography</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Panel</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Albums</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Panel</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure><p><Suspense> 내부에 하나의 컴포넌트라도 일시중단 되더라도 <strong>모든 하위 컴포넌트가 대기했다가 한번에 공개된다.</strong></p><h3 id="가장-가까운-의-fallback을-보여준다"><a href="#가장-가까운-의-fallback을-보여준다" class="headerlink" title="가장 가까운 의 fallback을 보여준다."></a>가장 가까운 <Suspense>의 fallback을 보여준다.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">Loading</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Details</span> <span class="attr">artistId</span>=<span class="string">&#123;artist.id&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Details</span>(<span class="params">&#123; artistId &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Biography</span> <span class="attr">artistId</span>=<span class="string">&#123;artistId&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Panel</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Albums</span> <span class="attr">artistId</span>=<span class="string">&#123;artistId&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Panel</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>때문에 직접적인 자식이 아니더라도 Biography와 Albums와 가장 가까운 부모 <Suspense> 경계를 공유하기 때문에 함께 표시된다.</p><h3 id="로드-될-때-중첩된-컨텐츠-표시한다"><a href="#로드-될-때-중첩된-컨텐츠-표시한다" class="headerlink" title="로드 될 때, 중첩된 컨텐츠 표시한다."></a>로드 될 때, 중첩된 컨텐츠 표시한다.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Suspense</span> fallback=&#123;<span class="language-xml"><span class="tag">&lt;<span class="name">BigSpinner</span> /&gt;</span></span>&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Biography</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">AlbumsGlimmer</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Panel</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Albums</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Panel</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Suspense</span>&gt;</span><br></pre></td></tr></table></figure><p>처음에 Biography가 로딩이 완료 되지 않았을 때, BigSpinner가 fallback으로 보여지고, 이후 Biography는 로딩이 완료되었기 때문에 보여지고, 아래 Albums이 로딩이 완료되지 않았다면 AlbumsGlimmer를 보여주고 있다가 로딩이 완료되어 Albums를 보여준다.</p><p>핵심은 Biography가 Albums 로딩이 완료될 때까지 기다리지 않는 다는 것이다.</p><h3 id="이미-공개된-컨텐츠가-숨겨지는-것을-방지하기"><a href="#이미-공개된-컨텐츠가-숨겨지는-것을-방지하기" class="headerlink" title="이미 공개된 컨텐츠가 숨겨지는 것을 방지하기"></a>이미 공개된 컨텐츠가 숨겨지는 것을 방지하기</h3><p><a href="https://codesandbox.io/s/0lgig0?file=/App.js&utm_medium=sandpack">Code Example Link</a></p><ul><li><Suspense> 내부에 startTransition이 사용되었다면, <span style="color:red;">fallback이 보여지지 않는다.</span></li><li>때문에 fallback의 BigSpinner에 의해 이전에 보여진 컨텐츠가 숨겨지는 것을 방지할 수 있다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;컴포넌트란&quot;&gt;&lt;a href=&quot;#컴포넌트란&quot; class=&quot;headerlink&quot; title=&quot; 컴포넌트란?&quot;&gt;&lt;/a&gt;&lt;Suspense&gt; 컴포넌트란?&lt;/h1&gt;&lt;p&gt;자식 요소가 로딩중이 완료될 때 까지 fallback에 제공된 컴포넌트를 보여준</summary>
      
    
    
    
    <category term="React" scheme="https://loco9939.github.io/categories/React/"/>
    
    
  </entry>
  
  <entry>
    <title>Context API란 무엇이고 Redux와 어떤 차이가 있나요?</title>
    <link href="https://loco9939.github.io/2023/02/02/CS/Context-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-Redux%EC%99%80-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94/Context-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-Redux%EC%99%80-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/02/02/CS/Context-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-Redux%EC%99%80-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94/Context-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-Redux%EC%99%80-%EC%96%B4%EB%96%A4-%EC%B0%A8%EC%9D%B4%EA%B0%80-%EC%9E%88%EB%82%98%EC%9A%94/</id>
    <published>2023-02-02T06:35:47.000Z</published>
    <updated>2023-02-06T12:12:03.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Context-API란"><a href="#Context-API란" class="headerlink" title="Context API란?"></a>Context API란?</h1><div style="display:flex">    <img src="../../../images/contextapi/context.png" width="200" height="300">    <p style="padding:0 1rem; line-height:1.5;">앱의 규모가 커지고 복잡해짐에 따라 부모 컴포넌트에서 중첩된 자식 컴포넌트에게 데이터나 데이터 변경함수를 전달해줄 때, 몇단계를 걸쳐서 전달해줌으로서 애플리케이션이 더욱 복잡해지는 문제가 발생하였다.<br />    이를 해결하기 위해 context API가 등장하였고, 이로써 props를 단계별로 넘겨주지 않아도 데이터를 제공할 수 있게 되었다. 그 결과 <b>컴포넌트 트리로 묶인 컴포넌트 간 데이터 공유가 수월해졌다.</b>     </p></div><ul><li>리액트에서 제공하는 내장 기능이다.</li></ul><blockquote><p>단, Context API를 사용하게 되면 컴포넌트의 재사용이 어려워지므로 꼭 필요한 경우에만 사용한다.</p></blockquote><h1 id="Redux란"><a href="#Redux란" class="headerlink" title="Redux란?"></a>Redux란?</h1><p>Redux는 action이라는 이벤트를 사용하여 데이터를 관리할 수 있는 상태관리 라이브러리이다.</p><p><img src="/../../../images/contextapi/redux.png" alt="redux"></p><h2 id="리덕스의-3원칙"><a href="#리덕스의-3원칙" class="headerlink" title="리덕스의 3원칙"></a>리덕스의 3원칙</h2><ol><li>단 하나의 store에서 모든 상태가 저장된다.</li><li>store의 상태를 변경하는 유일한 방법은 action 객체를 dispatch하는 방법 뿐이다.</li><li>action에 의한 상태 변경은 순수함수를 통해서만 가능하도록 작성해야 한다.</li></ol><h2 id="리덕스-특징"><a href="#리덕스-특징" class="headerlink" title="리덕스 특징"></a>리덕스 특징</h2><ul><li>thunk, saga와 같은 미들웨어를 추가적으로 설정할 수 있다. 비동기 처리를 Util로 처리 가능</li><li>Redux Devtool Extension을 사용하여 디버깅이 용이하다.</li><li>전역 상태 관리 이외도 로컬스토리지에 상태 저장, 버그 리포트 등의 기능을 제공한다.</li></ul><h2 id="Context-API와-Redux의-차이"><a href="#Context-API와-Redux의-차이" class="headerlink" title="Context API와 Redux의 차이"></a>Context API와 Redux의 차이</h2><table><thead><tr><th></th><th>Context API</th><th>Redux</th></tr></thead><tbody><tr><td>Learning Curve</td><td>쉬움</td><td>어려움</td></tr><tr><td>알아야 할 것들</td><td>적다</td><td>많다</td></tr><tr><td>유지보수성</td><td>작고 간단한 애플리케이션에 적합</td><td>복잡한 애플리케이션에 적합</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Context-API란&quot;&gt;&lt;a href=&quot;#Context-API란&quot; class=&quot;headerlink&quot; title=&quot;Context API란?&quot;&gt;&lt;/a&gt;Context API란?&lt;/h1&gt;&lt;div style=&quot;display:flex&quot;&gt;
    </summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>React에서 map 메서드를 사용할 때, key 프로퍼티를 왜 사용해야하나요?</title>
    <link href="https://loco9939.github.io/2023/02/02/CS/React%EC%97%90%EC%84%9C-map-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-key-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94/React%EC%97%90%EC%84%9C-map-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-key-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/02/02/CS/React%EC%97%90%EC%84%9C-map-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-key-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94/React%EC%97%90%EC%84%9C-map-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%A0-%EB%95%8C-key-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EB%A5%BC-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98%EC%9A%94/</id>
    <published>2023-02-02T06:20:29.000Z</published>
    <updated>2023-02-02T06:32:43.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React에서-key를-사용하는-이유"><a href="#React에서-key를-사용하는-이유" class="headerlink" title="React에서 key를 사용하는 이유"></a>React에서 key를 사용하는 이유</h1><p>리액트에서 배열 데이터와 map 메서드를 사용하여 다수의 컴포넌트를 렌더링할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">&#123; numbers &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;number&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>React 프레임워크는 state, props가 업데이트된 이후의 virtual DOM과 이전의 virtual DOM을 비교하고 변경 사항만 Real DOM에 반영하여 효율적으로 UI를 렌더링한다. <strong>이를 재조정 과정이라고 한다.</strong></p><p>재조정 과정에서 <span style="color:red;">key가 없다면 이전 DOM과 이후 DOM의 요소를 비교하기 어려워지고 O(n^3) 복잡성을 가지는 알고리즘을 사용해야 하기 때문에 성능상 문제가 생길 수 있다.</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React에서-key를-사용하는-이유&quot;&gt;&lt;a href=&quot;#React에서-key를-사용하는-이유&quot; class=&quot;headerlink&quot; title=&quot;React에서 key를 사용하는 이유&quot;&gt;&lt;/a&gt;React에서 key를 사용하는 이유&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>JavaScript 데이터 타입에 대해 설명하라</title>
    <link href="https://loco9939.github.io/2023/02/02/CS/JavaScript-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/JavaScript-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/"/>
    <id>https://loco9939.github.io/2023/02/02/CS/JavaScript-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/JavaScript-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/</id>
    <published>2023-02-02T05:38:32.000Z</published>
    <updated>2023-02-02T06:15:06.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-데이터-타입"><a href="#JavaScript-데이터-타입" class="headerlink" title="JavaScript 데이터 타입"></a>JavaScript 데이터 타입</h1><p>자바스크립트는 크게 2가지의 데이터 타입으로 나뉜다.</p><ol><li><p>원시타입 (Primitive Data Type)</p></li><li><p>객체타입(참조타입) (Object Type, Reference Type)</p></li></ol><p>이 중에서도 원시타입에는 6가지의 타입이 존재하고 그 외의 것들은 모두 객체타입이다.</p><h2 id="Primitive-Data-Type-원시타입"><a href="#Primitive-Data-Type-원시타입" class="headerlink" title="Primitive Data Type (원시타입)"></a>Primitive Data Type (원시타입)</h2><p>원시타입의 종류는 6가지가 있다.</p><ul><li>number (숫자형)</li><li>string (문자형)</li><li>undefined</li><li>null</li><li>boolean (불리언형)</li><li>symbol</li></ul><p><strong>원시 타입의 값은 변경 불가능한 값이며, pass-by-value(값에 의한 전달)이다.</strong></p><h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><p>Javascript에서는 숫자형을 모두 실수로 처리한다. 추가로 아래와 같은 자료도 숫자형이다.</p><ul><li>Infinity : 양의 무한대</li><li>-Infinity : 음의 무한대</li><li>NaN : 산술 연산 불가(Not A Number)</li></ul><blockquote><p>NaN은 자기 자신과 일치하지 않는 유일한 값이다. 그러므로 어떤 값이 NaN인지 판단하기 위해서는 Number.isNaN() 빌트인 함수를 사용하거나 Object.is() 메서드를 사용하여야 한다.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span>; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>.<span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><p>C언어와 다르게 JavaScript의 문자열은 원시타입으로 변경 불가능하다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;World&quot;</span>;</span><br></pre></td></tr></table></figure><p>위 코드에서 str 변수에 ‘World’라는 문자열로 데이터를 수정하는 것이 아니다.<br>임의의 메모리 주소를 갖는 메모리 공간에 ‘World’라는 문자열을 저장하고 변수의 식별자인 str이 새로운 메모리 주소를 가리켜 변수를 <b style="color:red">재할당</b>하는 것이다.</p><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>참, 거짓을 나타내는 자료형이다. 암묵적 불리언 형변환이 발생하면 해당 값들을 false로 바꿔주는 falsy 값들이 있다.</p><h4 id="falsy"><a href="#falsy" class="headerlink" title="falsy"></a>falsy</h4><ul><li>“” (빈문자열)</li><li>undefined</li><li>null</li><li>0, -0</li><li>NaN</li></ul><h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>변수의 선언 단계는 사실 선언단계와 초기화 단계 두 단계로 나눠서 볼 수 있는데, 초기화 단계에서 컴퓨터가 변수가 할당되기 이전에 undefined값으로 변수의 값을 초기화해준다.</p><p>때문에 이는 개발자의 의도가 담긴 것이 아니다.</p><h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>변수의 값이 없다는 것에 개발자의 의도를 담고 싶다면 null을 사용한다. 자바스크립트는 대소문자를 구별하기 때문에 null, Null, NULL 모두 다른 값이다.</p><blockquote><p>함수가 유효한 값을 반환할 수 없는 경우 명시적을 null을 반환하기도 한다.</p></blockquote><p>null 값의 type을 확인하기 위해서는 typeof 연산자를 사용하는 것 대신 일치 연산자(&#x3D;&#x3D;&#x3D;)를 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line">foo === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>심볼은 이름이 충돌한 위험이 없는 유일무이한 원시타입의 값이다. 주로 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="title class_">Symbol</span>(<span class="string">&quot;key&quot;</span>);</span><br><span class="line"><span class="keyword">typeof</span> key; <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[key] = <span class="string">&quot;value&quot;</span>; <span class="comment">// 이름이 충돌할 위험이 없는 유일무이한 값인 심볼을 프로퍼티 키로 사용</span></span><br></pre></td></tr></table></figure><h2 id="Object-Type-Reference-Type-객체타입"><a href="#Object-Type-Reference-Type-객체타입" class="headerlink" title="Object Type, Reference Type (객체타입)"></a>Object Type, Reference Type (객체타입)</h2><p>객체란, 데이터와 그 데이터에 관련된 동작(절차, 방법, 기능 등)을 모두 포함할 수 있는 개념적 존재이다.</p><p>다시말해 데이터를 의미하는 <strong>프로퍼티</strong>와 동작을 의미하는 <strong>메소드</strong>를 포함할 수 있는 독립적 주체이다.</p><p>원시타입을 제외한 나머지 값(배열, 함수, 정규표현식 등)이 모두 객체이다. 객체는 pass-by-reference (참조에 의한 전달)이다.</p><h3 id="얕은-복사와-깊은-복사"><a href="#얕은-복사와-깊은-복사" class="headerlink" title="얕은 복사와 깊은 복사"></a>얕은 복사와 깊은 복사</h3><p>객체는 참조에 의한 전달을 하기 때문에 복사를 객체 데이터를 복사하였을 때, 서로의 참조값을 공유하고 있으므로 변경 사항도 공유되는 특징이 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yiju&quot;</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy_obj = obj;</span><br><span class="line"></span><br><span class="line">copy_obj.<span class="property">name</span> = <span class="string">&quot;loco&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy_obj); <span class="comment">// &#123;name: &#x27;loco&#x27;, age: 29&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &#x27;loco&#x27;, age: 29&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy_obj === obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>때문에 객체를 복사할 때에는 참조값을 다르게 복사해줘야한다. Object.assign 메서드를 사용하거나 ES6에 등장한 Spread 문법을 사용하여 객체를 복사할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&quot;yiju&quot;</span>, <span class="attr">age</span>: <span class="number">29</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy_obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"><span class="keyword">const</span> copy_obj2 = &#123; ...obj &#125;;</span><br><span class="line"></span><br><span class="line">copy_obj.<span class="property">name</span> = <span class="string">&quot;loco&quot;</span>;</span><br><span class="line">copy_obj2.<span class="property">name</span> = <span class="string">&quot;mac&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// &#123;name: &#x27;yiju&#x27;, age: 29&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy_obj); <span class="comment">// &#123;name: &#x27;loco&#x27;, age: 29&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy_obj2); <span class="comment">// &#123;name: &#x27;mac&#x27;, age: 29&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같은 방식을 얕은 복사라고 부른다. <strong>왜냐하면 depth가 1단계 밖에 복사하지 못하기 때문이다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;yiju&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">29</span>,</span><br><span class="line">  <span class="attr">school</span>: &#123; <span class="attr">high</span>: <span class="string">&quot;donghwa&quot;</span>, <span class="attr">univ</span>: <span class="string">&quot;kangwon&quot;</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> copy_obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj);</span><br><span class="line"></span><br><span class="line">copy_obj.<span class="property">age</span> = <span class="number">40</span>;</span><br><span class="line">copy_obj.<span class="property">school</span>.<span class="property">high</span> = <span class="string">&quot;Yebong&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;name:&#x27;yiju&#x27;, age:40, school: &#123;high: &#x27;Yebong&#x27;, univ:&#x27;kangwon&#x27;&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(copy_obj);</span><br><span class="line"><span class="comment">// &#123;name:&#x27;yiju&#x27;, age:29, school: &#123;high: &#x27;Yebong&#x27;, univ:&#x27;kangwon&#x27;&#125;&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure><p>1단계 깊이인 age는 다른 참조값을 공유하지 않지만 2단계 깊이인 school의 객체값은 참조값을 공유하고 있다.</p><p>깊은 복사를 하기 위해서는 재귀적으로 객체 내부를 단계별로 복사를 해줘야 가능하다. 혹은 라이브러리를 사용하여 구현할 수 있다.</p><blockquote><p>JSON.stringify()를 사용할 수 도 있지만 이 방법은 메서드까진 복사할 수 없기 때문에 추천되지 않는다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaScript-데이터-타입&quot;&gt;&lt;a href=&quot;#JavaScript-데이터-타입&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 데이터 타입&quot;&gt;&lt;/a&gt;JavaScript 데이터 타입&lt;/h1&gt;&lt;p&gt;자바스크립트는 크게</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>React Virtual DOM이란?</title>
    <link href="https://loco9939.github.io/2023/01/30/CS/React-Virtual-DOM%EC%9D%B4%EB%9E%80/React-Virtual-DOM%EC%9D%B4%EB%9E%80/"/>
    <id>https://loco9939.github.io/2023/01/30/CS/React-Virtual-DOM%EC%9D%B4%EB%9E%80/React-Virtual-DOM%EC%9D%B4%EB%9E%80/</id>
    <published>2023-01-30T05:00:40.000Z</published>
    <updated>2023-01-30T07:51:27.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Virtual-DOM이란"><a href="#Virtual-DOM이란" class="headerlink" title="Virtual DOM이란?"></a>Virtual DOM이란?</h1><p>Virtual DOM은 Real DOM을 효율적으로 조작하기 위해 가상으로 DOM 구조를 흉내낸 자바스크립트 객체이다.</p><p>가상적인 표현을 메모리에 저장하고 React 같은 프레임워크를 통해 Real DOM과 동기화 하기 위해 사용된다.</p><h2 id="Virtual-DOM-사용하는-이유는"><a href="#Virtual-DOM-사용하는-이유는" class="headerlink" title="Virtual DOM 사용하는 이유는?"></a>Virtual DOM 사용하는 이유는?</h2><p>Real DOM을 조작하여 DOM Tree의 배치가 바뀌면 Real DOM의 재렌더링이 발생하기 때문에 컴퓨터에 부담이 되고 속도가 느려지게 될 것이다.</p><p>그래서 Real DOM과 구조가 똑같은 Virtual DOM을 만들고 DOM 조작이 가해진 요소만 찾아 Real DOM에 변화를 가하는 방법을 사용하여 메모리 상에서만 동작하고 실제 렌더링을 하지 않아 연산 비용을 최소화 할 수 있다.</p><h3 id="React에서-Virtual-DOM-작동원리"><a href="#React에서-Virtual-DOM-작동원리" class="headerlink" title="React에서 Virtual DOM 작동원리"></a>React에서 Virtual DOM 작동원리</h3><ol><li>우리가 UI를 조작하면 React는 Virtual DOM을 생성한다.</li><li>diffing 알고리즘을 통해 이전 Virtual DOM과 변경사항을 비교한다.</li><li>이 때 변경된 부분을 파악하여 Real DOM에 반영하여 변경된 부분만 재렌더링이 발생한다.</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Virtual-DOM이란&quot;&gt;&lt;a href=&quot;#Virtual-DOM이란&quot; class=&quot;headerlink&quot; title=&quot;Virtual DOM이란?&quot;&gt;&lt;/a&gt;Virtual DOM이란?&lt;/h1&gt;&lt;p&gt;Virtual DOM은 Real DOM을 효</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>실행 컨텍스트에 대해 설명해주세요</title>
    <link href="https://loco9939.github.io/2023/01/26/CS/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/26/CS/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94/%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4%EC%A3%BC%EC%84%B8%EC%9A%94/</id>
    <published>2023-01-26T14:23:41.000Z</published>
    <updated>2023-02-06T09:57:50.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="실행-컨텍스트란"><a href="#실행-컨텍스트란" class="headerlink" title="실행 컨텍스트란?"></a>실행 컨텍스트란?</h1><p>자바스크립트에서 실행 컨텍스트는 모든 코드의 동작원리를 담고 있는 핵심 개념이다.</p><p>다음 예시를 실행 컨텍스트 관점으로 설명해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">outer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">inner</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> b = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> inner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> closure = <span class="title function_">outer</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">closure</span>();</span><br></pre></td></tr></table></figure><h2 id="소스코드-평가와-실행"><a href="#소스코드-평가와-실행" class="headerlink" title="소스코드 평가와 실행"></a>소스코드 평가와 실행</h2><h3 id="1-전역-코드-평가"><a href="#1-전역-코드-평가" class="headerlink" title="1. 전역 코드 평가"></a>1. 전역 코드 평가</h3><p><img src="/../../images/../../images/execution/exec1.png" alt="실행컨텍스트1"></p><ol><li>전역 실행 컨텍스트 생성</li><li>var 키워드로 선언된 전역변수 outer는 전역 객체에 등록</li><li>const 키워드로 선언된 전역변수 closure는 선언적 환경 레코드에 등록</li><li>this는 전역 객체 바인딩</li></ol><h3 id="2-전역-코드-실행-단계"><a href="#2-전역-코드-실행-단계" class="headerlink" title="2. 전역 코드 실행 단계"></a>2. 전역 코드 실행 단계</h3><p><img src="/../../images/../../images/execution/exec2.png" alt="실행컨텍스트2"></p><ol><li>outer 우항의 함수를 평가한 뒤, 메모리에 저장한 뒤 전역 객체에서 outer 식별자에 할당</li><li>closure 우항의 outer 함수를 전역 객체에서 찾아 호출</li><li></li></ol><h3 id="3-outer-함수-평가-단계"><a href="#3-outer-함수-평가-단계" class="headerlink" title="3. outer 함수 평가 단계"></a>3. outer 함수 평가 단계</h3><p><img src="/../../images/../../images/execution/exec3.png" alt="실행컨텍스트3"></p><ol><li>outer 함수 실행 컨텍스트 생성</li><li>outer 함수에서 선언된 변수 a, inner를 환경 레코드에 등록</li><li>outer 함수의 외부 렉시컬 환경 참조는 outer 변수에 할당된 익명함수 객체의 내부슬롯 [[Environment]]가 가리키는 외부 렉시컬 환경을 가리킨다.</li></ol><h3 id="4-outer-함수-실행-단계"><a href="#4-outer-함수-실행-단계" class="headerlink" title="4. outer 함수 실행 단계"></a>4. outer 함수 실행 단계</h3><p><img src="/../../images/../../images/execution/exec4.png" alt="실행컨텍스트4"></p><ol><li>outer 함수 환경 레코드의 변수 a에 값 3이 할당된다.</li><li>변수 inner에 익명 함수 객체의 참조값이 할당되고, 익명 함수 객체의 내부 슬롯 [[Environment]]은 정의된 outer 렉시컬 환경을 가리킨다.</li></ol><h3 id="5-전역-코드-실행-단계-복귀"><a href="#5-전역-코드-실행-단계-복귀" class="headerlink" title="5. 전역 코드 실행 단계 복귀"></a>5. 전역 코드 실행 단계 복귀</h3><p><img src="/../../images/../../images/execution/exec5.png" alt="실행컨텍스트5"></p><ol><li>전역 렉시컬 환경의 선언적 환경 레코드에서 closure를 찾는다.</li><li>inner 함수 객체가 closure라는 식별자에 할당된다.</li></ol><h3 id="6-closure-함수-평가-단계"><a href="#6-closure-함수-평가-단계" class="headerlink" title="6. closure 함수 평가 단계"></a>6. closure 함수 평가 단계</h3><p><img src="/../../images/../../images/execution/exec6.png" alt="실행컨텍스트6"></p><ol><li>closure() 문이 실행되면서 closure의 실행 컨텍스트가 생성된다.</li><li>closure를 실행하기 위해 inner 함수 객체를 평가한다.<blockquote><p>즉, closure() 평가단계 &#x3D;&#x3D;&#x3D; inner() 평가단계</p></blockquote></li><li>const로 선언된 변수 b가 closure 환경 레코드에 등록된다.</li><li>화살표 함수의 this는 함수가 정의될 때 상위 스코프의 this로 정적으로 결정된다.</li></ol><h3 id="7-closure-함수-실행-단계"><a href="#7-closure-함수-실행-단계" class="headerlink" title="7. closure 함수 실행 단계"></a>7. closure 함수 실행 단계</h3><p><img src="/../../images/../../images/execution/exec7.png" alt="실행컨텍스트7"></p><ol><li>closure 즉, inner 함수 내부 코드가 실행</li><li>b에 값 5가 할당되고 a+b를 수행하기 위해 스코프 체인에서 a를 찾는다.</li><li>closure 환경 레코드에는 a가 존재하지 않기 때문에 외부 렉시컬 환경 참조를 따라 익명함수 객체로 이동하고, 익명함수 객체의 [[Environment]]내부 슬롯이 가리키는 outer 함수 렉시컬 환경으로 이동된다. 결국 outer 환경 레코드에서 a를 찾을 수 있다.</li><li>a+b 연산을 수행하고 연산값을 반환한다.</li></ol><h3 id="8-closure-실행-컨텍스트-소멸"><a href="#8-closure-실행-컨텍스트-소멸" class="headerlink" title="8. closure 실행 컨텍스트 소멸"></a>8. closure 실행 컨텍스트 소멸</h3><p><img src="/../../images/../../images/execution/exec8.png" alt="실행컨텍스트8"></p><ul><li>closure 함수 코드가 실행을 마치고 closure의 실행 컨텍스트가 pop 되어 더 이상 참조되지 않는 객체들은 Garbage Collector에 의해 메모리가 해제된다.</li></ul><h3 id="9-전역-실행-컨텍스트-소멸"><a href="#9-전역-실행-컨텍스트-소멸" class="headerlink" title="9. 전역 실행 컨텍스트 소멸"></a>9. 전역 실행 컨텍스트 소멸</h3><p><img src="/../../images/../../images/execution/exec9.png" alt="실행컨텍스트9"></p><ul><li>마지막으로 전역 실행컨텍스트가 pop 되어 참조될 수 있는 객체가 없기 때문에 모든 객체가 Garbage Collector에 의해 메모리가 해제된다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;실행-컨텍스트란&quot;&gt;&lt;a href=&quot;#실행-컨텍스트란&quot; class=&quot;headerlink&quot; title=&quot;실행 컨텍스트란?&quot;&gt;&lt;/a&gt;실행 컨텍스트란?&lt;/h1&gt;&lt;p&gt;자바스크립트에서 실행 컨텍스트는 모든 코드의 동작원리를 담고 있는 핵심 개념이다</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>스코프는 무엇인가요?</title>
    <link href="https://loco9939.github.io/2023/01/20/CS/%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/20/CS/%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/%EC%8A%A4%EC%BD%94%ED%94%84%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</id>
    <published>2023-01-20T01:30:56.000Z</published>
    <updated>2023-01-20T01:32:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="스코프"><a href="#스코프" class="headerlink" title="스코프"></a>스코프</h1><p>스코프란, 식별자가 참조할 수 있는 범위(유효범위)를 말한다. 자바스크립트 엔진이 식별자를 찾기 위해 사용하는 규칙이다.</p><ul><li>모든 식별자는 자신이 선언된 위치에 의해 상위 스코프를 결정한다.</li><li>식별자는 어떤 값을 구별하기 위해 유일 해야하므로 <span style="color:red">중복될 수 없다.</span> 단, 스코프가 다르면 중복될 수 있다.</li></ul><h2 id="지역-스코프"><a href="#지역-스코프" class="headerlink" title="지역 스코프"></a>지역 스코프</h2><p>자바스크립트는 함수 레벨 스코프를 갖는다. 그러므로 지역이란, 함수 몸체 내부를 말한다.</p><p>즉, 지역 스코프는 함수에 의해서 생성된다.</p><blockquote><p>let, const가 나오면서 블록 레벨 스코프를 갖는 식별자를 선언할 수 있다. 여기서 지역 스코프는 코드 블록에 의해 생성된다.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure><p>var 키워드는 함수 레벨 스코프를 갖는다. 즉, 함수 몸체 내부에서 var 키워드로 선언된 변수는 지역 스코프 범위를 참조할 수 있다. 함수 몸체 이외에서 선언된 변수는 모드 전역 스코프 범위로 본다.</p><h2 id="스코프-체인"><a href="#스코프-체인" class="headerlink" title="스코프 체인"></a>스코프 체인</h2><p>스코프는 함수의 중첩에 의해 계층적 구조를 갖는다. 모든 스코프는 하나의 계층적 구조로 연결된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>; <span class="comment">// 전역 스코프</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outer</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inner</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> x = -<span class="number">100</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 100</span></span><br><span class="line">  <span class="title function_">inner</span>(); <span class="comment">// -100</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x); <span class="comment">// 10</span></span><br><span class="line"><span class="title function_">outer</span>();</span><br></pre></td></tr></table></figure><ol><li><p>전역 스코프 (최상위 스코프)</p></li><li><p>outer 지역 스코프</p></li><li><p>inner 지역 스코프</p></li></ol><p>자바스크립트 엔진은 변수를 참조하는 스코프에서 시작하여 <span style="color:red">상위 스코프 방향</span>으로 이동하며 변수를 검색한다.</p><blockquote><p>실제 자바스크립트 엔진은 코드를 실행하기 전 렉시컬 환경이라는 자료구조를 생성한다. 변수 선언이 실행되면 변수 식별자가 자료구조의 key로 등록되고 변수 할당이 일어나면 변수 식별자에 해당하는 값을 변경한다.</p></blockquote><h2 id="렉시컬-스코프"><a href="#렉시컬-스코프" class="headerlink" title="렉시컬 스코프"></a>렉시컬 스코프</h2><p>렉시컬 스코프란, 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정된다.</p><p><span style="color:red">함수 호출이 아닌</span> 함수 정의(함수 선언문, 함수 표현식)가 실행되어 생성된 함수 객체는 자신이 정의된 스코프인 상위 스코프를 기억한다.</p><blockquote><p>즉, 내가(함수가) 정의된 스코프가 자신의 상위 스코드이다.</p></blockquote><hr><h1 id="전역변수와-var-키워드"><a href="#전역변수와-var-키워드" class="headerlink" title="전역변수와 var 키워드"></a>전역변수와 var 키워드</h1><p>변수는 생명주기가 있어 선언에 의해 생성되고 언젠가 소멸한다. 소멸하는 시점은 스코프에 따라 다르다.</p><ul><li><p>전역변수 : 런타임 이전에 자바스크립트 엔진에 의해 선언되고 애플리케이션이 종료되면 소멸한다.</p></li><li><p>지역변수 : 함수가 호출될 때 생성되고 함수가 종료하면 소멸한다. 함수가 호출되는 순간 함수 몸체에 있는 선언들이 호이스팅 된다.</p></li></ul><h2 id="전역변수의-문제점"><a href="#전역변수의-문제점" class="headerlink" title="전역변수의 문제점"></a>전역변수의 문제점</h2><ol><li><p>암묵적 결합<br>어디서든 참조하고 변경할 수 있어 의도치 않게 변경될 수 있다.</p></li><li><p>긴 생명주기</p></li></ol><p>메모리 자원도 오랜 기간 소비한다. 1번의 위험이 오래 지속되어 오류의 기회가 많아진다.</p><ol start="3"><li>네임 스페이스 오염</li></ol><p>자바스크립트는 파일을 분리해도 전역 스코프를 공유한다는 점에서 다른 파일에서 동일한 이름의 전역 변수끼리 충돌이 일어날 수 있다.</p><blockquote><p>그러므로 전역변수를 꼭 써야하는 상황이 아니라면 사용하지 말자.</p></blockquote><h2 id="전역변수-사용-억제-방법"><a href="#전역변수-사용-억제-방법" class="headerlink" title="전역변수 사용 억제 방법"></a>전역변수 사용 억제 방법</h2><ol><li><p>즉시실행함수<br>즉시실행함수를만들어 함수 종료 시 변수도 사라져 메모리 해제도 빨리 되고 지역 스코프를 가져 충돌의 위험을 줄일 수 있다.</p></li><li><p>모듈패턴<br>클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시실행함수로 감싸 하나의 모듈로 만든다.</p></li></ol><p>전역변수 억제와 캡슐화까지 가능하다.</p><blockquote><p>캡슐화란, 객체의 상태를 나타내는 프로퍼티와 프로퍼티를 참조하고 조작할 수 있는 메서드를 하나로 묶는 것을 말한다. 객체의 특정 프로퍼티나 메서드를 감출 목적으로 사용하기도 한다.(정보은닉)</p></blockquote><h1 id="var-키워드"><a href="#var-키워드" class="headerlink" title="var 키워드"></a>var 키워드</h1><p>var 키워드는 함수 레벨 스코프를 따른다. 함수 몸체 외부에서 var 키워드로 선언시 전역 변수로 선언되고 전역 스코프를 갖는다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">// 10;</span></span><br></pre></td></tr></table></figure><p>var 키워드는 전역에서 선언시 전역 객체의 프로퍼티로 등록된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  z = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure><p>키워드로 선언되지 않은 변수는 어디에서든지 항상 전역 변수이다.</p><p>선언되지 않은 변수는 해당 코드가 실행되어야 존재한다.</p><blockquote><p>키워드 없이 선언하는 것은 옳지 않다.</p></blockquote><p><span style="font-size:1.2rem">러버덕하면서 알게된 내용</span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, <span class="string">&quot;x&quot;</span>); <span class="comment">//  &#123;value: 100, writable: true, enumerable: true, configurable: false&#125;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(<span class="variable language_">window</span>, <span class="string">&quot;y&quot;</span>); <span class="comment">// &#123;value: 50, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure><p>var 키워드로 선언된 변수와 암묵적 선언으로 선언된 변수 모두 전역 객체의 프로퍼티로 등록된다.</p><p>하지만, 객체의 프로퍼티를 보면 configurable 값이 다른 것을 볼 수 있는데, 이것이 true이면 재정의(삭제, 변경)가 가능하다는 의미이다.</p><p>따라서 암묵적 선언으로 전역 객체의 프로퍼티로 등록이 되면 재정의가 가능하므로 암묵적 선언은 사용하지 않는 것이 좋다.</p><hr><h1 id="let-const-키워드"><a href="#let-const-키워드" class="headerlink" title="let, const 키워드"></a>let, const 키워드</h1><p>let, const 키워드는 블록 레벨 스코프를 따른다. 그러므로 var 키워드의 함수 레벨 스코프보다 더 한정적인 스코프를 지원하여 작은 범위의 스코프를 다룰 수 있어 유용하다.</p><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>var 키워드와 비교하여 let 키워드를 알아보자.</p><ol><li><p>변수 중복 선언 금지</p></li><li><p>블록 레벨 스코프</p></li></ol><p>let 키워드로 선언한 전역변수는 전역객체의 프로퍼티가 아니다. 전역 객체의 프로퍼티가 되는 것들은 var 키워드로 선언한 전역변수 및 전역함수, 그리고 선언하지 않는 변수에 값을 할당한 암묵적 전역이 있다. 이에 대해서는 실행 컨텍스트에 대해 배울 때 자세히 배우자.</p><ol start="3"><li>변수 호이스팅</li></ol><p>var 키워드로 선언한 변수는 선언단계와 초기화 단계가 동시에 진행된다. 하지만 let 키워드로 선언한 변수는 선언단계와 초기화 단계가 분리되어 진행된다.</p><p>선언단계가 자바스크립트 엔진에 의해 실행되고 <span style="color:red">초기화 단계는 변수 선언문에 도달했을 때</span>, 실행된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// Uncaught ReferenceError: b is not defined</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br></pre></td></tr></table></figure><p>언뜻보면 let 키워드는 호이스팅이 일어나지 않는 것처럼 보이지만, 선언단계는 호이스팅이 되어 최상단에서 먼저 실행되었고 초기화 단계는 선언문에 도달했을 경우 진행되기 때문에 위와 같은 현상이 발생하는 것이다.</p><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>let 키워드와 비교해서 알아보자</p><ol><li>선언과 초기화</li></ol><p>const 키워드로 선언한 변수는 개발자가 선언과 초기화를 동시에 해야한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="number">1</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz; <span class="comment">// Uncaught SyntaxError : Unexpected identifier</span></span><br></pre></td></tr></table></figure><p>이전에 선언을 하면 선언단계와 초기화 단계가 진행된다 그랬었는데, 이것도 초기화가 맞지만 const를 사용하기 위해서는 개발자가 직접 초기화를 해줘야한다. 만약 초기화를 해주지 않고 나중에 값을 할당한다는 것이 재할당으로 해석되기 때문이다.</p><ol start="2"><li>재할당 금지</li></ol><p>const 키워드로 선언한 변수에 원시값을 할당하면 값을 변경할 수 없다. 하지만 객체를 할당한 경우 값을 변경할 수 있다. 재할당 금지라는 말이 불변을 의미하지는 않는다. 왜냐하면 식별자가 가리키는 메모리 주소 공간은 참조값이 저장되어 있고 객체를 변경하여도 참조값은 변하지 않기 때문이다.</p><ol start="3"><li>상수</li></ol><p>변하지 않는 값을 사용하기 위해 우리는 상수를 사용한다.</p><p>주로 상수의 이름은 대문자로 사용한다. 원시값을 할당한 경우 원시값은 변경 불가능한 값이고 재할당이 금지되므로 할당된 값을 변경할 방법은 없다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;스코프&quot;&gt;&lt;a href=&quot;#스코프&quot; class=&quot;headerlink&quot; title=&quot;스코프&quot;&gt;&lt;/a&gt;스코프&lt;/h1&gt;&lt;p&gt;스코프란, 식별자가 참조할 수 있는 범위(유효범위)를 말한다. 자바스크립트 엔진이 식별자를 찾기 위해 사용하는 규칙이다</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>프로세스와 스레드의 차이점은?</title>
    <link href="https://loco9939.github.io/2023/01/19/CS/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80/"/>
    <id>https://loco9939.github.io/2023/01/19/CS/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90%EC%9D%80/</id>
    <published>2023-01-19T06:12:28.000Z</published>
    <updated>2023-02-06T09:59:23.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="프로세스와-스레드는-무엇인가요"><a href="#프로세스와-스레드는-무엇인가요" class="headerlink" title="프로세스와 스레드는 무엇인가요?"></a>프로세스와 스레드는 무엇인가요?</h1><p><strong>프로세스란?</strong> 작업의 단위로써, 작업을 관리하는 주체는 OS이다. 프로세스는 최소 1개의 스레드(thread)를 가진다.</p><p>컴퓨터가 명령을 받게되면 명령을 실행하면서 연산코드의 흐름이 생겨난다. <span style="color:red;">이 때의 흐름을 스레드라고 한다.</span></p><p><strong>즉, 스레드가 실질적으로 연산을 하는 주체가 된다.</strong></p><p>기본적으로 프로세스 흐름(스레드)은 1개이다. 그런데 흐름이 n개 일 수 있는데, 이런 경우를 멀티 스레딩(Multi-threading)라고 한다.</p><p>멀티 스레딩은 동시성과 동기화라는 특징이 있는데 이는 아래 예시를 통해 설명할 수 있다.</p><blockquote><p>만약 프로세스가 여러 개라면 멀티 태스킹(Multi-tasking)이라고 한다.</p></blockquote><h2 id="프로세스와-스레드-비유-설명"><a href="#프로세스와-스레드-비유-설명" class="headerlink" title="프로세스와 스레드 비유 설명"></a>프로세스와 스레드 비유 설명</h2><p><img src="/../../images/../../images/processandthread/process_thread.png" alt="프로세스와 스레드 비유 설명"></p><p>한 가구(Process)가 있다고 하자. 해당 가구는 집(Virtual Memory)이라는 공간에 살게된다. 한 가구안에 세대원(Thread) 3명이 있다고 하자.</p><p>집 안에는 세대원들이 각자 방(Thread Local Storage)을 하나씩 사용한다. 뿐만 아니라 Thread마다 Stack 자료구조로 관리되는 메모리 공간이 따로 있다.</p><p>각자 방은 본인만 사용 가능하고 거실, 화장실, 부엌은 공용공간(Heap)이다.</p><h2 id="프로세스와-스레드-작동원리"><a href="#프로세스와-스레드-작동원리" class="headerlink" title="프로세스와 스레드 작동원리"></a>프로세스와 스레드 작동원리</h2><p><img src="/../../images/../../images/processandthread/procee_thread_logic.png" alt="프로세스와 스레드 작동원리"></p><ol><li><p>Process가 Thread를 처리하기 위해서는 CPU와 메모리(연습장)가 필요하는데 이를 관리해주는 것이 바로 OS가 하는 일이다.</p></li><li><p>이 때 Process는 실제 메모리를 사용하지 않고 RAM(1차 메모리)과 HDD(2차 메모리)를 추상화한 Virtual Memory를 사용한다.</p></li><li><p>Virtual Memory는 RAM과 연결된 부분이 있을 수도 있고 HDD와 연결된 부분이 있을 수도 있다. RAM이 부족해서 연결하지 못하는 것보단 HDD라도 연결해주는 것이 낫기 때문이다.</p></li></ol><p>OS가 Virtual Memory를 Process에게 할당해준다. 때문에 Process 내부의 Thread는 작동범위가 Virtual Memory로 제한된다.</p><h1 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h1><p><a href="https://www.youtube.com/watch?v=x-Lp-h_pf9Q&t=58s">유튜브 널널한 개발자 - Process와 Thread 차이</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;프로세스와-스레드는-무엇인가요&quot;&gt;&lt;a href=&quot;#프로세스와-스레드는-무엇인가요&quot; class=&quot;headerlink&quot; title=&quot;프로세스와 스레드는 무엇인가요?&quot;&gt;&lt;/a&gt;프로세스와 스레드는 무엇인가요?&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;프로세스</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>1.1 + 0.1 === 1.2 가 틀린 이유는?</title>
    <link href="https://loco9939.github.io/2023/01/19/CS/1-1-0-1-1-2-%EA%B0%80-%ED%8B%80%EB%A6%B0-%EC%9D%B4%EC%9C%A0%EB%8A%94/1-1-0-1-1-2-%EA%B0%80-%ED%8B%80%EB%A6%B0-%EC%9D%B4%EC%9C%A0%EB%8A%94/"/>
    <id>https://loco9939.github.io/2023/01/19/CS/1-1-0-1-1-2-%EA%B0%80-%ED%8B%80%EB%A6%B0-%EC%9D%B4%EC%9C%A0%EB%8A%94/1-1-0-1-1-2-%EA%B0%80-%ED%8B%80%EB%A6%B0-%EC%9D%B4%EC%9C%A0%EB%8A%94/</id>
    <published>2023-01-19T05:35:22.000Z</published>
    <updated>2023-02-06T10:00:25.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-1은-우리-눈에-보이는-0-1이-아니다"><a href="#0-1은-우리-눈에-보이는-0-1이-아니다" class="headerlink" title="0.1은 우리 눈에 보이는 0.1이 아니다?"></a>0.1은 우리 눈에 보이는 0.1이 아니다?</h1><p>컴퓨터는 데이터를 RAM이라는 곳에 임시 저장한 뒤 CPU가 꺼내와서 데이터를 연산한다.</p><p>RAM에 데이터를 저장할 때 2진수로 저장을 하는데, 정수가 아닌 소수를 저장할 때는 다음과 같은 방식으로 저장한다.</p><p>ex) 5.125 -&gt; 101.001 -&gt; 1.01001 * 2^2</p><p><img src="/../../images/../../images/primenum/example.png" alt="컴퓨터가 소수 저장하는 원리"></p><ol><li>32칸의 공간을 마련한 뒤 첫칸에 부호를 나타내는 숫자를 적어둔다. (양수:0, 음수:1)</li><li>소수점 우측 부분을 mantissa 부분으로, 정수부분 8칸 공간 뒤에 23칸에 넣어준다.</li><li>지수에다가 127을 더한 뒤 2진법으로 만들고(2+127 -&gt; 10000001) 이를 맨 앞 8칸에다가 넣어준다.</li></ol><h2 id="순환소수"><a href="#순환소수" class="headerlink" title="순환소수"></a>순환소수</h2><p>하지만 0.1같은 소수는 32칸으로 표현할 수 없는 무한한 소수점 이하의 값을 가진다. <strong>그러므로 컴퓨터는 32칸까지만 표시를 해주고 뒤의 값은 무시한다.</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line">a + b === <span class="number">1.2</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>32칸뒤에 잘려나간 부분때문에 오차가 발생하여 위 비교식이 false가 판단된다.</p><h2 id="정리"><a href="#정리" class="headerlink" title="정리"></a>정리</h2><h3 id="정확히-계산하기-위해서는-정수를-사용하자"><a href="#정확히-계산하기-위해서는-정수를-사용하자" class="headerlink" title="정확히 계산하기 위해서는 정수를 사용하자."></a>정확히 계산하기 위해서는 정수를 사용하자.</h3><p>1m를 표시하는데, 1.2m를 표시하는 것을 변수에 그대로 담지 말고, mm로 단위를 통일하고 1200를 변수에 담자.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-1은-우리-눈에-보이는-0-1이-아니다&quot;&gt;&lt;a href=&quot;#0-1은-우리-눈에-보이는-0-1이-아니다&quot; class=&quot;headerlink&quot; title=&quot;0.1은 우리 눈에 보이는 0.1이 아니다?&quot;&gt;&lt;/a&gt;0.1은 우리 눈에 보이는 0</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>REST API란 무엇인가요?</title>
    <link href="https://loco9939.github.io/2023/01/18/CS/REST-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/REST-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/18/CS/REST-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/REST-API%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</id>
    <published>2023-01-18T05:30:25.000Z</published>
    <updated>2023-01-18T14:39:17.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="REST-API란-무엇인가요"><a href="#REST-API란-무엇인가요" class="headerlink" title="REST API란 무엇인가요?"></a>REST API란 무엇인가요?</h1><p>자원의 이름으로 구분하여 해당 자원의 상태(정보)를 주고 받는 것을 의미한다. REST API는 HTTP 프로토콜을 의도에 맞게 디자인 하도록 유도하고 있다.</p><p>즉, REST는 HTTP를 기반으로 클라이언트가 서버의 리소스에 접근하는 방식을 규정한 아키텍처이고 REST API는 REST를 기반으로 서비스 API를 구현한 것이다.</p><h2 id="REST-API의-구성"><a href="#REST-API의-구성" class="headerlink" title="REST API의 구성"></a>REST API의 구성</h2><ul><li>자원 : 모든 자원에는 고유한 ID가 존재하고 ID는 &#x2F;store&#x2F;:store_ID와 같은 HTTP URI이다.</li><li>행위 : 자원에 대한 행위 (HTTP 요청 메서드)</li><li>표현 : 자원에 대한 행위의 구체적 내용 (페이로드, JSON)</li></ul><h2 id="REST-API-설계-규칙"><a href="#REST-API-설계-규칙" class="headerlink" title="REST API 설계 규칙"></a>REST API 설계 규칙</h2><h3 id="1-URI는-리소스를-표현하는데-집중하고-마지막에-슬래시-포함하지-않는다"><a href="#1-URI는-리소스를-표현하는데-집중하고-마지막에-슬래시-포함하지-않는다" class="headerlink" title="1. URI는 리소스를 표현하는데 집중하고 마지막에 슬래시 포함하지 않는다."></a>1. URI는 리소스를 표현하는데 집중하고 마지막에 슬래시 포함하지 않는다.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line"><span class="variable constant_">GET</span> /getTodos/<span class="number">1</span></span><br><span class="line"><span class="variable constant_">GET</span> /todos/show/<span class="number">1</span></span><br><span class="line"><span class="variable constant_">GET</span> /todos/<span class="number">1</span>/</span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line"><span class="variable constant_">GET</span> /todos/<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-행위에-대한-정의는-HTTP-요청-메서드를-통해-정의한다"><a href="#2-행위에-대한-정의는-HTTP-요청-메서드를-통해-정의한다" class="headerlink" title="2. 행위에 대한 정의는 HTTP 요청 메서드를 통해 정의한다."></a>2. 행위에 대한 정의는 HTTP 요청 메서드를 통해 정의한다.</h3><table><thead><tr><th>HTTP 요청 메서드</th><th>종류</th><th>목적</th><th>페이로드</th></tr></thead><tbody><tr><td>GET</td><td>index&#x2F;retrieve</td><td>모든&#x2F;특정 리소스 취득</td><td>X</td></tr><tr><td>POST</td><td>create</td><td>리소스 생성</td><td>O</td></tr><tr><td>PUT</td><td>replace</td><td>리소스 전체 교체</td><td>O</td></tr><tr><td>PATCH</td><td>modify</td><td>리소스 일부 수정</td><td>O</td></tr><tr><td>DELETE</td><td>delete</td><td>모든&#x2F;특정 리소스 삭제</td><td>X</td></tr></tbody></table><ul><li>리소스에 대한 행위는 HTTP 요청 메서드를 통해 표현하며 URI에 표현하지 않는다.</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line"><span class="variable constant_">GET</span> /todos/<span class="keyword">delete</span>/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line"><span class="variable constant_">DELETE</span> /todos/<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="3-슬래시-구분자-x2F-는-계층-관계를-표현"><a href="#3-슬래시-구분자-x2F-는-계층-관계를-표현" class="headerlink" title="3. 슬래시 구분자(&#x2F;)는 계층 관계를 표현"></a>3. 슬래시 구분자(&#x2F;)는 계층 관계를 표현</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//example.com/stores/restaurant</span></span><br></pre></td></tr></table></figure><h3 id="4-불가피하게-긴-URI인-경우-하이픈-사용"><a href="#4-불가피하게-긴-URI인-경우-하이픈-사용" class="headerlink" title="4. 불가피하게 긴 URI인 경우 하이픈(-) 사용"></a>4. 불가피하게 긴 URI인 경우 하이픈(-) 사용</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http</span>:<span class="comment">//example.com/stores/very-long-store</span></span><br></pre></td></tr></table></figure><blockquote><p>단 밑줄(_)은 포함하지 않는다.</p></blockquote><h3 id="5-파일-확장자는-URI에-포함하지-않는다"><a href="#5-파일-확장자는-URI에-포함하지-않는다" class="headerlink" title="5. 파일 확장자는 URI에 포함하지 않는다."></a>5. 파일 확장자는 URI에 포함하지 않는다.</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># bad</span><br><span class="line"><span class="attr">http</span>:<span class="comment">//example.com/stores/restaurant/:1/logo.png</span></span><br><span class="line"></span><br><span class="line"># good</span><br><span class="line"><span class="variable constant_">GET</span> /stores/restaurant/:<span class="number">1</span>/logo <span class="variable constant_">HTTP</span>/<span class="number">1.1</span> <span class="attr">HOST</span>: example.<span class="property">com</span> <span class="title class_">Accept</span>: image/png</span><br></pre></td></tr></table></figure><ul><li>대신 Accept header를 사용한다.</li></ul><h2 id="RESTful한-REST-API-설계하기"><a href="#RESTful한-REST-API-설계하기" class="headerlink" title="RESTful한 REST API 설계하기"></a>RESTful한 REST API 설계하기</h2><p>RESTful은 이해하기 쉽고 사용하기 쉬운 REST API를 만들고, 일관적인 컨벤션을 통해 API의 이해도를 높이는 것을 말한다.</p><h3 id="REST-API-설계-예시"><a href="#REST-API-설계-예시" class="headerlink" title="REST API 설계 예시"></a>REST API 설계 예시</h3><table><thead><tr><th>CRUD</th><th>HTTP verbs</th><th>Route</th></tr></thead><tbody><tr><td>resource 목록 표시</td><td>GET</td><td>&#x2F;resource</td></tr><tr><td>resource 하나 내용 표시</td><td>GET</td><td>&#x2F;resource&#x2F;:id</td></tr><tr><td>resource 생성</td><td>POST</td><td>&#x2F;resource</td></tr><tr><td>resource 수정</td><td>PUT</td><td>&#x2F;resource&#x2F;:id</td></tr><tr><td>resource 삭제</td><td>DELETE</td><td>&#x2F;resource&#x2F;:id</td></tr></tbody></table><h4 id="응답상태-코드"><a href="#응답상태-코드" class="headerlink" title="응답상태 코드"></a>응답상태 코드</h4><table><thead><tr><th>상태코드</th><th>설명</th></tr></thead><tbody><tr><td>1xx</td><td>전송 프로토콜 수준의 정보 교환</td></tr><tr><td>2xx</td><td>클라이언트 요청 성공</td></tr><tr><td>3xx</td><td>클라이언트 요청 완료하기 위해 추가 행동 필요</td></tr><tr><td>4xx</td><td>클라이언트의 잘못된 요청</td></tr><tr><td>5xx</td><td>서버쪽 오류</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;REST-API란-무엇인가요&quot;&gt;&lt;a href=&quot;#REST-API란-무엇인가요&quot; class=&quot;headerlink&quot; title=&quot;REST API란 무엇인가요?&quot;&gt;&lt;/a&gt;REST API란 무엇인가요?&lt;/h1&gt;&lt;p&gt;자원의 이름으로 구분하여 해당</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>OOP에 대해 설명하세요</title>
    <link href="https://loco9939.github.io/2023/01/17/CS/OOP%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94/OOP%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/17/CS/OOP%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94/OOP%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EC%84%B8%EC%9A%94/</id>
    <published>2023-01-17T08:40:29.000Z</published>
    <updated>2023-01-17T10:23:33.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP란-무엇인가요"><a href="#OOP란-무엇인가요" class="headerlink" title="OOP란 무엇인가요?"></a>OOP란 무엇인가요?</h1><p>OOP(Obeject-Oriented-Programming)는 객체지향 프로그래밍을 말한다.</p><p>객체지향 프로그래밍이란, 실세계에 존재하고 우리가 인지하는 객체라는 대상을 추상화하여 프로그래밍에 접목 시킨 방식으로,</p><p>프로그래밍 관점에서 데이터를 추상화할 때, <strong>상태와 행동을 가진 객체를 만들고 이 객체들간의 유기적인 상호작용</strong>을 통해 로직을 구성하는 프로그래밍 방식을 객체지향 프로그래밍이라 한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">TV</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Samsung UHD Ultra&quot;</span>,</span><br><span class="line">  <span class="attr">price</span>: <span class="string">&quot;1,000,000원&quot;</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">  <span class="attr">volume</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="title function_">turnOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">turnOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">volumeUp</span>(<span class="params">num = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">volume</span> += num;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">volumeDown</span>(<span class="params">num = <span class="number">10</span></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">volume</span> -= num;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>위는 TV라는 데이터를 상태와 행동으로 추상화한 객체로 표현한 것이다.</p><h2 id="OOP의-특징은-무엇인가요"><a href="#OOP의-특징은-무엇인가요" class="headerlink" title="OOP의 특징은 무엇인가요?"></a>OOP의 특징은 무엇인가요?</h2><h3 id="1-캡슐화"><a href="#1-캡슐화" class="headerlink" title="1. 캡슐화"></a>1. 캡슐화</h3><p>캡슐화란 객체를 특정한 목적을 위해 변수 혹은 메서드 하나로 묶는 것을 말한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> counter = (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">getCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> count;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">increase</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count += <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">decrease</span>(<span class="params"></span>) &#123;</span><br><span class="line">      count -= <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>위 예시는 counter를 캡슐화한 예시이다. 이렇게 캡슐화를 하게되면 count라는 변수에 대해 참조하거나 변경하는 함수를 통해서만 간접적으로 접근이 가능하도록 하여 <span style='color:red;'>해당 데이터를 은닉하고 안전하게 보존하기 위해 사용한다.</span></p><h3 id="2-추상화"><a href="#2-추상화" class="headerlink" title="2. 추상화"></a>2. 추상화</h3><p>우리는 앞서 TV라는 데이터를 추상화하였다. 하지만 추상화는 예시처럼 간단하지만은 않다. 추상적으로 큰 틀에 공통적인 요소나 필수적인 요소를 담는 것을 말한다.</p><p>다시 TV의 예를 들어보겠다. 우리가 실생활의 모든 데이터(TV, 냉장고, 인덕션, 청소기 등)를 모두 개별적으로 만드는 것보단 이들의 공통적인 특성을 가진 큰 틀의 객체를 만들고 해당 객체의 상속을 받고 본인만의 특별한 기능을 추가하는 방법으로 객체를 생성해나가는 것이 <span style='color:red;'>중복을 줄이고 확장성의 장점을 살려</span> 추상화를 할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HomeAppliance</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, price</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">price</span> = price;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">turnOn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;on&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">turnOff</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = <span class="string">&quot;off&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">TV</span> = <span class="keyword">new</span> <span class="title class_">HomeAppliance</span>(<span class="string">&quot;Samsung UHD Smart TV&quot;</span>, <span class="number">1000000</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Refrigerator</span> = <span class="keyword">new</span> <span class="title class_">HomeAppliance</span>(<span class="string">&quot;Samsung BSpoke&quot;</span>, <span class="number">2000000</span>);</span><br><span class="line"><span class="keyword">const</span> vacuumCleaner = <span class="keyword">new</span> <span class="title class_">HomeAppliance</span>(<span class="string">&quot;Dyson&quot;</span>, <span class="number">800000</span>);</span><br></pre></td></tr></table></figure><p>위 예시처럼 가전제품이라는 데이터를 추상화하여 객체로 생성한 뒤, 해당 객체의 상속을 받아 공통적인 행동을 할 수 있는 객체를 생성하여 TV, 냉장고, 청소기 데이터를 추상화하였다.</p><h3 id="3-상속-및-다형성"><a href="#3-상속-및-다형성" class="headerlink" title="3. 상속 및 다형성"></a>3. 상속 및 다형성</h3><p>다형성은 같은 동작이지만 다른 결과물을 반환하는 특징을 말한다.</p><p>상속과 다형성을 통해 기능을 확장하거나 변경하는 것이 가능하다. 그렇게 되면 <span style='color:red;'>코드의 재사용 및 코드 길이 감소되고 유지보수가 용이해지는 장점이 있다.</span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 숫자를 문자열로 바꾸는 경우</span></span><br><span class="line"><span class="keyword">const</span> number = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> string1 = number.<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 날짜를 문자열로 바꾸는 경우</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">const</span> string2 = date.<span class="title function_">toString</span>();</span><br></pre></td></tr></table></figure><p>위 예시는 다형성의 예시이다. toString()이라는 메서드를 사용하여 타입에 따라 적절한 변환 방식을 정의해둠으로써 객체의 종류와 상관없는 추상도가 높은 변환 형식을 구현할 수 있다는 장점이 있다.</p><p>이러한 다형성의 개념을 녹여내는 방법은 오버라이딩(Overriding), 오버로딩(Overloading) 두가지가 있다.</p><h4 id="오버라이딩-Overriding"><a href="#오버라이딩-Overriding" class="headerlink" title="오버라이딩(Overriding)"></a>오버라이딩(Overriding)</h4><p>자식 클래스가 부모 클래스에게 상속받은 메서드를 특정 형태로 구현하는 것을 말한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, legs</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">legs</span> = legs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;move forward faster!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eat food&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">move</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;move like a dog!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">bark</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Wal! Wal!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animal = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;eagle&quot;</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;seechu&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">dog.<span class="title function_">move</span>(); <span class="comment">// move like a dog!</span></span><br><span class="line">animal.<span class="title function_">move</span>(); <span class="comment">// move forward faster!!</span></span><br></pre></td></tr></table></figure><p>위 예시에서 자식 클래스는 부모 클래스에게 상속받은 move 메서드를 새롭게 정의하였다. 그리고 자식 클래스의 인스턴스와 부모 클래스의 인스턴스에서 각각 move 메서드를 사용했을 때, 각자 클래스에 정의된 move 메서드가 동작하는 것을 알 수 있다.</p><h4 id="오버로딩-Overloading"><a href="#오버로딩-Overloading" class="headerlink" title="오버로딩(Overloading)"></a>오버로딩(Overloading)</h4><p>하나의 클래스안에서 같은 이름의 메서드를 사용하지만 매개변수, Return Type 등의 특징에 따라 다른 용도로 사용되도록 구현하는 것을 말한다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, legs</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">legs</span> = legs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">move</span>(<span class="params">direction, distance</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!direction || !distance) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;move forward faster!!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`move <span class="subst">$&#123;direction&#125;</span> for <span class="subst">$&#123;distance&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">eat</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eat food&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pig = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;kong-e&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">pig.<span class="title function_">move</span>(); <span class="comment">// move forward faster!!</span></span><br><span class="line">pig.<span class="title function_">move</span>(<span class="string">&quot;right&quot;</span>, <span class="string">&quot;10m&quot;</span>); <span class="comment">// move right for 10m</span></span><br></pre></td></tr></table></figure><p>위 예시는 자바스크립트에서 오버로딩을 구현한 예시이다. move라는 메서드를 사용할 때, 매개변수가 있고 없고에 따라 다르게 동작하도록 구현하였다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OOP란-무엇인가요&quot;&gt;&lt;a href=&quot;#OOP란-무엇인가요&quot; class=&quot;headerlink&quot; title=&quot;OOP란 무엇인가요?&quot;&gt;&lt;/a&gt;OOP란 무엇인가요?&lt;/h1&gt;&lt;p&gt;OOP(Obeject-Oriented-Programming)는 객</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>SSR과 CSR에 대해 설명하라</title>
    <link href="https://loco9939.github.io/2023/01/12/CS/SSR%EA%B3%BC-CSR%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/SSR%EA%B3%BC-CSR%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/"/>
    <id>https://loco9939.github.io/2023/01/12/CS/SSR%EA%B3%BC-CSR%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/SSR%EA%B3%BC-CSR%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/</id>
    <published>2023-01-12T13:12:40.000Z</published>
    <updated>2023-01-12T13:29:39.467Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🐥-SSR과-CSR에-대해-설명하라"><a href="#🐥-SSR과-CSR에-대해-설명하라" class="headerlink" title="🐥 SSR과 CSR에 대해 설명하라"></a>🐥 SSR과 CSR에 대해 설명하라</h1><p>SSR은 서버 사이드 렌더링의 줄임말로, 클라이언트가 서버에 요청을 보낼 때 서버에서 HTML,JS 등을 렌더링하고 클라이언트에게 완성된 HTML 파일을 응답해주는 방식이다.</p><p>CSR은 서버에 요청을 보내면 서버에서 HTML,JS 리소스 파일등을 받은 이후 브라우저에서 렌더링을 진행하는 것이다. 이후 클라이언트는 서버에게 데이터만 요청하면서 브라우저가 렌더링한 페이지에 서버의 응답으로 받은 데이터만 패칭해주면 된다.</p><h2 id="😃-특징"><a href="#😃-특징" class="headerlink" title="😃 특징"></a>😃 특징</h2><h3 id="✈️-초기-로딩-속도"><a href="#✈️-초기-로딩-속도" class="headerlink" title="✈️ 초기 로딩 속도"></a>✈️ 초기 로딩 속도</h3><p>SSR은 클라이언트가 요청한 부분의 페이지만 렌더링해서 보내주면 되므로 초기 로딩 속도가 CSR에 비해서 빠른 반면, CSR은 HTML,JS, 모든 리소스를 한번에 로드하기 때문에 초기 로드 속도가 느리다.</p><h3 id="❗️-서버-부하"><a href="#❗️-서버-부하" class="headerlink" title="❗️ 서버 부하"></a>❗️ 서버 부하</h3><p>SSR은 View가 바뀔 때마다 서버에 요청을 보내고 서버는 그 때마다 응답해줘야하므로 서버의 부하가 높고 UX 측면에서는 깜빡임 현상이 있는 단점이 있다. 반면, CSR은 데이터 요청이 있을 때만 서버에 요청을 하기 때문에 서버 부하가 적다.</p><h3 id="📚-SEO"><a href="#📚-SEO" class="headerlink" title="📚 SEO"></a>📚 SEO</h3><p>SSR은 서버가 렌더링을 하고 완성된 페이지를 클라이언트에게 보내주는데, 그 안에는 SEO에 사용되는 meta 태그 등이 미리 정의 되어 있어 SEO 측면에서 유리하다. 반면 CSR은 초기에 비어있는 HTML 파일을 보내주고 JS를 다운로드하여 브라우저에서 렌더링이 완료되기 전까지는 빈 파일로 남아있기 때문에, SEO 측면에서 불리하다.</p><h3 id="Next-js에서-SSR-CSR"><a href="#Next-js에서-SSR-CSR" class="headerlink" title="Next.js에서 SSR,CSR"></a>Next.js에서 SSR,CSR</h3><p>이번 과제에서 Next.js를 사용하면서 새롭게 배우게 된 사실을 정리해본다. Next.js는 기본적으로 SSR을 지원한다. SSR을 지원하는 방법으로는 2가지 방법이 있는데,</p><p>첫번째, 클라이언트가 요청할 때마다 서버에서 렌더링을 해주는 진짜 SSR 방식</p><p>두번째, 미리 렌더링을 끝내놓은 페이지를 클라이언트가 요청할 때마다 캐싱하여 보여주는 SSG 방식</p><p>그리고 CSR까지 지원해준다.</p><p>Next.js를 사용하다보니 SSR, CSR, SSG에 대한 이해가 더 잘되는 것 같아서 마무리로 적어보았다.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🐥-SSR과-CSR에-대해-설명하라&quot;&gt;&lt;a href=&quot;#🐥-SSR과-CSR에-대해-설명하라&quot; class=&quot;headerlink&quot; title=&quot;🐥 SSR과 CSR에 대해 설명하라&quot;&gt;&lt;/a&gt;🐥 SSR과 CSR에 대해 설명하라&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>Next.js는 왜 사용하나요?</title>
    <link href="https://loco9939.github.io/2023/01/11/CS/Next-js%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94/Next-js%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/11/CS/Next-js%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94/Next-js%EB%8A%94-%EC%99%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%82%98%EC%9A%94/</id>
    <published>2023-01-11T13:23:00.000Z</published>
    <updated>2023-01-11T13:54:34.005Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Next-js를-왜-사용하나요"><a href="#Next-js를-왜-사용하나요" class="headerlink" title="Next.js를 왜 사용하나요?"></a>Next.js를 왜 사용하나요?</h1><p><strong>Next.js는 빠르게 웹 애플리케이션을 만들기 위한 React 프레임워크이다.</strong></p><p>우리가 웹 애플리케이션을 만들기 위해서는 단순히 React로 코드만 짜서는 만들 수 없다.</p><p>UI는 물론, 라우팅, 데이터 패칭, 렌더링, 성능 최적화, 확장성, DX 까지도 고려하여 웹 애플리케이션을 만들어야한다.</p><p>그렇기 때문에 우리는 각 부분을 직접 구현할 지 아니면 라이브러리나 프레임워크와 같은 도구를 사용할지 결정해야한다.</p><p><strong>즉, 우리는 React로 UI를 구축한 뒤 Next.js의 기능을 점진적으로 도입하여 라우팅, 데이터 가져오기 등 애플레이케이션 요구사항을 해결함과 동시에 UX, DX까지 개선할 수 있다.</strong></p><h2 id="Next-js-특징"><a href="#Next-js-특징" class="headerlink" title="Next.js 특징"></a>Next.js 특징</h2><h3 id="👍-장점"><a href="#👍-장점" class="headerlink" title="👍 장점"></a>👍 장점</h3><ul><li>SWR을 사용하여 컴파일, 축소, 코드분할, 번들링 작업을 하고 Babel보다 17배 빠른 컴파일 속도를 갖는다.</li><li>페이지 별 SSR, CSR, SSG를 사용할 수 있다. 이를 통해 SEO 최적화 가능</li><li>React 프로젝트에서 Next.js로 점진적 마이그레이션 용이</li></ul><h3 id="👎-단점"><a href="#👎-단점" class="headerlink" title="👎 단점"></a>👎 단점</h3><ul><li>SSR을 사용하여 서버 부하가 있을 수 있다.</li><li>페이지 이동 시 깜빡거림</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Next-js를-왜-사용하나요&quot;&gt;&lt;a href=&quot;#Next-js를-왜-사용하나요&quot; class=&quot;headerlink&quot; title=&quot;Next.js를 왜 사용하나요?&quot;&gt;&lt;/a&gt;Next.js를 왜 사용하나요?&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Next</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>객체 불변성에 대해 설명하라</title>
    <link href="https://loco9939.github.io/2023/01/10/CS/%EA%B0%9D%EC%B2%B4-%EB%B6%88%EB%B3%80%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/%EA%B0%9D%EC%B2%B4-%EB%B6%88%EB%B3%80%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/"/>
    <id>https://loco9939.github.io/2023/01/10/CS/%EA%B0%9D%EC%B2%B4-%EB%B6%88%EB%B3%80%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/%EA%B0%9D%EC%B2%B4-%EB%B6%88%EB%B3%80%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/</id>
    <published>2023-01-10T07:49:01.000Z</published>
    <updated>2023-01-10T08:46:56.582Z</updated>
    
    <content type="html"><![CDATA[<h1 id="객체-불변성에-대해-설명하라"><a href="#객체-불변성에-대해-설명하라" class="headerlink" title="객체 불변성에 대해 설명하라."></a>객체 불변성에 대해 설명하라.</h1><p>자바스크립트에서 데이터는 변경 불가능한 원시값, 변경 가능한 참조값으로 구성된다.</p><p>변경 가능한 참조값이 바로 객체를 말하는데, 객체는 값을 참조값으로 전달하고 전달 받으므로 객체가 참조를 통해 공유되어 있다면 하나를 바꿨을 때, 다른 것들도 바뀔 위험이 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">a</span>: <span class="number">10</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> c = a;</span><br><span class="line"></span><br><span class="line">c.<span class="property">a</span> = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// &#123;a: 30, b: 200&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// &#123;a: 30, b: 200&#125;</span></span><br></pre></td></tr></table></figure><p>위와 같은 문제를 해결하기 위한 방법으로 객체를 불변객체로 만들거나, 참조값을 복사하는 것이 아닌 객체의 값을 복사하여 새로운 객체를 생성하는 방법이 있다.</p><p>객체를 불변 객체로 만드는 방법은 Object.freeze메서드와 Object.seal 메서드를 사용하는 방법이 있다. 두 메서드는 직속 프로퍼티에만 적용된다(얕은 방지).</p><blockquote><p>Object.freeze(), Object.seal()의 차이는 Object.freeze()는 해당 객체에 속성 추가, 기존 속성 변경, 삭제가 모두 불가능하지만 Object.seal()은 새로운 속성 추가및 삭제가 불가능하고 기존 속성 변경은 가능하다.</p></blockquote><p>객체의 값을 복사하는 방법으로는 Object.assign()를 사용하는 방법, ES6 Spread 문법이 있다. 이 두가지 방법 역시 얕은 복사이므로, 깊은 복사를 하려면 라이브러리를 사용하거나 새로 추가된 structedClone() 메서드를 사용하는 방법이 있다.</p><blockquote><p>structedClone() 메서드는 Function 객체, DOM Node, 객체들의 몇몇 파라미터 일부 기능에 제한이 있다.</p></blockquote><h2 id="리액트에서-Props-State를-불변객체로-다루는-이유는"><a href="#리액트에서-Props-State를-불변객체로-다루는-이유는" class="headerlink" title="리액트에서 Props, State를 불변객체로 다루는 이유는?"></a>리액트에서 Props, State를 불변객체로 다루는 이유는?</h2><p>리액트에서는 Props와 State의 변경을 불변성을 이용해 감지하고 리렌더링을 발생시킨다.</p><p>만약 불변 객체를 사용하지 않는다면, 객체의 값이 어디에서 바뀌게 되었는지 예상하기 어렵고 해당 객체도 엉망이 될 것이다.</p><blockquote><p>setState는 비동기적으로 State를 변경시키는데, 불변 객체로 다루지 않고 직접 State를 변경시킨다면 이전의 값이 반환될 수 있다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;객체-불변성에-대해-설명하라&quot;&gt;&lt;a href=&quot;#객체-불변성에-대해-설명하라&quot; class=&quot;headerlink&quot; title=&quot;객체 불변성에 대해 설명하라.&quot;&gt;&lt;/a&gt;객체 불변성에 대해 설명하라.&lt;/h1&gt;&lt;p&gt;자바스크립트에서 데이터는 변경</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>비동기 함수를 이벤트 루프 관점에서 설명하라</title>
    <link href="https://loco9939.github.io/2023/01/10/CS/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/"/>
    <id>https://loco9939.github.io/2023/01/10/CS/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/</id>
    <published>2023-01-10T07:30:09.000Z</published>
    <updated>2023-02-06T10:01:23.698Z</updated>
    
    <content type="html"><![CDATA[<h1 id="이벤트-루프가-비동기-함수를-어떻게-처리하는지-설명하라"><a href="#이벤트-루프가-비동기-함수를-어떻게-처리하는지-설명하라" class="headerlink" title="이벤트 루프가 비동기 함수를 어떻게 처리하는지 설명하라."></a>이벤트 루프가 비동기 함수를 어떻게 처리하는지 설명하라.</h1><p>우선 자바스크립트는 한번에 하나의 일을 처리할 수 있는 싱글 스레드 처리방식을 가진다.</p><p>그러므로 동기적으로 일을 처리할 때에 시간이 오래 걸리는 처리를 할 경우 다음 일에 블로킹이 발생한다.</p><p>이러한 블로킹 현상을 해결하기 위해 비동기식 처리 방식을 사용하고 여러 개의 일이 동시에 처리되는 것처럼 느껴지도록 도와주는 이벤트 루프가 있다.</p><blockquote><p>이벤트 루프는 브라우저에 내장된 기능 중 하나이다.</p></blockquote><p><img src="/../../images/../../images/event/eventLoop.png" alt="이벤트 루프"></p><p>위 사진은 이벤트 루프가 동작하는 방식을 보여주는 사진이다.</p><ul><li><strong>콜 스택</strong> : 함수 호출 시 함수 실행 컨텍스트가 콜 스택에 푸시되어 순차적으로 실행된다.</li><li><strong>태스크 큐</strong> : 타이머 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역이다. 태스크 큐와는 별도로 프로미스의 후속처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로 태스크 큐도 존재한다.</li><li><strong>이벤트 루프 :</strong> 이벤트 루프는 현재 콜 스택에 실행중인 실행 컨텍스트가 있는지, 태스크 큐에 대기중인 함수가 있는지 확인하여 콜 스택이 비어있고 태스크 큐에 대기중인 함수가 있다면 이벤트 루프가 순차적(FIFO)으로 태스크 큐에 대기중인 함수를 콜 스택으로 이동시킨다. 즉, <strong>태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작한다.</strong></li></ul><blockquote><p>비동기 처리에서 소스코드 평가 및 실행을 제외한 모든 코드는 브라우저 또는 NodeJS가 담당한다. 브라우저는 멀티 스레드로 동작한다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;이벤트-루프가-비동기-함수를-어떻게-처리하는지-설명하라&quot;&gt;&lt;a href=&quot;#이벤트-루프가-비동기-함수를-어떻게-처리하는지-설명하라&quot; class=&quot;headerlink&quot; title=&quot;이벤트 루프가 비동기 함수를 어떻게 처리하는지 설명하라.&quot;</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>모의 면접 2차 회고</title>
    <link href="https://loco9939.github.io/2023/01/10/CS/%EB%AA%A8%EC%9D%98-%EB%A9%B4%EC%A0%91-2%EC%B0%A8-%ED%9A%8C%EA%B3%A0/"/>
    <id>https://loco9939.github.io/2023/01/10/CS/%EB%AA%A8%EC%9D%98-%EB%A9%B4%EC%A0%91-2%EC%B0%A8-%ED%9A%8C%EA%B3%A0/</id>
    <published>2023-01-10T06:45:38.000Z</published>
    <updated>2023-01-10T07:27:53.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="📌-1분-자기소개-파트"><a href="#📌-1분-자기소개-파트" class="headerlink" title="📌 1분 자기소개 파트"></a>📌 1분 자기소개 파트</h1><p>기술면접만 진행하실 줄 알았는데 갑자기 자기소개를 하라하셔서 당황하여 말을 제대로 못했다.</p><ul><li>~ 하는 편입니다. 보다는 ~ 합니다. 라고 명료하게 답변하자</li></ul><h1 id="📚-기술면접-파트"><a href="#📚-기술면접-파트" class="headerlink" title="📚 기술면접 파트"></a>📚 기술면접 파트</h1><h3 id="비동기-함수와-이벤트-루프에-대한-설명해라"><a href="#비동기-함수와-이벤트-루프에-대한-설명해라" class="headerlink" title="비동기 함수와 이벤트 루프에 대한 설명해라"></a>비동기 함수와 이벤트 루프에 대한 설명해라</h3><ul><li>Web API, setTimeout, 이벤트리스너등의 특수한 경우에서 자바스크립트는 멀티스레드로 동작하는 것처럼 보이는 것이다. 실제로 자바스크립트는 싱글 스레드이다.</li><li>일련의 과정을 설명하는데 짜임새가 부족하였다.</li><li>자바스크립트는 원래 싱글 스레드인데, 런타임 이전에서 AJAX나 비동기 코드를 위해 불가피하게 멀티 스레드를 두어 사용하게 되었다 라는 보충 설명 해주면 좋을 것 같다.</li></ul><h3 id="객체-불변성에-대해-설명해라"><a href="#객체-불변성에-대해-설명해라" class="headerlink" title="객체 불변성에 대해 설명해라"></a>객체 불변성에 대해 설명해라</h3><ul><li>리액트와 객체 불변성을 연관짓는 설명이 부족하다.</li><li>~ 한다고 생각합니다 대신 ~ 할 수 있습니다로 바꿔서 말하기</li></ul><h3 id="This-설명하라"><a href="#This-설명하라" class="headerlink" title="This 설명하라"></a>This 설명하라</h3><ul><li>처음에 4가지 분류를 말하였는데 말하다보니 까먹어서 3가지밖에 말하지 못한 부분이 아쉬웠다.</li><li>화살표 함수는 this를 가지고 있지 않으므로, 내부의 this는 상위 스코프의 this에 바인딩된다.</li></ul><h3 id="var-let-const-비교-설명하라"><a href="#var-let-const-비교-설명하라" class="headerlink" title="var, let, const 비교 설명하라"></a>var, let, const 비교 설명하라</h3><ul><li>스코프 설명하면서 함수레벨 스코프, 블록 레벨 스코프가 왜 더 안전한 코드를 짤 수 있도록 하는 지에 대한 설명 보충</li></ul><h3 id="함수가-일급-객체인-이유는"><a href="#함수가-일급-객체인-이유는" class="headerlink" title="함수가 일급 객체인 이유는?"></a>함수가 일급 객체인 이유는?</h3><ul><li>좀 더 자세한 설명이 필요하다.</li><li>특징을 2가지 밖에 말하지 못하여 아쉬웠다.</li></ul><h3 id="클로저-설명-장점-및-주의점"><a href="#클로저-설명-장점-및-주의점" class="headerlink" title="클로저 설명, 장점 및 주의점"></a>클로저 설명, 장점 및 주의점</h3><ul><li>주의점 설명이 부족했다. 클로저는 외부 함수의 실행 컨텍스트가 사라져도 내부 함수에 대한 참조가 유지되고 있기 때문에 메모리 누수에 대한 부분도 고려해줘야한다.</li><li>리액트내에서도 useEffect 함수 내부에서 클린업 함수를 해주어 메모리 누수를 방지하여야 한다.</li></ul><h3 id="CORS-우회-방법-설명하라"><a href="#CORS-우회-방법-설명하라" class="headerlink" title="CORS 우회 방법 설명하라"></a>CORS 우회 방법 설명하라</h3><ul><li>프록시 객체라는 설명이 모호해서 아쉬웠다. 프록시 서버에 대한 설명을 프록시 객체로 잘못 답변하였다.</li></ul><h3 id="제너레이터에-대해-설명하라"><a href="#제너레이터에-대해-설명하라" class="headerlink" title="제너레이터에 대해 설명하라"></a>제너레이터에 대해 설명하라</h3><ul><li>제너레이터 공부하자…</li></ul><h1 id="✏️-총평"><a href="#✏️-총평" class="headerlink" title="✏️ 총평"></a>✏️ 총평</h1><ul><li>정제된 단어로 정리해서 답변을 하면 더 좋을 것 같다.</li><li>객체 변경 불가성 중요하니깐 제대로 알아두자. 상태값을 객체로 주로 저장하기 때문에, 이 자체의 참조값을 바꿔야지만 내부적으로 렌더링이 일어난다.</li><li>클로저의 주의점에 대해서는 클린업 함수, 메모리 누수 설명 보충하자.</li><li>1급 객체에 대한 특징 및 조건 설명을 풍부하게 해보자.</li><li>CORS 해결 방법에 대한 설명을 제대로 답변하지 못하였으니 공부하자.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;📌-1분-자기소개-파트&quot;&gt;&lt;a href=&quot;#📌-1분-자기소개-파트&quot; class=&quot;headerlink&quot; title=&quot;📌 1분 자기소개 파트&quot;&gt;&lt;/a&gt;📌 1분 자기소개 파트&lt;/h1&gt;&lt;p&gt;기술면접만 진행하실 줄 알았는데 갑자기 자기소개</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>JWT 토큰 방식은 무엇인가요?</title>
    <link href="https://loco9939.github.io/2023/01/09/CS/JWT-%ED%86%A0%ED%81%B0-%EB%B0%A9%EC%8B%9D%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/09/CS/JWT-%ED%86%A0%ED%81%B0-%EB%B0%A9%EC%8B%9D%EC%9D%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</id>
    <published>2023-01-09T02:31:32.000Z</published>
    <updated>2023-01-09T08:51:54.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="🛠-JWT-토큰-방식이란"><a href="#🛠-JWT-토큰-방식이란" class="headerlink" title="🛠 JWT 토큰 방식이란?"></a>🛠 JWT 토큰 방식이란?</h1><p>JWT는 JSON Web Token의 약자로, 인증에 필요한 데이터를 암호화한 JSON으로 이루어진 토큰을 말한다.</p><p>기존의 세션 인증방식은 인증관련 정보를 세션 저장소라는 DB에 저장하여 서버가 과부하 되거나 서버를 확장하기가 어려웠다.</p><p>이러한 문제 때문에 서버자원을 절약하기 위해 사용자 인증에 필요한 정보를 토큰 자체에 담아두는 JWT를 사용하게 되었다.</p><blockquote><p>토큰은 로그인 이후 서버가 만들어주는 문자열이고, 토큰 안에는 사용자의 로그인 정보와 서버의 서명이 들어있다.</p></blockquote><h1 id="JWT-토큰-방식-순서"><a href="#JWT-토큰-방식-순서" class="headerlink" title="JWT 토큰 방식 순서"></a>JWT 토큰 방식 순서</h1><ol><li>사용자가 로그인을 하면 서버는 사용자에게 사용자 로그인 정보 및 서버의 서명이 들어간 토큰을 발급한다.</li><li>사용자는 토큰을 가지고 권한이 필요한 API 작업을 요청한다.</li><li>서버는 토큰의 유효성 검사를 통해 요청에 응답한다.</li></ol><h1 id="JWT-토큰-특징"><a href="#JWT-토큰-특징" class="headerlink" title="JWT 토큰 특징"></a>JWT 토큰 특징</h1><h2 id="👍-장점"><a href="#👍-장점" class="headerlink" title="👍 장점"></a>👍 장점</h2><ul><li>서버에서 사용자 정보를 저장해둘 필요가 없어 서버 스케일링시 큰 문제가 없다.</li><li>별도의 I&#x2F;O 작업 없는 빠른 인증 처리 가능</li></ul><h2 id="👎-단점"><a href="#👎-단점" class="headerlink" title="👎 단점"></a>👎 단점</h2><ul><li>한번 발급된 토큰은 수정 및 폐기가 불가능하다.(클라이언트에게 있으니깐!)<ul><li>그렇기 때문에 유효기간을 짧게 설정해주는것이 중요하다.</li></ul></li><li>토큰의 길이가 늘어날 수록 네트워크 부하가 심해진다.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;🛠-JWT-토큰-방식이란&quot;&gt;&lt;a href=&quot;#🛠-JWT-토큰-방식이란&quot; class=&quot;headerlink&quot; title=&quot;🛠 JWT 토큰 방식이란?&quot;&gt;&lt;/a&gt;🛠 JWT 토큰 방식이란?&lt;/h1&gt;&lt;p&gt;JWT는 JSON Web Token의</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>SPA는 무엇인가요?</title>
    <link href="https://loco9939.github.io/2023/01/06/CS/SPA%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/"/>
    <id>https://loco9939.github.io/2023/01/06/CS/SPA%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94/</id>
    <published>2023-01-06T03:36:24.000Z</published>
    <updated>2023-01-06T06:29:24.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="✏️-SPA란"><a href="#✏️-SPA란" class="headerlink" title="✏️ SPA란?"></a>✏️ SPA란?</h1><p><strong>Single Page Application의 약자로, 단일 페이지로 구성된 애플리케이션을 말한다.</strong></p><p>전통적으로 브라우저는 서버에서 HTML을 받아 렌더링 해주는 역할을 한다. 즉, 사용자가 다른 URL로 이동하거나 사용자 액션에 의해 화면의 UI가 변경될 때마다 서버에 HTML을 요청하고 응답받는 서버측 렌더링(SSR)을 사용한다.</p><p>하지만 오늘날 최신 SPA에서는 대화형 요소와 동적인 요소가 많아 클라이언트가 작업을 수행하고 작업에 대한 응답을 받을 수 있는 <strong>클라이언트 사이드 렌더링(CSR)을 사용한다.</strong></p><h1 id="🤓-SPA-동작-원리"><a href="#🤓-SPA-동작-원리" class="headerlink" title="🤓 SPA 동작 원리"></a>🤓 SPA 동작 원리</h1><ol><li>브라우저는 웹에 필요한 소스코드 및 스타일 시트를 서버로부터 응답받아 초기 페이지를 렌더링한다.</li><li>대화형 요소, 동적인 요소에 의해 새 페이지가 필요해지면, 새 페이지에 필요한 새 데이터는 서버에게 AJAX 요청을 보낸다. 이후 SPA는 초기 페이지 로드시 다운로드한 JavaScript를 통해 응답받은 데이터를 페이지에 동적으로 업데이트한다.</li></ol><blockquote><p>사용자가 다른 페이지로 이동할 때 새로고침이 발생하지 않는다. 페이지의 URL은 <strong>HTML5 History API</strong>를 통해 업데이트된다.</p></blockquote><h1 id="📚-SPA-특징"><a href="#📚-SPA-특징" class="headerlink" title="📚 SPA 특징"></a>📚 SPA 특징</h1><h3 id="👍-장점"><a href="#👍-장점" class="headerlink" title="👍 장점"></a>👍 장점</h3><ul><li>앱의 반응속도가 빨라지고 새로고침으로 인한 깜빡임 현상이 사라진다.</li><li>페이지 렌더링 시 중복된 데이터를 다시 다운받을 필요가 없어 서버에 대한 HTTP 요청이 줄어든다.</li><li>클라이언트와 서버간의 문제를 명확히 구분할 수 있다. 서버 코드를 수정하지 않고도 다양한 플랫폼을 위한 새로운 클라이언트를 쉽게 구축할 수 있다.</li></ul><h3 id="👎-단점"><a href="#👎-단점" class="headerlink" title="👎 단점"></a>👎 단점</h3><ul><li>초기에 웹에 필요한 모든 데이터를 서버로 부터 로드 받기 때문에 초기 페이지 로드 시간이 길다.</li><li>모든 요청을 단일 진입점으로 라우트하고 클라이언트 측 라우팅이 단일 진입점에서 응답받을 수 있도록 서버를 구성하는 추가 단계가 필요하다.</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 브라우저 새로고침 시 서버는 index.html 파일을 응답하고 클라이언트는 window.location.pathname을 참조해 라우팅</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&quot;*&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">sendFile</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&quot;public/index.html&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>SPA는 JavaScript에 의존하는데 검색 엔진이 크롤링 중에 JavaScript를 실행하지 않기 때문에 해당 웹이 빈 컨텐츠로 표시될 수 있어 SEO 최적화에 부적합하다.<blockquote><p>이를 해결하기 위해 서버측에서 앱을 렌더링하거나 Prerender 같은 서비스를 사용하여 브라우저에서 JavaScript를 렌더링하고 정적 HTML을 저장한 다음 크롤러에게 반환할 수 있다.</p></blockquote></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;✏️-SPA란&quot;&gt;&lt;a href=&quot;#✏️-SPA란&quot; class=&quot;headerlink&quot; title=&quot;✏️ SPA란?&quot;&gt;&lt;/a&gt;✏️ SPA란?&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Single Page Application의 약자로, 단일 페이지로 구성</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
  <entry>
    <title>브라우저 렌더링 과정에 대해 설명하라</title>
    <link href="https://loco9939.github.io/2023/01/05/CS/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/"/>
    <id>https://loco9939.github.io/2023/01/05/CS/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%98%EB%9D%BC/</id>
    <published>2023-01-05T06:10:40.000Z</published>
    <updated>2023-01-05T06:31:13.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="브라우저란"><a href="#브라우저란" class="headerlink" title="브라우저란?"></a>브라우저란?</h1><p>브라우저는 HTML, CSS, Javascript로 작성된 텍스트 문서를 서버에게 요청하여 응답을 받아 의미있는 단위인 토큰으로 파싱하여 시각적으로 렌더링 해주는 역할을 담당한다.</p><h1 id="브라우저-렌더링-과정"><a href="#브라우저-렌더링-과정" class="headerlink" title="브라우저 렌더링 과정"></a>브라우저 렌더링 과정</h1><h2 id="1-요청과-응답"><a href="#1-요청과-응답" class="headerlink" title="1. 요청과 응답"></a>1. 요청과 응답</h2><p>서버에 요청하기 위해 브라우저는 주소창을 제공한다. 주소창에 URL을 입력하면 URL의 호스트 이름이 DNS를 통해 IP주소로 변환되고 IP 주소를 갖는 서버에게 요청을 전송한다.</p><p>이렇게 요청을 보내면 서버는 서버의 루트 폴더에 존재하는 정적파일로 응답을 보낸다. 기본적으로 index.html이다.</p><h2 id="2-HTML-파싱과-DOM-생성"><a href="#2-HTML-파싱과-DOM-생성" class="headerlink" title="2. HTML 파싱과 DOM 생성"></a>2. HTML 파싱과 DOM 생성</h2><p>브라우저 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다.</p><p><strong>그래서 HTML 문서를 파싱하여 <span style="color:red">브라우저가 이해할 수 있는 자료구조인 DOM을 생성</span>한다.</strong></p><ol><li>문자열로 변환된 HTML문서를 토큰화한다.</li><li>각 토큰을 객체로 변환하여 노드를 생성한다. 노드는 DOM을 구성하는 기본 요소이다. ex) 문서 노드, 요소 노드 등</li><li>HTML 문서는 중첩관계를 통해 부자관계가 형성된다. 이러한 부자관계를 반영하여 <strong>모든 노드들을 트리 자료구조로 구성한다. 이러한 노드들로 구성된 트리 자료구조를 DOM이라 부른다.</strong></li></ol><h2 id="3-CSS-파싱과-CSSOM-생성"><a href="#3-CSS-파싱과-CSSOM-생성" class="headerlink" title="3. CSS 파싱과 CSSOM 생성"></a>3. CSS 파싱과 CSSOM 생성</h2><p>렌더링 엔진은 HTML을 한줄씩 읽어나가며 순차적으로 파싱하여 DOM을 생성해 나간다. <strong>DOM을 생성하다가 CSS를 로드하는 link 태그나 style 태그를 만나면 <span style="color:red">DOM 생성을 일시중단</span>한다.</strong></p><p>그 결과 CSS 파일을 서버에 요청하여 응답받은 CSS 파일이나 style 태그 내의 CSS를 HTML과 동일한 과정으로 토큰화 생성 → CSSOM 생성 과정을 거친다. 이후 파싱이 완료되면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작한다.</p><h2 id="4-렌더-트리-생성"><a href="#4-렌더-트리-생성" class="headerlink" title="4. 렌더 트리 생성"></a>4. 렌더 트리 생성</h2><p>앞선 과정에서 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리로 결합된다. 이 때 <strong>브라우저 화면에 렌더링되지 않는 노드<span style="color:red">(meta태그, script 태그 등)</span>와 CSS에 의해 표시되지 않는<span style="color:red">(display:none)</span> 노드들은 포함하지 않는다.</strong></p><p>지금까지의 렌더링 과정은 여러번 반복되서 실행될 수 있다. <strong>렌더링이 반복 실행되는 원인은 다음과 같다.</strong></p><ul><li>자바스크립트에 의한 노드 추가 또는 삭제</li><li>브라우저 창의 리사이징에 의한 viewport 크기 변경</li><li>HTML 요소의 레이아웃(위치와 크기)을 변경시키는 width, height, margin, padding, border, display, position 등의 스타일 변경</li></ul><p><strong>이러한 리렌더링은 비용이 많이 들고 성능에 악영향을 주므로 <span style="color:red">리렌더링이 적게 발생하도록 하여야한다.</span></strong></p><h2 id="5-자바스크립트-파싱과-실행"><a href="#5-자바스크립트-파싱과-실행" class="headerlink" title="5. 자바스크립트 파싱과 실행"></a>5. 자바스크립트 파싱과 실행</h2><p>HTML 파싱의 결과물 DOM은 HTML 문서의 구조와 정보뿐 아니라 HTML 요소와 스타일을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다.</p><p>즉, DOM API를 사용하여 이미 생성된 DOM을 동적으로 조작할 수 있다.</p><p>CSS 파싱과정과 마찬가지로 script 태그 만나면 DOM 생성을 일시 중단한다.</p><p>이후 자바스크립트 파일을 서버에 요청하여 응답받은 파일이나 script 태그내의 코드를 파싱하기 위해 <strong>자바스크립트 엔진에 제어권을 넘긴다. <span style="color:red">(렌더링 엔진 → 자바스크립트 엔진으로 제어권 이동)</span></strong></p><p>이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권 넘겨 HTML 파싱 중단된 시점부터 DOM 생성을 재개한다.</p><h2 id="6-리플로우와-리페인트"><a href="#6-리플로우와-리페인트" class="headerlink" title="6. 리플로우와 리페인트"></a>6. 리플로우와 리페인트</h2><p>만약 자바스크립트 코드에 DOM, CSSOM을 변경하는 DOM API가 사용된 경우 DOM, CSSOM이 변경되고 변경된 DOM, CSSOM으로 다시 렌더트리로 결합되고 레이아웃과 페인트 과정을 거쳐 브라우저 화면에 다시 렌더링한다. 이를 리플로우, 리페인트라고 한다.</p><blockquote><p>리플로우가 발생하면 성능을 저하시키므로 리플로우가 발생하는 메서드 사용을 최소화 하여야 한다. 일단 가독성 위주로 코딩을 하되 성능 측정하여 렌더링에 2초 이상 걸린다면 리팩터링을 하여 성능을 개선해야한다.</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;브라우저란&quot;&gt;&lt;a href=&quot;#브라우저란&quot; class=&quot;headerlink&quot; title=&quot;브라우저란?&quot;&gt;&lt;/a&gt;브라우저란?&lt;/h1&gt;&lt;p&gt;브라우저는 HTML, CSS, Javascript로 작성된 텍스트 문서를 서버에게 요청하여 응답을 받</summary>
      
    
    
    
    <category term="CS" scheme="https://loco9939.github.io/categories/CS/"/>
    
    
  </entry>
  
</feed>
